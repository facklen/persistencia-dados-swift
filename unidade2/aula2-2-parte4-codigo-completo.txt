================================================================================
AULA 2.2 - PARTE 4: SERVICE LAYER PROFISSIONAL
CÃ“DIGO COMPLETO DE TODOS OS ARQUIVOS
================================================================================

Este arquivo contÃ©m o cÃ³digo completo de todos os arquivos modificados ou
criados nesta aula. Use como referÃªncia durante a implementaÃ§Ã£o.


================================================================================


================================================================================
A. Transaction.swift 
================================================================================
Status: CRIAR na pasta Models/
Linhas totais: ~40 linhas
Usado por: TransactionService e BadTransactionView
================================================================================

//
//  Transaction.swift
//  FinancasApp
//
//  Created by DiÃ³genes Reis on 29/09/25.
//

import Foundation
import FirebaseFirestore

// MARK: - ğŸ’° Modelo de TransaÃ§Ã£o
struct Transaction: Identifiable, Codable {
    @DocumentID var id: String?
    var amount: Double
    var description: String
    var type: TransactionType
    var date: Date
    var userId: String
    
    enum TransactionType: String, Codable, CaseIterable {
        case income = "income"
        case expense = "expense"
        
        var displayName: String {
            switch self {
            case .income: return "Receita"
            case .expense: return "Despesa"
            }
        }
        
        var icon: String {
            switch self {
            case .income: return "arrow.down.circle.fill"
            case .expense: return "arrow.up.circle.fill"
            }
        }
    }
    
    // Inicializador para criar novas transaÃ§Ãµes
    init(amount: Double, description: String, type: TransactionType, userId: String) {
        self.amount = amount
        self.description = description
        self.type = type
        self.date = Date()
        self.userId = userId
    }
}


================================================================================
B. BadTransactionView.swift 
================================================================================
Status: CRIAR ANTES DA AULA na pasta Views/
Linhas totais: ~95 linhas
Usado para: Demonstrar cÃ³digo espaguete (problema)
================================================================================

//
//  BadTransactionView.swift
//  FinancasApp
//
//  Created by DiÃ³genes Reis on 29/09/25.
//

import SwiftUI
import FirebaseFirestore

// âŒ EXEMPLO DE CÃ“DIGO RUIM - NÃƒO USAR EM PRODUÃ‡ÃƒO
// Este cÃ³digo serve apenas para demonstraÃ§Ã£o do problema

struct BadTransactionView: View {
    @State private var transactions: [Transaction] = []
    @State private var isLoading = false
    @State private var errorMessage: String?
    
    var body: some View {
        NavigationView {
            ZStack {
                if isLoading {
                    ProgressView("Carregando...")
                } else if let error = errorMessage {
                    VStack(spacing: 20) {
                        Image(systemName: "exclamationmark.triangle")
                            .font(.system(size: 60))
                            .foregroundColor(.red)
                        Text("Erro ao carregar")
                            .font(.headline)
                        Text(error)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding()
                } else if transactions.isEmpty {
                    VStack(spacing: 20) {
                        Image(systemName: "doc.text")
                            .font(.system(size: 60))
                            .foregroundColor(.gray)
                        Text("Nenhuma transaÃ§Ã£o")
                            .font(.headline)
                        Text("Adicione transaÃ§Ãµes no Firebase Console")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding()
                } else {
                    List(transactions) { transaction in
                        HStack {
                            // Ãcone
                            Image(systemName: transaction.type.icon)
                                .foregroundColor(transaction.type == .income ? .green : .red)
                                .font(.title2)
                            
                            // DescriÃ§Ã£o
                            VStack(alignment: .leading, spacing: 4) {
                                Text(transaction.description)
                                    .font(.headline)
                                Text(transaction.date, style: .date)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            // Valor
                            Text("R$ \(transaction.amount, specifier: "%.2f")")
                                .font(.headline)
                                .foregroundColor(transaction.type == .income ? .green : .red)
                        }
                        .padding(.vertical, 4)
                    }
                }
            }
            .navigationTitle("CÃ³digo Espaguete ğŸ")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: loadTransactions) {
                        Image(systemName: "arrow.clockwise")
                    }
                }
            }
            .onAppear {
                loadTransactions()
            }
        }
    }
    
    // âŒ PROBLEMA: View fazendo TUDO
    // - Conecta diretamente no Firestore
    // - Faz parsing manual
    // - Trata erros de forma bÃ¡sica
    // - LÃ³gica de negÃ³cio misturada com UI
    // - ImpossÃ­vel de testar isoladamente
    // - CÃ³digo duplicado em outras telas
    private func loadTransactions() {
        isLoading = true
        errorMessage = nil
        
        let db = Firestore.firestore()
        
        // ğŸ˜± ConexÃ£o direta sem abstraÃ§Ã£o
        db.collection("transactions").getDocuments { snapshot, error in
            DispatchQueue.main.async {
                self.isLoading = false
                
                if let error = error {
                    // âŒ Error handling bÃ¡sico
                    self.errorMessage = "Erro: \(error.localizedDescription)"
                    print("âŒ Erro ao carregar: \(error)")
                    return
                }
                
                guard let documents = snapshot?.documents else {
                    self.errorMessage = "Nenhum documento encontrado"
                    return
                }
                
                // ğŸ˜± Parsing manual propenso a erros
                var loadedTransactions: [Transaction] = []
                for document in documents {
                    do {
                        let transaction = try document.data(as: Transaction.self)
                        loadedTransactions.append(transaction)
                    } catch {
                        print("âŒ Erro ao decodificar: \(error)")
                    }
                }
                
                self.transactions = loadedTransactions
                print("ğŸ“Š TransaÃ§Ãµes carregadas: \(loadedTransactions.count)")
            }
        }
    }
}

#Preview {
    BadTransactionView()
}


================================================================================
0. ORGANIZAÃ‡ÃƒO DA ESTRUTURA (INÃCIO DA AULA - 0:00 a 0:45)
================================================================================
AÃ‡ÃƒO: Criar Groups no Xcode e organizar arquivos existentes
Tempo: 45 segundos
================================================================================

ğŸ“ ESTRUTURA DE GROUPS A CRIAR NO XCODE:

FinancasApp/
â”œâ”€â”€ App/                          â† NEW GROUP
â”‚   â””â”€â”€ FinancasAppApp.swift     â† MOVER PARA CÃ
â”œâ”€â”€ Views/                        â† NEW GROUP
â”‚   â”œâ”€â”€ ContentView.swift        â† MOVER PARA CÃ
â”‚   â””â”€â”€ BadTransactionView.swift â† MOVER PARA CÃ
â”œâ”€â”€ Models/                       â† NEW GROUP
â”‚   â””â”€â”€ Transaction.swift        â† JÃ ESTÃ AQUI
â”œâ”€â”€ Services/                     â† NEW GROUP (vazio - criar arquivos na aula)
â”œâ”€â”€ Configuration/                â† NEW GROUP
â”‚   â”œâ”€â”€ EnvironmentConfig.swift        â† MOVER PARA CÃ
â”‚   â”œâ”€â”€ FirestoreConfiguration.swift   â† MOVER PARA CÃ
â”‚   â””â”€â”€ ConfigurationValidator.swift   â† MOVER PARA CÃ
â”œâ”€â”€ Managers/                     â† NEW GROUP
â”‚   â””â”€â”€ FirebaseTestManager.swift â† MOVER PARA CÃ
â””â”€â”€ Resources/                    â† NEW GROUP
    â”œâ”€â”€ Assets.xcassets          â† MOVER PARA CÃ
    â””â”€â”€ GoogleService-Info.plist â† MOVER PARA CÃ

PASSOS NO XCODE:
1. Right-click no grupo FinancasApp
2. New Group â†’ "App" (repetir para todas as pastas acima)
3. Arrastar arquivos para os grupos corretos
4. Resultado: Projeto organizado profissionalmente!

ğŸ’¡ RAZÃƒO PEDAGÃ“GICA:
Demonstra que arquitetura profissional comeÃ§a com organizaÃ§Ã£o visual.
Coerente com a mensagem da aula sobre "Service Layer Profissional".


================================================================================
1. FirestoreError.swift - NOVO
================================================================================
Status: CRIAR NOVO ARQUIVO na pasta Services/
Linhas totais: ~45 linhas
Timing: 1:30 - 2:15 (45 segundos de implementaÃ§Ã£o)
================================================================================

//
//  FirestoreError.swift
//  FinancasApp
//
//  Created by [Seu Nome] on [Data]
//

import Foundation

// MARK: - ğŸ›¡ï¸ Sistema de Erros Profissional
/*
 ğŸ“ ERROS CUSTOMIZADOS DO FIRESTORE
 
 ğŸ¯ Por que criar erros customizados:
 â€¢ Mensagens especÃ­ficas e amigÃ¡veis ao usuÃ¡rio
 â€¢ Diferentes tipos de tratamento por tipo de erro
 â€¢ Logs detalhados para debugging
 â€¢ Facilita identificaÃ§Ã£o de problemas em produÃ§Ã£o
 */
enum FirestoreError: LocalizedError {
    case documentNotFound
    case invalidData
    case networkError(Error)
    case permissionDenied
    case quotaExceeded
    case unknown(Error)
    
    // ğŸ“± MENSAGENS AMIGÃVEIS PARA O USUÃRIO
    var errorDescription: String? {
        switch self {
        case .documentNotFound:
            return "Documento nÃ£o encontrado. Verifique se os dados existem."
        case .invalidData:
            return "Dados invÃ¡lidos. Formato nÃ£o suportado."
        case .networkError(let error):
            return "Erro de conexÃ£o: \(error.localizedDescription)"
        case .permissionDenied:
            return "Acesso negado. Verifique suas permissÃµes."
        case .quotaExceeded:
            return "Limite de uso excedido. Tente novamente mais tarde."
        case .unknown(let error):
            return "Erro desconhecido: \(error.localizedDescription)"
        }
    }
}


================================================================================
2. FirestoreService.swift - NOVO
================================================================================
Status: CRIAR NOVO ARQUIVO na pasta Services/
Linhas totais: ~120 linhas
Timing: 2:15 - 3:30 (75 segundos de implementaÃ§Ã£o)
================================================================================

//
//  FirestoreService.swift
//  FinancasApp
//
//  Created by [Seu Nome] on [Data]
//

import Foundation
import FirebaseFirestore

// MARK: - ğŸ”§ Service GenÃ©rico do Firestore
/*
 ğŸ“ SERVICE LAYER BASE - REUTILIZÃVEL
 
 ğŸ¯ Este service Ã© genÃ©rico e funciona com QUALQUER modelo Codable:
 â€¢ Transaction, User, Product, Category, etc.
 â€¢ Uma base sÃ³lida para todos os outros services
 â€¢ Centraliza comunicaÃ§Ã£o com Firestore
 â€¢ Facilita manutenÃ§Ã£o e testes
 */
class FirestoreService {
    private let db = Firestore.firestore()
    
    // MARK: - ğŸ“¥ Buscar Documentos (Generic GET)
    /*
     ğŸ“ MÃ‰TODO GENÃ‰RICO DE LEITURA
     
     ğŸ¯ Funcionalidades:
     â€¢ Funciona com qualquer tipo Codable
     â€¢ Suporta ordenaÃ§Ã£o e limite
     â€¢ Logs educativos para debugging
     â€¢ Error handling robusto
     
     ğŸ’¡ Exemplo de uso:
     let transactions = try await getDocuments(
         from: "transactions",
         type: Transaction.self,
         limit: 10,
         orderBy: "date",
         descending: true
     )
     */
    func getDocuments<T: Codable>(
        from collection: String,
        type: T.Type,
        limit: Int? = nil,
        orderBy field: String? = nil,
        descending: Bool = false
    ) async throws -> [T] {
        print("ğŸ” FirestoreService: Buscando documentos de \(collection)")
        
        do {
            var query: Query = db.collection(collection)
            
            // ğŸ“Š Aplicar ordenaÃ§Ã£o se especificada
            if let orderField = field {
                query = query.order(by: orderField, descending: descending)
                print("   ğŸ“Š Ordenando por: \(orderField) (desc: \(descending))")
            }
            
            // ğŸ”¢ Aplicar limite se especificado
            if let limitCount = limit {
                query = query.limit(to: limitCount)
                print("   ğŸ”¢ Limite: \(limitCount) documentos")
            }
            
            // ğŸŒ Executar query
            let snapshot = try await query.getDocuments()
            
            // ğŸ”„ Decodificar documentos
            let documents = snapshot.documents.compactMap { document -> T? in
                do {
                    let decoded = try document.data(as: type)
                    print("   âœ… Documento decodificado: \(document.documentID)")
                    return decoded
                } catch {
                    print("   âŒ Erro ao decodificar documento \(document.documentID): \(error)")
                    return nil
                }
            }
            
            print("ğŸ“Š Total de documentos carregados: \(documents.count)")
            return documents
            
        } catch {
            print("ğŸ’¥ Erro no FirestoreService: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    // MARK: - ğŸ’¾ Salvar Documento (Generic CREATE/UPDATE)
    /*
     ğŸ“ MÃ‰TODO GENÃ‰RICO DE ESCRITA
     
     ğŸ¯ Funcionalidades:
     â€¢ Cria ou atualiza documentos
     â€¢ Auto-gera ID se nÃ£o fornecido
     â€¢ Retorna o ID do documento salvo
     â€¢ Logs para tracking
     */
    func saveDocument<T: Codable>(
        _ document: T,
        to collection: String,
        documentId: String? = nil
    ) async throws -> String {
        print("ğŸ’¾ FirestoreService: Salvando documento em \(collection)")
        
        do {
            let ref: DocumentReference
            
            if let id = documentId {
                ref = db.collection(collection).document(id)
                print("   ğŸ“ Atualizando documento existente: \(id)")
            } else {
                ref = db.collection(collection).document()
                print("   âœ¨ Criando novo documento com ID: \(ref.documentID)")
            }
            
            try ref.setData(from: document)
            
            print("âœ… Documento salvo com sucesso: \(ref.documentID)")
            return ref.documentID
            
        } catch {
            print("ğŸ’¥ Erro ao salvar documento: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    // MARK: - ğŸ—‘ï¸ Deletar Documento (Generic DELETE)
    func deleteDocument(from collection: String, documentId: String) async throws {
        print("ğŸ—‘ï¸ FirestoreService: Deletando documento \(documentId)")
        
        do {
            try await db.collection(collection).document(documentId).delete()
            print("âœ… Documento deletado com sucesso")
        } catch {
            print("ğŸ’¥ Erro ao deletar: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    // MARK: - ğŸ”„ Mapeamento de Erros
    /*
     ğŸ“ TRADUÃ‡ÃƒO DE ERROS DO FIREBASE
     
     ğŸ¯ Converte erros genÃ©ricos do Firebase em erros especÃ­ficos
     do nosso app, com mensagens amigÃ¡veis.
     */
    private func mapFirebaseError(_ error: Error) -> FirestoreError {
        if let firestoreError = error as? FirestoreErrorCode {
            switch firestoreError.code {
            case .notFound:
                return .documentNotFound
            case .permissionDenied:
                return .permissionDenied
            case .resourceExhausted:
                return .quotaExceeded
            default:
                return .networkError(error)
            }
        }
        return .unknown(error)
    }
}


================================================================================
3. TransactionService.swift - NOVO
================================================================================
Status: CRIAR NOVO ARQUIVO na pasta Services/
Linhas totais: ~90 linhas
Timing: 3:30 - 4:30 (60 segundos de implementaÃ§Ã£o)
================================================================================

//
//  TransactionService.swift
//  FinancasApp
//
//  Created by [Seu Nome] on [Data]
//

import Foundation

// MARK: - ğŸ’¼ Service Especializado de TransaÃ§Ãµes
/*
 ğŸ“ SERVICE COM REGRAS DE NEGÃ“CIO ESPECÃFICAS
 
 ğŸ¯ Por que criar service especializado:
 â€¢ Encapsula regras de negÃ³cio de transaÃ§Ãµes
 â€¢ Usa o FirestoreService genÃ©rico como base
 â€¢ Valida dados antes de salvar
 â€¢ Aplica filtros de negÃ³cio ao carregar
 â€¢ Facilita testes de lÃ³gica de negÃ³cio
 */
class TransactionService {
    private let firestoreService = FirestoreService()
    
    // MARK: - â• Criar TransaÃ§Ã£o
    /*
     ğŸ“ CRIAÃ‡ÃƒO COM VALIDAÃ‡ÃƒO DE NEGÃ“CIO
     
     ğŸ¯ Processo:
     1. Valida dados da transaÃ§Ã£o
     2. Adiciona userId Ã  transaÃ§Ã£o
     3. Salva no path hierÃ¡rquico correto
     4. Retorna ID do documento criado
     */
    func createTransaction(_ transaction: Transaction, for userId: String) async throws -> String {
        print("ğŸ­ TransactionService: Criando transaÃ§Ã£o para user \(userId)")
        
        // âœ… VALIDAÃ‡Ã•ES DE NEGÃ“CIO
        guard isValidTransaction(transaction) else {
            print("âŒ TransaÃ§Ã£o invÃ¡lida - nÃ£o passou nas validaÃ§Ãµes")
            throw FirestoreError.invalidData
        }
        
        // ğŸ“ Adicionar userId Ã  transaÃ§Ã£o
        var transactionWithUser = transaction
        transactionWithUser.userId = userId
        
        // ğŸ—‚ï¸ Path hierÃ¡rquico NoSQL
        let collectionPath = "users/\(userId)/transactions"
        print("   ğŸ“‚ Path: \(collectionPath)")
        
        // ğŸ’¾ Delegar para service genÃ©rico
        let documentId = try await firestoreService.saveDocument(
            transactionWithUser,
            to: collectionPath
        )
        
        print("âœ… TransaÃ§Ã£o criada com sucesso: \(documentId)")
        return documentId
    }
    
    // MARK: - ğŸ“‹ Buscar TransaÃ§Ãµes do UsuÃ¡rio
    /*
     ğŸ“ BUSCA COM FILTROS DE NEGÃ“CIO
     
     ğŸ¯ Processo:
     1. Busca documentos do usuÃ¡rio
     2. Ordena por data (mais recentes primeiro)
     3. Limita quantidade de resultados
     4. Aplica validaÃ§Ãµes de negÃ³cio
     5. Retorna apenas transaÃ§Ãµes vÃ¡lidas
     */
    func getUserTransactions(userId: String, limit: Int = 50) async throws -> [Transaction] {
        print("ğŸ“‹ TransactionService: Buscando transaÃ§Ãµes do usuÃ¡rio \(userId)")
        
        // ğŸ—‚ï¸ Path hierÃ¡rquico
        let collectionPath = "users/\(userId)/transactions"
        
        // ğŸ“¥ Buscar usando service genÃ©rico
        let transactions = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            limit: limit,
            orderBy: "date",
            descending: true
        )
        
        // âœ… Aplicar filtros de negÃ³cio
        let validTransactions = transactions.filter { isValidTransaction($0) }
        
        print("âœ… TransaÃ§Ãµes vÃ¡lidas carregadas: \(validTransactions.count)")
        return validTransactions
    }
    
    // MARK: - ğŸ¯ Regras de NegÃ³cio
    /*
     ğŸ“ VALIDAÃ‡Ã•ES ESPECÃFICAS DE TRANSAÃ‡Ã•ES
     
     ğŸ¯ Regras aplicadas:
     â€¢ Valor deve ser positivo
     â€¢ DescriÃ§Ã£o nÃ£o pode estar vazia
     â€¢ Adicione mais regras conforme necessÃ¡rio
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // ğŸ’° Validar valor
        let isValidAmount = transaction.amount > 0
        
        // ğŸ“ Validar descriÃ§Ã£o
        let isValidDescription = !transaction.description.trimmingCharacters(
            in: .whitespacesAndNewlines
        ).isEmpty
        
        // ğŸ“Š Logs para debugging
        if !isValidAmount {
            print("âš ï¸ TransaÃ§Ã£o invÃ¡lida: valor deve ser positivo")
        }
        
        if !isValidDescription {
            print("âš ï¸ TransaÃ§Ã£o invÃ¡lida: descriÃ§Ã£o nÃ£o pode estar vazia")
        }
        
        return isValidAmount && isValidDescription
    }
    
    // MARK: - ğŸ—‘ï¸ Deletar TransaÃ§Ã£o
    func deleteTransaction(transactionId: String, userId: String) async throws {
        print("ğŸ—‘ï¸ TransactionService: Deletando transaÃ§Ã£o \(transactionId)")
        
        let collectionPath = "users/\(userId)/transactions"
        
        try await firestoreService.deleteDocument(
            from: collectionPath,
            documentId: transactionId
        )
        
        print("âœ… TransaÃ§Ã£o deletada")
    }
}


================================================================================
4. ContentView.swift - MODIFICADO
================================================================================
Status: ARQUIVO EXISTENTE - MODIFICAR mÃ©todo do botÃ£o Service Layer
ModificaÃ§Ãµes: Habilitar botÃ£o e adicionar teste do TransactionService
Timing: 4:30 - 5:30 (60 segundos de implementaÃ§Ã£o)
================================================================================

//
//  ContentView.swift
//  FinancasApp
//
//  Created by DiÃ³genes Reis on 24/09/25.
//

import SwiftUI

struct ContentView: View {
    // ========================================================================
    // âœ… ADICIONAR ESTADOS PARA TESTE DO SERVICE LAYER
    // ========================================================================
    @State private var isTestingService = false
    @State private var serviceTestResult: String = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 30) {
                // CabeÃ§alho
                VStack(spacing: 10) {
                    Image(systemName: "building.columns.fill")
                        .font(.system(size: 80))
                        .foregroundColor(.blue)
                    
                    Text("ğŸ›ï¸ Service Layer Demo")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                    
                    Text("Arquitetura Profissional")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 50)
                
                // DemonstraÃ§Ã£o do Problema
                VStack(spacing: 15) {
                    Text("DemonstraÃ§Ã£o")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    NavigationLink(destination: BadTransactionView()) {
                        HStack {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .foregroundColor(.red)
                            Text("Ver CÃ³digo Espaguete ğŸ")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.red.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    Text("âŒ View fazendo tudo - NÃƒO fazer!")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .padding(.horizontal)
                
                Divider()
                    .padding(.horizontal)
                
                // ================================================================
                // âœ… MODIFICAR ESTA SEÃ‡ÃƒO COMPLETA - SoluÃ§Ã£o Profissional
                // ================================================================
                VStack(spacing: 15) {
                    Text("Service Layer Implementado! ğŸ‰")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Button(action: testServiceLayer) {
                        HStack {
                            if isTestingService {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                            } else {
                                Image(systemName: "checkmark.shield.fill")
                                    .foregroundColor(.green)
                            }
                            Text(isTestingService ? "Testando..." : "Testar Service Layer")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(10)
                    }
                    .disabled(isTestingService)
                    
                    if !serviceTestResult.isEmpty {
                        Text(serviceTestResult)
                            .font(.caption)
                            .foregroundColor(.green)
                            .multilineTextAlignment(.center)
                    } else {
                        Text("âœ… Arquitetura elegante e testÃ¡vel")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .padding(.horizontal)
                
                Spacer()
                
                // InformaÃ§Ã£o de ambiente
                Text(EnvironmentConfig.environmentName)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.bottom)
            }
            .navigationBarHidden(true)
        }
        .task {
            // ğŸ§ª ValidaÃ§Ã£o automÃ¡tica da configuraÃ§Ã£o
            print("ğŸ§ª Executando validaÃ§Ã£o automÃ¡tica...")
            let result = await ConfigurationValidator.validateSetup()
            
            if result.isValid {
                print("ğŸ‰ App pronto para uso!")
            } else {
                print("âš ï¸ \(result.message)")
            }
        }
    }
    
    // ========================================================================
    // âœ… ADICIONAR TODO ESTE MÃ‰TODO NOVO
    // ========================================================================
    // MARK: - ğŸ§ª Teste do Service Layer
    /*
     ğŸ“ DEMONSTRAÃ‡ÃƒO PRÃTICA DO SERVICE LAYER
     
     ğŸ¯ Testa:
     â€¢ CriaÃ§Ã£o de transaÃ§Ã£o usando TransactionService
     â€¢ Busca de transaÃ§Ãµes do usuÃ¡rio
     â€¢ Logs educativos no console
     â€¢ Error handling robusto
     */
    private func testServiceLayer() {
        isTestingService = true
        serviceTestResult = ""
        
        Task {
            do {
                let transactionService = TransactionService()
                
                // ğŸ“ Criar transaÃ§Ã£o de teste
                let newTransaction = Transaction(
                    amount: 50.00,
                    description: "Teste Service Layer",
                    type: .income,
                    userId: "demo_user"
                )
                
                print("ğŸ“ Criando transaÃ§Ã£o de teste...")
                let transactionId = try await transactionService.createTransaction(
                    newTransaction,
                    for: "demo_user"
                )
                
                print("âœ… TransaÃ§Ã£o criada: \(transactionId)")
                
                // ğŸ“‹ Buscar transaÃ§Ãµes
                print("ğŸ“‹ Buscando transaÃ§Ãµes...")
                let transactions = try await transactionService.getUserTransactions(
                    userId: "demo_user"
                )
                
                print("âœ… TransaÃ§Ãµes carregadas: \(transactions.count)")
                
                // âœ… Atualizar UI
                await MainActor.run {
                    serviceTestResult = "âœ… Service Layer funcionando! \(transactions.count) transaÃ§Ãµes carregadas."
                    isTestingService = false
                }
                
            } catch {
                print("âŒ Erro no teste: \(error)")
                
                await MainActor.run {
                    serviceTestResult = "âŒ Erro: \(error.localizedDescription)"
                    isTestingService = false
                }
            }
        }
    }
}

#Preview {
    ContentView()
}


================================================================================
RESUMO DAS MODIFICAÃ‡Ã•ES - AULA 2.2 PARTE 4
================================================================================

ğŸ—‚ï¸ ORGANIZAÃ‡ÃƒO (InÃ­cio da aula - 0:00 a 0:45):
   â€¢ Criar 7 Groups no Xcode: App, Views, Models, Services, Configuration, 
     Managers, Resources
   â€¢ Mover arquivos existentes para groups corretos
   â€¢ Resultado: Estrutura profissional e organizada

âœ¨ ARQUIVOS NOVOS (Criados na Parte 4):
   â€¢ Models/Transaction.swift
   â€¢ Services/FirestoreError.swift (~45 linhas)
   â€¢ Services/FirestoreService.swift (~120 linhas)
   â€¢ Services/TransactionService.swift (~90 linhas)

âœï¸ ARQUIVOS MODIFICADOS (Da Parte 3 para Parte 4):
   â€¢ Views/ContentView.swift
     - Adicionar estados: isTestingService, serviceTestResult
     - Modificar seÃ§Ã£o do botÃ£o Service Layer (habilitar)
     - Adicionar mÃ©todo testServiceLayer() completo

âœ… ARQUIVOS MANTIDOS SEM ALTERAÃ‡ÃƒO:
   â€¢ App/FinancasAppApp.swift
   â€¢ Views/BadTransactionView.swift
   â€¢ Configuration/EnvironmentConfig.swift
   â€¢ Configuration/FirestoreConfiguration.swift
   â€¢ Configuration/ConfigurationValidator.swift
   â€¢ Managers/FirebaseTestManager.swift
   â€¢ Resources/GoogleService-Info.plist


================================================================================
ESTRUTURA FINAL DO PROJETO APÃ“S PARTE 4
================================================================================

FinancasApp/
â”œâ”€â”€ FinancasApp/
â”‚   â”œâ”€â”€ App/
â”‚   â”‚   â””â”€â”€ FinancasAppApp.swift âœ…
â”‚   â”‚
â”‚   â”œâ”€â”€ Views/
â”‚   â”‚   â”œâ”€â”€ ContentView.swift âœ… (modificado)
â”‚   â”‚   â””â”€â”€ BadTransactionView.swift âœ…
â”‚   â”‚
â”‚   â”œâ”€â”€ Models/
â”‚   â”‚   â””â”€â”€ Transaction.swift âœ…
â”‚   â”‚
â”‚   â”œâ”€â”€ Services/ â­ ARQUIVOS CRIADOS NESTA AULA
â”‚   â”‚   â”œâ”€â”€ FirestoreError.swift âœ… NOVO
â”‚   â”‚   â”œâ”€â”€ FirestoreService.swift âœ… NOVO
â”‚   â”‚   â””â”€â”€ TransactionService.swift âœ… NOVO
â”‚   â”‚
â”‚   â”œâ”€â”€ Configuration/
â”‚   â”‚   â”œâ”€â”€ EnvironmentConfig.swift âœ…
â”‚   â”‚   â”œâ”€â”€ FirestoreConfiguration.swift âœ…
â”‚   â”‚   â””â”€â”€ ConfigurationValidator.swift âœ…
â”‚   â”‚
â”‚   â”œâ”€â”€ Managers/
â”‚   â”‚   â””â”€â”€ FirebaseTestManager.swift âœ…
â”‚   â”‚
â”‚   â””â”€â”€ Resources/
â”‚       â”œâ”€â”€ Assets.xcassets âœ…
â”‚       â””â”€â”€ GoogleService-Info.plist âœ…

ğŸ’¡ NOTA: A estrutura em pastas/groups foi criada NO INÃCIO da aula (0:00-0:45)
como parte do ensino de arquitetura profissional.


================================================================================
LOGS ESPERADOS NO CONSOLE APÃ“S IMPLEMENTAÃ‡ÃƒO
================================================================================

ğŸ”¥ Iniciando configuraÃ§Ã£o do Firebase...
ğŸ“Š Ambiente detectado: ğŸ”§ Development
âœ… Arquivo encontrado
âœ… Firebase App inicializado
âš™ï¸ Aplicando configuraÃ§Ãµes avanÃ§adas Firestore...
ğŸ“Š Ambiente: ğŸ”§ Development
   ğŸ“ Cache: 100MB (Development)
   ğŸ“ Debug logging: HABILITADO
âœ… ConfiguraÃ§Ã£o avanÃ§ada aplicada:
   â€¢ Cache offline: ATIVO
   â€¢ Tamanho cache: 100MB
   â€¢ SSL: ATIVO
   â€¢ Ambiente: ğŸ”§ Development
âœ… Firestore otimizado para ğŸ”§ Development
ğŸ‰ ConfiguraÃ§Ã£o completa finalizada!

ğŸ§ª Executando validaÃ§Ã£o automÃ¡tica...
ğŸ§ª Validando configuraÃ§Ã£o avanÃ§ada...
   ğŸ”— Testando conexÃ£o...
   âœ… ConexÃ£o OK
   âš™ï¸ Validando settings aplicados...
   âœ… Settings validados
   ğŸ’¾ Testando operaÃ§Ã£o de escrita...
   âœ… OperaÃ§Ã£o OK
âœ… ValidaÃ§Ã£o completa: SUCESSO!
ğŸ‰ App pronto para uso!

[Ao clicar em "Testar Service Layer"]

ğŸ“ Criando transaÃ§Ã£o de teste...
ğŸ­ TransactionService: Criando transaÃ§Ã£o para user demo_user
   ğŸ“‚ Path: users/demo_user/transactions
ğŸ’¾ FirestoreService: Salvando documento em users/demo_user/transactions
   âœ¨ Criando novo documento com ID: ABC123XYZ
âœ… Documento salvo com sucesso: ABC123XYZ
âœ… TransaÃ§Ã£o criada com sucesso: ABC123XYZ
âœ… TransaÃ§Ã£o criada: ABC123XYZ

ğŸ“‹ Buscando transaÃ§Ãµes...
ğŸ“‹ TransactionService: Buscando transaÃ§Ãµes do usuÃ¡rio demo_user
ğŸ” FirestoreService: Buscando documentos de users/demo_user/transactions
   ğŸ“Š Ordenando por: date (desc: true)
   ğŸ”¢ Limite: 50 documentos
   âœ… Documento decodificado: ABC123XYZ
ğŸ“Š Total de documentos carregados: 1
âœ… TransaÃ§Ãµes vÃ¡lidas carregadas: 1
âœ… TransaÃ§Ãµes carregadas: 1


================================================================================
COMPARAÃ‡ÃƒO: ANTES (CÃ³digo Espaguete) vs DEPOIS (Service Layer)
================================================================================

âŒ ANTES (BadTransactionView):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ View fazendo TUDO
â€¢ ConexÃ£o direta com Firestore na View
â€¢ Error handling bÃ¡sico e genÃ©rico
â€¢ Parsing manual propenso a erros
â€¢ LÃ³gica de negÃ³cio misturada com UI
â€¢ ImpossÃ­vel de testar isoladamente
â€¢ CÃ³digo duplicado em mÃºltiplas telas
â€¢ DifÃ­cil de manter e evoluir

âœ… DEPOIS (Service Layer):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ View focada apenas em UI
â€¢ FirestoreService genÃ©rico reutilizÃ¡vel
â€¢ TransactionService com regras de negÃ³cio
â€¢ Error handling robusto e especÃ­fico
â€¢ SeparaÃ§Ã£o clara de responsabilidades
â€¢ FÃ¡cil de testar (mocks simples)
â€¢ CÃ³digo reutilizado entre telas
â€¢ FÃ¡cil de manter e escalar

Aspecto              | CÃ³digo Espaguete  | Service Layer
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
OrganizaÃ§Ã£o          | Tudo misturado    | Cada classe uma funÃ§Ã£o
Testabilidade        | DifÃ­cil           | FÃ¡cil e rÃ¡pido
ReutilizaÃ§Ã£o         | CÃ³digo duplicado  | Services compartilhados
ManutenÃ§Ã£o           | Quebra tudo       | MudanÃ§as localizadas
Error Handling       | Try/catch bÃ¡sico  | Sistema robusto
Performance          | NÃ£o otimizada     | Cache inteligente
Code Review          | Rejeitado         | Aprovado
NÃ­vel Desenvolvedor  | Junior            | SÃªnior


================================================================================
CONCEITOS-CHAVE IMPLEMENTADOS NA PARTE 4
================================================================================

ğŸ—ï¸ ARQUITETURA:
   âœ… Service Layer Pattern
   âœ… Separation of Concerns
   âœ… Single Responsibility Principle
   âœ… Generic Programming com Swift

ğŸ’¡ BOAS PRÃTICAS:
   âœ… Error handling customizado
   âœ… Logging educativo detalhado
   âœ… ValidaÃ§Ãµes de negÃ³cio centralizadas
   âœ… CÃ³digo auto-documentado

ğŸ§ª TESTABILIDADE:
   âœ… Services isolados e injetÃ¡veis
   âœ… FÃ¡cil criaÃ§Ã£o de mocks
   âœ… LÃ³gica de negÃ³cio testÃ¡vel

ğŸ¯ QUALIDADE:
   âœ… ReutilizaÃ§Ã£o mÃ¡xima de cÃ³digo
   âœ… ManutenÃ§Ã£o facilitada
   âœ… Escalabilidade garantida
   âœ… PadrÃµes da indÃºstria aplicados



================================================================================
FIM DO CÃ“DIGO COMPLETO - AULA 2.2 PARTE 4
================================================================================