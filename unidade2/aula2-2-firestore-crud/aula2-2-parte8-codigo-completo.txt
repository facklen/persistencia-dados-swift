// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ AULA 2.2 - PARTE 8: TESTES E OTIMIZAÃ‡Ã•ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// Este arquivo contÃ©m TODOS os cÃ³digos criados/modificados na Parte 8
// 
// ARQUIVOS CRIADOS:
// 1. Services/StressTestManager.swift
// 2. Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// 3. Services/TransactionService.swift (cache + invalidaÃ§Ãµes)
// 4. Views/RealtimeDemoView.swift (botÃ£o de teste)
// 
// CONFIGURAÃ‡Ã•ES:
// 5. Firebase Security Rules (firestore.rules)
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 1: Services/StressTestManager.swift (CRIAR NOVO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation

// MARK: - ğŸ§ª Stress Test Manager
/*
 âš¡ SIMULADOR DE STRESS TEST PROFISSIONAL
 
 Este gerenciador testa o app sob condiÃ§Ãµes extremas:
 - MÃºltiplas transaÃ§Ãµes simultÃ¢neas (concorrÃªncia)
 - Performance sob carga
 - ValidaÃ§Ã£o de estabilidade
 
 âš ï¸ IMPORTANTE: Use APENAS em ambiente de desenvolvimento!
 Nunca execute em produÃ§Ã£o pois cria dados de teste.
 */
class StressTestManager {
    // ğŸ“¦ DEPENDÃŠNCIAS
    private let transactionService = TransactionService()
    private let testUserId = "stress_test_user_\(UUID().uuidString)"
    
    // MARK: - ğŸ¯ Teste Principal
    /*
     Executa teste de stress com mÃºltiplas transaÃ§Ãµes paralelas.
     
     Como funciona:
     1. Cria 50 tasks simultÃ¢neas
     2. Cada task adiciona uma transaÃ§Ã£o
     3. TaskGroup aguarda todas completarem
     4. Calcula tempo total e sucesso/erro
     */
    func performStressTest() async {
        print("\nğŸ§ª === INICIANDO STRESS TEST ===")
        print("â±ï¸  Timestamp: \(Date())")
        print("ğŸ‘¤ User ID: \(testUserId)")
        print("ğŸ“Š TransaÃ§Ãµes a criar: 50")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
        
        let startTime = Date()
        var successCount = 0
        var errorCount = 0
        
        // ğŸ¯ CRIAR 50 TRANSAÃ‡Ã•ES EM PARALELO
        await withTaskGroup(of: Result<Void, Error>.self) { group in
            for index in 1...50 {
                group.addTask {
                    do {
                        let transaction = Transaction(
                            amount: self.randomAmount(index: index),
                            description: "Teste Stress #\(index)",
                            type: index % 2 == 0 ? .income : .expense,
                            userId: self.testUserId
                        )
                      
                        // Tentar criar no Firestore
                        _ = try await self.transactionService.createTransaction(transaction)
                        print("âœ… [\(index)/50] TransaÃ§Ã£o criada com sucesso")
                        return .success(())
                    } catch {
                        print("âŒ [\(index)/50] ERRO: \(error.localizedDescription)")
                        return .failure(error)
                    }
                }
            }
            
            // â³ AGUARDAR TODAS AS TASKS COMPLETAREM
            for await result in group {
                switch result {
                case .success:
                    successCount += 1
                case .failure:
                    errorCount += 1
                }
            }
        }
        
        // â±ï¸ CALCULAR TEMPO TOTAL
        let endTime = Date()
        let duration = endTime.timeIntervalSince(startTime)
        
        // ğŸ“Š RELATÃ“RIO FINAL
        print("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        print("ğŸ¯ === STRESS TEST CONCLUÃDO ===")
        print("â±ï¸  Tempo total: \(String(format: "%.2f", duration)) segundos")
        print("âœ… Sucessos: \(successCount)")
        print("âŒ Erros: \(errorCount)")
        print("ğŸ“ˆ Taxa de sucesso: \(String(format: "%.1f", Double(successCount) / 50.0 * 100))%")
        print("âš¡ TransaÃ§Ãµes/segundo: \(String(format: "%.2f", 50.0 / duration))")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
        
        // âœ… AVALIAÃ‡ÃƒO DE QUALIDADE
        if successCount == 50 {
            print("ğŸ† EXCELENTE! Sistema aguenta carga pesada!")
        } else if successCount >= 45 {
            print("âœ… BOM! Algumas falhas mas estÃ¡vel")
        } else {
            print("âš ï¸ ATENÃ‡ÃƒO! Taxa de erro elevada - revisar implementaÃ§Ã£o")
        }
    }
    
    // MARK: - ğŸ² Helpers
    private func randomAmount(index: Int) -> Double {
        let base = Double.random(in: 10...1000)
        return index % 2 == 0 ? base : -base
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 2: Services/AdvancedCacheManager.swift (CRIAR NOVO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation

// MARK: - ğŸ’¾ Advanced Cache Manager
/*
 ğŸ¯ SISTEMA DE CACHE INTELIGENTE
 
 Reduz reads do Firestore em atÃ© 95%, economizando custos e melhorando performance.
 
 Funcionalidades:
 - Cache com expiraÃ§Ã£o automÃ¡tica (5 minutos)
 - Limpeza automÃ¡tica de cache antigo
 - Thread-safe (pode ser usado de qualquer lugar)
 - Singleton para acesso global
 */
class AdvancedCacheManager {
    // ğŸŒŸ SINGLETON
    static let shared = AdvancedCacheManager()
    
    // ğŸ“¦ ARMAZENAMENTO
    private var transactionCache: [String: [Transaction]] = [:]
    private var cacheTimestamps: [String: Date] = [:]
    
    // âš™ï¸ CONFIGURAÃ‡ÃƒO
    private let cacheExpirationTime: TimeInterval = 300 // 5 minutos
    
    private init() {
        print("ğŸ’¾ AdvancedCacheManager inicializado")
    }
    
    // MARK: - ğŸ“¥ Salvar no Cache
    func cacheTransactions(_ transactions: [Transaction], for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache[cacheKey] = transactions
        cacheTimestamps[cacheKey] = Date()
        
        print("ğŸ’¾ Cache salvo: \(transactions.count) transaÃ§Ãµes para user \(userId)")
        cleanupExpiredCache()
    }
    
    // MARK: - ğŸ“¤ Recuperar do Cache
    func getCachedTransactions(for userId: String) -> [Transaction]? {
        let cacheKey = "transactions_\(userId)"
        
        guard let timestamp = cacheTimestamps[cacheKey],
              let transactions = transactionCache[cacheKey] else {
            print("ğŸ’¾ Cache MISS - nÃ£o existe para user \(userId)")
            return nil
        }
        
        let age = Date().timeIntervalSince(timestamp)
        
        if age < cacheExpirationTime {
            print("ğŸ’¾ Cache HIT - \(transactions.count) transaÃ§Ãµes (\(Int(age))s de idade)")
            return transactions
        } else {
            print("ğŸ’¾ Cache EXPIRADO - idade: \(Int(age))s")
            transactionCache.removeValue(forKey: cacheKey)
            cacheTimestamps.removeValue(forKey: cacheKey)
            return nil
        }
    }
    
    // MARK: - ğŸ§¹ Limpeza AutomÃ¡tica
    private func cleanupExpiredCache() {
        let now = Date()
        var cleanedCount = 0
        
        for (key, timestamp) in cacheTimestamps {
            let age = now.timeIntervalSince(timestamp)
            if age > cacheExpirationTime {
                transactionCache.removeValue(forKey: key)
                cacheTimestamps.removeValue(forKey: key)
                cleanedCount += 1
            }
        }
        
        if cleanedCount > 0 {
            print("ğŸ§¹ Limpeza: \(cleanedCount) cache(s) expirado(s) removido(s)")
        }
    }
    
    // MARK: - ğŸ—‘ï¸ Invalidar Cache
    func invalidateCache(for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache.removeValue(forKey: cacheKey)
        cacheTimestamps.removeValue(forKey: cacheKey)
        print("ğŸ—‘ï¸ Cache invalidado para user \(userId)")
    }
    
    // MARK: - ğŸ“Š EstatÃ­sticas
    func printCacheStats() {
        print("\nğŸ“Š === ESTATÃSTICAS DO CACHE ===")
        print("ğŸ“¦ Caches ativos: \(transactionCache.count)")
        print("â° Timestamps: \(cacheTimestamps.count)")
        
        for (key, timestamp) in cacheTimestamps {
            let age = Date().timeIntervalSince(timestamp)
            let remaining = Int(cacheExpirationTime - age)
            print("  â€¢ \(key): \(Int(age))s, expira em \(max(0, remaining))s")
        }
        print("================================\n")
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 3: Services/TransactionService.swift (MODIFICAR)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// âš ï¸ MODIFICAÃ‡Ã•ES NECESSÃRIAS:
// 1. Corrigir isValidTransaction para aceitar valores negativos
// 2. Alterar funÃ§Ã£o getUserTransactions() para usar cache
// 3. Adicionar invalidateCache() em create, update e delete
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation
import FirebaseFirestore

// MARK: - ğŸ’¼ Service Especializado de TransaÃ§Ãµes
/*
 ğŸ“ SERVICE COM REGRAS DE NEGÃ“CIO ESPECÃFICAS
 
 ğŸ¯ Por que criar service especializado:
 â€¢ Encapsula regras de negÃ³cio de transaÃ§Ãµes
 â€¢ Usa o FirestoreService genÃ©rico como base
 â€¢ Valida dados antes de salvar
 â€¢ Aplica filtros de negÃ³cio ao carregar
 â€¢ Facilita testes de lÃ³gica de negÃ³cio
 */
class TransactionService {
    private let firestoreService = FirestoreService()
    
    // Adicionar propriedade de cache na classe - Parte 8:
    private let cacheManager = AdvancedCacheManager.shared // âœ… Usar singleton
    
    // MARK: - â• Criar TransaÃ§Ã£o
    /*
     ğŸ“ CRIAÃ‡ÃƒO COM VALIDAÃ‡ÃƒO DE NEGÃ“CIO
     
     ğŸ¯ Processo:
     1. Valida dados da transaÃ§Ã£o
     2. Adiciona userId Ã  transaÃ§Ã£o
     3. Salva no path hierÃ¡rquico correto
     4. Retorna ID do documento criado
     */
    func createTransaction(_ transaction: Transaction, for userId: String) async throws -> String {
        print("ğŸ­ TransactionService: Criando transaÃ§Ã£o para user \(userId)")
        
        // âœ… VALIDAÃ‡Ã•ES DE NEGÃ“CIO
        guard isValidTransaction(transaction) else {
            print("âŒ TransaÃ§Ã£o invÃ¡lida - nÃ£o passou nas validaÃ§Ãµes")
            throw FirestoreError.invalidData
        }
        
        // ğŸ“ Adicionar userId Ã  transaÃ§Ã£o
        var transactionWithUser = transaction
        transactionWithUser.userId = userId
        
        // ğŸ—‚ï¸ Path hierÃ¡rquico NoSQL
        let collectionPath = "users/\(userId)/transactions"
        print("   ğŸ“‚ Path: \(collectionPath)")
        
        // ğŸ’¾ Delegar para service genÃ©rico
        let documentId = try await firestoreService.saveDocument(
            transactionWithUser,
            to: collectionPath
        )
        
        print("âœ… TransaÃ§Ã£o criada com sucesso: \(documentId)")
        
        // Invalidar cache apÃ³s CREATE:
        cacheManager.invalidateCache(for: userId)
        
        return documentId
    }
    
    // MARK: - ğŸ“‹ Buscar TransaÃ§Ãµes do UsuÃ¡rio - (âœ… NOVO - PARTE 8)
    func getUserTransactions(userId: String, limit: Int = 50) async throws -> [Transaction] {
        print("ğŸ“‹ TransactionService: Buscando transaÃ§Ãµes do usuÃ¡rio \(userId)")
        
        // 1ï¸âƒ£ Verificar cache primeiro
        if let cached = cacheManager.getCachedTransactions(for: userId) {
            return cached
        }
        

        // 2ï¸âƒ£ Se nÃ£o tem cache, buscar do Firestore
        let collectionPath = "users/\(userId)/transactions"
        let transactions = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            limit: limit,
            orderBy: "date",
            descending: true
        )

        // âœ… Aplicar filtros de negÃ³cio
        let validTransactions = transactions
            .filter { isValidTransaction($0) }
            .filter { !$0.isDeleted }

        // 3ï¸âƒ£ Salvar no cache
        cacheManager.cacheTransactions(validTransactions, for: userId)


        print("âœ… TransaÃ§Ãµes carregadas e cacheadas: \(validTransactions.count)")
        
        return validTransactions
    }
    
    
    // MARK: - READ Including Deleted (âœ… NOVO - PARTE 5)
        /*
         ğŸ“– BUSCAR TODAS AS TRANSAÃ‡Ã•ES (INCLUINDO DELETADAS)
         
         Ãštil para:
         - AdministraÃ§Ã£o e auditoria
         - RelatÃ³rios completos
         - RecuperaÃ§Ã£o de dados
         - AnÃ¡lise de histÃ³rico completo
         */
        func getAllTransactionsIncludingDeleted(
            userId: String,
            limit: Int = 50
        ) async throws -> [Transaction] {
            print("ğŸ“– TransactionService: Buscando TODAS transaÃ§Ãµes (incluindo deletadas)")
            print("  ğŸ“ Limite: \(limit)")
            
            let collectionPath = "users/\(userId)/transactions"
            
            let transactions: [Transaction] = try await firestoreService.getDocuments(
                from: collectionPath,
                type: Transaction.self,
                limit: limit,
                orderBy: "date",
                descending: true
            )
            
            // SÃ³ valida, mas NÃƒO filtra deletados
            let validTransactions = transactions.filter { isValidTransaction($0) }
            
            print("âœ… \(validTransactions.count) transaÃ§Ãµes totais (incluindo deletadas)")
            return validTransactions
        }
    
    // MARK: - ğŸ¯ Regras de NegÃ³cio
    /*
     ğŸ“ VALIDAÃ‡Ã•ES ESPECÃFICAS DE TRANSAÃ‡Ã•ES
     
     ğŸ¯ Regras aplicadas:
     â€¢ Valor deve ser positivo
     â€¢ DescriÃ§Ã£o nÃ£o pode estar vazia
     â€¢ Adicione mais regras conforme necessÃ¡rio
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // âŒ ANTES: guard transaction.amount > 0// âœ… AGORA:
        guard transaction.amount != 0 else {
           print("âŒ Valor invÃ¡lido: \(transaction.amount)")
           return false
        }
            
        // 2. Description nÃ£o pode estar vazia
        guard !transaction.description.isEmpty else {
            print("âŒ ValidaÃ§Ã£o falhou: descriÃ§Ã£o vazia")
            return false
        }
            
        // 3. Data nÃ£o pode ser futura (nova validaÃ§Ã£o!)
        guard transaction.date <= Date() else {
            print("âŒ Data futura: \(transaction.date)")
            return false
        }
            
        return true
    }
    
    // MARK: - ğŸ—‘ï¸ Deletar TransaÃ§Ã£o
    func deleteTransaction(
        transactionId: String,
        userId: String,
        soft: Bool = true  // ğŸ·ï¸ PadrÃ£o: soft delete
    ) async throws {
        let collectionPath = "users/\(userId)/transactions"
        
        if soft {
            // ğŸ·ï¸ SOFT DELETE: marca isDeleted
            print("ğŸ·ï¸ TransactionService: Soft delete de \(transactionId)")
            
            // Buscar documento atual
            var transaction = try await firestoreService.getDocument(
                transactionId,
                from: collectionPath,
                as: Transaction.self
            )
            
            // Marcar como deletado
            transaction.isDeleted = true
            transaction.deletedAt = Date()
            
            // Atualizar com as flags
            try await firestoreService.updateDocument(
                transaction,
                documentId: transactionId,
                in: collectionPath
            )
            
            print("âœ… Soft delete concluÃ­do")
            print("  ğŸ“… deletedAt: \(transaction.deletedAt!)")
            
        } else {
            // ğŸ—‘ï¸ HARD DELETE: remove permanentemente
            print("ğŸ—‘ï¸ TransactionService: Hard delete de \(transactionId)")
            
            try await firestoreService.deleteDocument(
                from: collectionPath,
                documentId: transactionId
            )
            
            print("âœ… Hard delete concluÃ­do - documento removido permanentemente")
        }
        // Invalidar cache apÃ³s DELETE:
        cacheManager.invalidateCache(for: userId)
    }
    
    func updateTransaction(_ transaction: Transaction) async throws {
        print("âœï¸ TransactionService: Atualizando transaÃ§Ã£o")
        
        // ğŸ”’ VALIDAR ID
        guard let id = transaction.id else {
            print("âŒ Erro: TransaÃ§Ã£o deve ter ID para atualizaÃ§Ã£o")
            throw FirestoreError.invalidData
        }
        
        // ğŸ›¡ï¸ VALIDAR DADOS (preventivo!)
        guard isValidTransaction(transaction) else {
            print("âŒ Erro: Dados invÃ¡lidos")
            throw FirestoreError.invalidData
        }
        
        // â° ATUALIZAR TIMESTAMP
        var updatedTransaction = transaction
        updatedTransaction.updatedAt = Date()
        
        let collectionPath = "users/\(transaction.userId)/transactions"
        
        try await firestoreService.updateDocument(
            updatedTransaction,
            documentId: id,
            in: collectionPath,
            merge: true  // âš¡ MERGE INTELIGENTE - preserva campos nÃ£o enviados
        )
        
        print("âœ… TransaÃ§Ã£o atualizada com sucesso")
        print("  ğŸ“… updatedAt: \(updatedTransaction.updatedAt)")
        
        // Invalidar cache apÃ³s UPDATE:
        cacheManager.invalidateCache(for: transaction.userId)
    }
    
    // MARK: - ğŸ”„ Real-time Listeners (âœ¨ PARTE 6 - NOVO!)
    
    /*
     ğŸ‘‚ LISTENER PARA TRANSAÃ‡Ã•ES EM TEMPO REAL
     
     Escuta mudanÃ§as em tempo real e notifica a UI automaticamente.
     Implementa padrÃ£o Observer para sincronizaÃ§Ã£o automÃ¡tica.
     
     ğŸ¯ Como funciona:
     1. Registra interesse nesta query (addSnapshotListener)
     2. Firebase detecta writes/deletes que afetam query
     3. Servidor envia diff (sÃ³ o que mudou) via WebSocket
     4. Closure Ã© executada AUTOMATICAMENTE
     5. UI atualiza sem usuÃ¡rio fazer nada!
     
     ğŸ¯ ParÃ¢metros:
     - userId: ID do usuÃ¡rio proprietÃ¡rio das transaÃ§Ãµes
     - limit: Limite de documentos (padrÃ£o 50 para performance)
     - onUpdate: Closure chamada quando dados mudam (fornece [Transaction])
     - onError: Closure chamada quando ocorre erro
     
     âœ… Retorna: ListenerRegistration para cleanup posterior
     
     âš ï¸ CRÃTICO:
     - SEMPRE chamar listener.remove() quando nÃ£o precisar mais!
     - Usar [weak self] na closure para evitar retain cycle
     - Usar DispatchQueue.main.async para atualizar UI
     */
    func startListeningToUserTransactions(
        userId: String,
        limit: Int = 50,
        onUpdate: @escaping ([Transaction]) -> Void,
        onError: @escaping (Error) -> Void
    ) -> ListenerRegistration {
        
        print("ğŸ‘‚ === INICIANDO LISTENER TEMPO REAL ===")
        print("ğŸ‘¤ UsuÃ¡rio: \(userId)")
        print("ğŸ“ Limite: \(limit) transaÃ§Ãµes")
        print("ğŸ¯ Objetivo: SincronizaÃ§Ã£o automÃ¡tica em tempo real")
        
        // ğŸ—„ï¸ CONSTRUIR QUERY OTIMIZADA
        let db = Firestore.firestore()
        let query = db.collection("users")
            .document(userId)
            .collection("transactions")
            .order(by: "date", descending: true)  // Mais recentes primeiro
            .limit(to: limit)                     // Limitar para performance
        
        print("ğŸ“ Query construÃ­da: users/\(userId)/transactions")
        print("ğŸ”„ Listener ativo - aguardando mudanÃ§as...")
        
        // ğŸ‘‚ ADICIONAR LISTENER (A MÃGICA ACONTECE AQUI!)
        /*
         ğŸ“ addSnapshotListener Ã© o coraÃ§Ã£o do tempo real:
         
         O que acontece:
         1. Firestore "marca" esta query como "interessante"
         2. Toda vez que dados desta query mudam, Firestore avisa
         3. A closure abaixo Ã© executada AUTOMATICAMENTE
         4. Recebemos snapshot com dados atualizados
         
         Ã‰ como assinar notificaÃ§Ãµes push, mas para dados!
         
         Esta closure executa:
         - IMEDIATAMENTE (dados iniciais)
         - TODA VEZ que algo mudar
         - AUTOMATICAMENTE sem a gente chamar nada!
         */
        let listener = query.addSnapshotListener { [weak self] snapshot, error in
            
            // ğŸš¨ TRATAMENTO DE ERRO
            if let error = error {
                print("âŒ Erro no listener: \(error.localizedDescription)")
                
                
                // ğŸ¯ NOTIFICAR ERRO NA THREAD PRINCIPAL
                /*
                 âš ï¸ CRÃTICO: onError atualiza @Published properties na UI!
                 Precisa executar na main thread, assim como onUpdate.
                 
                 Sem isso: Crash "UIKit must be accessed from main thread"
                 */
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
                return
            }
            
            // ğŸ“„ VERIFICAR SNAPSHOT
            guard let snapshot = snapshot else {
                print("âš ï¸ Snapshot vazio recebido")
                DispatchQueue.main.async {
                    onUpdate([])
                }
                return
            }
            
            print("ğŸ“¦ Snapshot recebido: \(snapshot.documents.count) documentos")
            
            // ğŸ¯ CONVERTER DOCUMENTOS PARA OBJETOS SWIFT
            do {
                // Codable faz a mÃ¡gica: Firebase JSON â†’ Swift Object
                let allTransactions = try snapshot.documents.map { document in
                    try document.data(as: Transaction.self)
                }
                
                print("âœ… Convertidos: \(allTransactions.count) transaÃ§Ãµes")
                
                // ğŸ·ï¸ FILTRAR DELETADOS (soft delete - Parte 5!)
                /*
                 Por padrÃ£o, nÃ£o mostramos transaÃ§Ãµes deletadas.
                 isDeleted Ã© do modelo atualizado na Parte 5.
                 */
                let activeTransactions = allTransactions.filter { !$0.isDeleted }
                
                print("ğŸ·ï¸ Filtradas: \(activeTransactions.count) ativas (sem deletadas)")
                
                // ğŸ›¡ï¸ VALIDAR DADOS (defesa em profundidade)
                /*
                 Dupla validaÃ§Ã£o:
                 1. Antes de salvar (preventiva)
                 2. Depois de buscar (garantia)
                 
                 Protege contra dados corrompidos ou regras mudadas.
                 */
                let validTransactions = activeTransactions.filter {
                    self?.isValidTransaction($0) ?? true
                }
                
                print("âœ… Validadas: \(validTransactions.count) transaÃ§Ãµes vÃ¡lidas")
                
                // ğŸ¯ NOTIFICAR UI NA THREAD PRINCIPAL
                /*
                 âš ï¸ CRÃTICO: UI sÃ³ pode ser atualizada na main thread!
                 
                 Listener executa em background thread (Firebase decide).
                 Temos que voltar pra main thread antes de atualizar UI.
                 
                 Sem isso: CRASH garantido!
                 "UIKit must be accessed from main thread"
                 */
                DispatchQueue.main.async {
                    onUpdate(validTransactions)
                }
                
                print("ğŸ¨ UI notificada com \(validTransactions.count) transaÃ§Ãµes")
                
            } catch {
                print("âŒ Erro ao converter documentos: \(error)")
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
            }
        }
        
        print("ğŸ“Œ Listener registrado com sucesso")
        print("âš¡ SincronizaÃ§Ã£o automÃ¡tica ATIVA!")
        
        // âœ… RETORNAR LISTENER PARA CLEANUP POSTERIOR
        /*
         âš ï¸ IMPORTANTE: Este listener precisa ser REMOVIDO quando nÃ£o for mais necessÃ¡rio!
         
         Sem remoÃ§Ã£o = MEMORY LEAK:
         - Listener continua rodando
         - Consome recursos
         - App fica lento
         - Pode travar
         
         Sempre guardar este return e chamar .remove() depois!
         
         Pattern recomendado:
         1. Guardar em var listener: ListenerRegistration?
         2. Chamar listener?.remove() em stopListening()
         3. Ter deinit que chama stopListening() (rede de seguranÃ§a)
         */
        return listener
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 4: Views/RealtimeDemoView.swift (MODIFICAR)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// âš ï¸ ADICIONAR botÃ£o de teste APÃ“S o .toolbar { } e ANTES do .onAppear
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import SwiftUI

struct RealtimeDemoView: View {
    @StateObject private var viewModel = RealtimeDemoViewModel()
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {

                    // ğŸ”Œ STATUS DE CONEXÃƒO
                    HStack {
                        Circle()
                            .fill(viewModel.isListening ? Color.green : Color.gray)
                            .frame(width: 8, height: 8)

                        Text(viewModel.isListening ? "Tempo Real Ativo" : "Offline")
                            .font(.caption)
                            .foregroundColor(.secondary)

                        Spacer()
                    }
                    .padding(.horizontal)

                    // ğŸ’° HEADER COM BALANÃ‡O
                    BalanceHeaderView(
                        totalBalance: viewModel.totalBalance,
                        totalIncome: viewModel.totalIncome,
                        totalExpenses: viewModel.totalExpenses,
                        formatter: viewModel.formatCurrency
                    )

                    // ğŸ“Š ESTATÃSTICAS
                    VStack(spacing: 8) {
                        HStack(spacing: 12) {
                            StatisticsCardView(
                                icon: "chart.bar.fill",
                                title: "TransaÃ§Ãµes",
                                value: "\(viewModel.transactionCount)",
                                color: .blue
                            )

                            StatisticsCardView(
                                icon: "chart.line.uptrend.xyaxis",
                                title: "MÃ©dia de Gastos",
                                value: viewModel.formatCurrency(viewModel.averageExpense),
                                color: .orange
                            )
                        }
                    }
                    .padding(.horizontal)

                    // ğŸ“‹ LISTA DE TRANSAÃ‡Ã•ES
                    VStack(alignment: .leading, spacing: 12) {
                        Text("TransaÃ§Ãµes Recentes")
                            .font(.headline)
                            .padding(.horizontal)

                        if viewModel.transactions.isEmpty {
                            EmptyStateView()
                                .frame(height: 300)
                        } else {
                            ForEach(viewModel.transactions.prefix(20)) { transaction in
                                TransactionCardView(
                                    transaction: transaction,
                                    formatter: viewModel.formatCurrency,
                                    dateFormatter: viewModel.formatDate
                                )
                                .padding(.horizontal)
                            }
                        }
                    }

                    Spacer(minLength: 20)
                }
                .padding(.vertical)
            }
            .navigationTitle("ğŸ’« Dashboard")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        viewModel.isListening ? viewModel.stopListening() : viewModel.startListening()
                    }) {
                        Image(systemName: viewModel.isListening ? "pause.circle.fill" : "play.circle.fill")
                            .foregroundColor(viewModel.isListening ? .orange : .green)
                    }
                }
            }
            
            // MARK: - ğŸ¨ BotÃ£o de Teste na UI (âœ¨ NOVO NA PARTE 8)
            // ğŸ“ ADICIONAR ESTE CÃ“DIGO APÃ“S O FECHAMENTO DO .toolbar:

            #if DEBUG
            .safeAreaInset(edge: .bottom) {
                Button(action: {
                    Task {
                        let tester = StressTestManager()
                        await tester.performStressTest()
                    }
                }) {
                    Label("ğŸ§ª Executar Stress Test", systemImage: "bolt.fill")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.orange)
                        .cornerRadius(12)
                }
                .padding()
                .background(Color(UIColor.systemBackground))
            }
            #endif
            
        }
        .onAppear {
            print("ğŸ“± Dashboard apareceu - iniciando listener")
            viewModel.startListening()
        }
        .onDisappear {
            print("ğŸ“± Dashboard desapareceu - parando listener")
            viewModel.stopListening()
        }
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 5: firestore.rules (CONFIGURAR NO FIREBASE CONSOLE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// ğŸ“ ONDE: Firebase Console â†’ Firestore Database â†’ Rules
// ğŸ“ AÃ‡ÃƒO: Substituir TODAS as rules por estas:
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rules_version = '2';

/*
ğŸ›¡ï¸ FIRESTORE SECURITY RULES - PRODUÃ‡ÃƒO

Estas rules protegem dados com validaÃ§Ãµes server-side.
NUNCA podem ser burladas pelo cliente.

PrincÃ­pios:
- AutenticaÃ§Ã£o obrigatÃ³ria
- Cada usuÃ¡rio acessa apenas SEUS dados
- ValidaÃ§Ãµes rigorosas em todas operaÃ§Ãµes
- Negar por padrÃ£o
*/

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ğŸš« REGRA PADRÃƒO: NEGAR TUDO
    match /{document=**} {
      allow read, write: if false;
    }
    
    // ğŸ‘¤ USUÃRIOS: Somente prÃ³prio usuÃ¡rio
    match /users/{userId} {
      allow read, write: if request.auth != null 
                         && request.auth.uid == userId;
      
      // ğŸ’° TRANSAÃ‡Ã•ES: Subcollection com validaÃ§Ãµes
      match /transactions/{transactionId} {
        
        // ğŸ“– READ: Apenas prÃ³prio usuÃ¡rio
        allow read: if request.auth != null 
                    && request.auth.uid == userId;
        
        // â• CREATE: ValidaÃ§Ã£o completa
        allow create: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId);
        
        // âœï¸ UPDATE: ValidaÃ§Ã£o + nÃ£o pode mudar dono
        allow update: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId)
                      && resource.data.userId == request.resource.data.userId;
        
        // ğŸ—‘ï¸ DELETE: Apenas prÃ³prio usuÃ¡rio
        allow delete: if request.auth != null 
                      && request.auth.uid == userId;
      }
    }
    
    // ğŸ·ï¸ CATEGORIAS: Apenas leitura
    match /categories/{categoryId} {
      allow read: if request.auth != null;
      allow write: if false;
    }
    
    // ğŸ›¡ï¸ FUNÃ‡ÃƒO DE VALIDAÃ‡ÃƒO
    function isValidTransaction(data, expectedUserId) {
      return data.keys().hasAll(['amount', 'description', 'categoryId', 'type', 'userId', 'date'])
             && data.amount is number
             && data.amount != 0
             && data.amount > -1000000
             && data.amount < 1000000
             && data.description is string
             && data.description.size() > 0
             && data.description.size() <= 200
             && data.categoryId is string
             && data.categoryId.size() > 0
             && data.type is string
             && data.type in ['income', 'expense']
             && data.userId is string
             && data.userId == expectedUserId
             && data.date is timestamp;
    }
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… CHECKLIST DE IMPLEMENTAÃ‡ÃƒO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// ARQUIVOS CRIADOS:
// [ ] Services/StressTestManager.swift
// [ ] Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// [ ] Services/TransactionService.swift - loadTransactions com cache
// [ ] Services/TransactionService.swift - invalidaÃ§Ãµes em create/update/delete
// [ ] Views/RealtimeDemoView.swift - botÃ£o de teste
// 
// CONFIGURAÃ‡Ã•ES:
// [ ] Firebase Console - Security Rules publicadas
// 
// TESTES:
// [ ] Stress test executando (50 transaÃ§Ãµes)
// [ ] Cache funcionando (hit/miss nos logs)
// [ ] Security rules bloqueando dados invÃ¡lidos
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
