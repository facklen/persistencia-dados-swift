// ═══════════════════════════════════════════════════════════════════
// 📦 AULA 2.2 - PARTE 8: TESTES E OTIMIZAÇÕES
// ═══════════════════════════════════════════════════════════════════
// 
// Este arquivo contém TODOS os códigos criados/modificados na Parte 8
// 
// ARQUIVOS CRIADOS:
// 1. Services/StressTestManager.swift
// 2. Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// 3. Services/TransactionService.swift (cache + invalidações)
// 4. Views/RealtimeDemoView.swift (botão de teste)
// 
// CONFIGURAÇÕES:
// 5. Firebase Security Rules (firestore.rules)
// 
// ═══════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 1: Services/StressTestManager.swift (CRIAR NOVO)
// ═══════════════════════════════════════════════════════════════════

import Foundation

// MARK: - 🧪 Stress Test Manager
/*
 ⚡ SIMULADOR DE STRESS TEST PROFISSIONAL
 
 Este gerenciador testa o app sob condições extremas:
 - Múltiplas transações simultâneas (concorrência)
 - Performance sob carga
 - Validação de estabilidade
 
 ⚠️ IMPORTANTE: Use APENAS em ambiente de desenvolvimento!
 Nunca execute em produção pois cria dados de teste.
 */
class StressTestManager {
    // 📦 DEPENDÊNCIAS
    private let transactionService = TransactionService()
    private let testUserId = "stress_test_user_\(UUID().uuidString)"
    
    // MARK: - 🎯 Teste Principal
    /*
     Executa teste de stress com múltiplas transações paralelas.
     
     Como funciona:
     1. Cria 50 tasks simultâneas
     2. Cada task adiciona uma transação
     3. TaskGroup aguarda todas completarem
     4. Calcula tempo total e sucesso/erro
     */
    func performStressTest() async {
        print("\n🧪 === INICIANDO STRESS TEST ===")
        print("⏱️  Timestamp: \(Date())")
        print("👤 User ID: \(testUserId)")
        print("📊 Transações a criar: 50")
        print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
        
        let startTime = Date()
        var successCount = 0
        var errorCount = 0
        
        // 🎯 CRIAR 50 TRANSAÇÕES EM PARALELO
        await withTaskGroup(of: Result<Void, Error>.self) { group in
            for index in 1...50 {
                group.addTask {
                    do {
                        let transaction = Transaction(
                            amount: self.randomAmount(index: index),
                            description: "Teste Stress #\(index)",
                            type: index % 2 == 0 ? .income : .expense,
                            userId: self.testUserId
                        )
                      
                        // Tentar criar no Firestore
                        _ = try await self.transactionService.createTransaction(transaction)
                        print("✅ [\(index)/50] Transação criada com sucesso")
                        return .success(())
                    } catch {
                        print("❌ [\(index)/50] ERRO: \(error.localizedDescription)")
                        return .failure(error)
                    }
                }
            }
            
            // ⏳ AGUARDAR TODAS AS TASKS COMPLETAREM
            for await result in group {
                switch result {
                case .success:
                    successCount += 1
                case .failure:
                    errorCount += 1
                }
            }
        }
        
        // ⏱️ CALCULAR TEMPO TOTAL
        let endTime = Date()
        let duration = endTime.timeIntervalSince(startTime)
        
        // 📊 RELATÓRIO FINAL
        print("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
        print("🎯 === STRESS TEST CONCLUÍDO ===")
        print("⏱️  Tempo total: \(String(format: "%.2f", duration)) segundos")
        print("✅ Sucessos: \(successCount)")
        print("❌ Erros: \(errorCount)")
        print("📈 Taxa de sucesso: \(String(format: "%.1f", Double(successCount) / 50.0 * 100))%")
        print("⚡ Transações/segundo: \(String(format: "%.2f", 50.0 / duration))")
        print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
        
        // ✅ AVALIAÇÃO DE QUALIDADE
        if successCount == 50 {
            print("🏆 EXCELENTE! Sistema aguenta carga pesada!")
        } else if successCount >= 45 {
            print("✅ BOM! Algumas falhas mas estável")
        } else {
            print("⚠️ ATENÇÃO! Taxa de erro elevada - revisar implementação")
        }
    }
    
    // MARK: - 🎲 Helpers
    private func randomAmount(index: Int) -> Double {
        let base = Double.random(in: 10...1000)
        return index % 2 == 0 ? base : -base
    }
}


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 2: Services/AdvancedCacheManager.swift (CRIAR NOVO)
// ═══════════════════════════════════════════════════════════════════

import Foundation

// MARK: - 💾 Advanced Cache Manager
/*
 🎯 SISTEMA DE CACHE INTELIGENTE
 
 Reduz reads do Firestore em até 95%, economizando custos e melhorando performance.
 
 Funcionalidades:
 - Cache com expiração automática (5 minutos)
 - Limpeza automática de cache antigo
 - Thread-safe (pode ser usado de qualquer lugar)
 - Singleton para acesso global
 */
class AdvancedCacheManager {
    // 🌟 SINGLETON
    static let shared = AdvancedCacheManager()
    
    // 📦 ARMAZENAMENTO
    private var transactionCache: [String: [Transaction]] = [:]
    private var cacheTimestamps: [String: Date] = [:]
    
    // ⚙️ CONFIGURAÇÃO
    private let cacheExpirationTime: TimeInterval = 300 // 5 minutos
    
    private init() {
        print("💾 AdvancedCacheManager inicializado")
    }
    
    // MARK: - 📥 Salvar no Cache
    func cacheTransactions(_ transactions: [Transaction], for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache[cacheKey] = transactions
        cacheTimestamps[cacheKey] = Date()
        
        print("💾 Cache salvo: \(transactions.count) transações para user \(userId)")
        cleanupExpiredCache()
    }
    
    // MARK: - 📤 Recuperar do Cache
    func getCachedTransactions(for userId: String) -> [Transaction]? {
        let cacheKey = "transactions_\(userId)"
        
        guard let timestamp = cacheTimestamps[cacheKey],
              let transactions = transactionCache[cacheKey] else {
            print("💾 Cache MISS - não existe para user \(userId)")
            return nil
        }
        
        let age = Date().timeIntervalSince(timestamp)
        
        if age < cacheExpirationTime {
            print("💾 Cache HIT - \(transactions.count) transações (\(Int(age))s de idade)")
            return transactions
        } else {
            print("💾 Cache EXPIRADO - idade: \(Int(age))s")
            transactionCache.removeValue(forKey: cacheKey)
            cacheTimestamps.removeValue(forKey: cacheKey)
            return nil
        }
    }
    
    // MARK: - 🧹 Limpeza Automática
    private func cleanupExpiredCache() {
        let now = Date()
        var cleanedCount = 0
        
        for (key, timestamp) in cacheTimestamps {
            let age = now.timeIntervalSince(timestamp)
            if age > cacheExpirationTime {
                transactionCache.removeValue(forKey: key)
                cacheTimestamps.removeValue(forKey: key)
                cleanedCount += 1
            }
        }
        
        if cleanedCount > 0 {
            print("🧹 Limpeza: \(cleanedCount) cache(s) expirado(s) removido(s)")
        }
    }
    
    // MARK: - 🗑️ Invalidar Cache
    func invalidateCache(for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache.removeValue(forKey: cacheKey)
        cacheTimestamps.removeValue(forKey: cacheKey)
        print("🗑️ Cache invalidado para user \(userId)")
    }
    
    // MARK: - 📊 Estatísticas
    func printCacheStats() {
        print("\n📊 === ESTATÍSTICAS DO CACHE ===")
        print("📦 Caches ativos: \(transactionCache.count)")
        print("⏰ Timestamps: \(cacheTimestamps.count)")
        
        for (key, timestamp) in cacheTimestamps {
            let age = Date().timeIntervalSince(timestamp)
            let remaining = Int(cacheExpirationTime - age)
            print("  • \(key): \(Int(age))s, expira em \(max(0, remaining))s")
        }
        print("================================\n")
    }
}


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 3: Services/TransactionService.swift (MODIFICAR)
// ═══════════════════════════════════════════════════════════════════
// 
// ⚠️ MODIFICAÇÕES NECESSÁRIAS:
// 1. Corrigir isValidTransaction para aceitar valores negativos
// 2. Alterar função getUserTransactions() para usar cache
// 3. Adicionar invalidateCache() em create, update e delete
// 
// ═══════════════════════════════════════════════════════════════════

import Foundation
import FirebaseFirestore

// MARK: - 💼 Service Especializado de Transações
/*
 📝 SERVICE COM REGRAS DE NEGÓCIO ESPECÍFICAS
 
 🎯 Por que criar service especializado:
 • Encapsula regras de negócio de transações
 • Usa o FirestoreService genérico como base
 • Valida dados antes de salvar
 • Aplica filtros de negócio ao carregar
 • Facilita testes de lógica de negócio
 */
class TransactionService {
    private let firestoreService = FirestoreService()
    
    // Adicionar propriedade de cache na classe - Parte 8:
    private let cacheManager = AdvancedCacheManager.shared // ✅ Usar singleton
    
    // MARK: - ➕ Criar Transação
    /*
     📝 CRIAÇÃO COM VALIDAÇÃO DE NEGÓCIO
     
     🎯 Processo:
     1. Valida dados da transação
     2. Adiciona userId à transação
     3. Salva no path hierárquico correto
     4. Retorna ID do documento criado
     */
    func createTransaction(_ transaction: Transaction, for userId: String) async throws -> String {
        print("🏭 TransactionService: Criando transação para user \(userId)")
        
        // ✅ VALIDAÇÕES DE NEGÓCIO
        guard isValidTransaction(transaction) else {
            print("❌ Transação inválida - não passou nas validações")
            throw FirestoreError.invalidData
        }
        
        // 📝 Adicionar userId à transação
        var transactionWithUser = transaction
        transactionWithUser.userId = userId
        
        // 🗂️ Path hierárquico NoSQL
        let collectionPath = "users/\(userId)/transactions"
        print("   📂 Path: \(collectionPath)")
        
        // 💾 Delegar para service genérico
        let documentId = try await firestoreService.saveDocument(
            transactionWithUser,
            to: collectionPath
        )
        
        print("✅ Transação criada com sucesso: \(documentId)")
        
        // Invalidar cache após CREATE:
        cacheManager.invalidateCache(for: userId)
        
        return documentId
    }
    
    // MARK: - 📋 Buscar Transações do Usuário - (✅ NOVO - PARTE 8)
    func getUserTransactions(userId: String, limit: Int = 50) async throws -> [Transaction] {
        print("📋 TransactionService: Buscando transações do usuário \(userId)")
        
        // 1️⃣ Verificar cache primeiro
        if let cached = cacheManager.getCachedTransactions(for: userId) {
            return cached
        }
        

        // 2️⃣ Se não tem cache, buscar do Firestore
        let collectionPath = "users/\(userId)/transactions"
        let transactions = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            limit: limit,
            orderBy: "date",
            descending: true
        )

        // ✅ Aplicar filtros de negócio
        let validTransactions = transactions
            .filter { isValidTransaction($0) }
            .filter { !$0.isDeleted }

        // 3️⃣ Salvar no cache
        cacheManager.cacheTransactions(validTransactions, for: userId)


        print("✅ Transações carregadas e cacheadas: \(validTransactions.count)")
        
        return validTransactions
    }
    
    
    // MARK: - READ Including Deleted (✅ NOVO - PARTE 5)
        /*
         📖 BUSCAR TODAS AS TRANSAÇÕES (INCLUINDO DELETADAS)
         
         Útil para:
         - Administração e auditoria
         - Relatórios completos
         - Recuperação de dados
         - Análise de histórico completo
         */
        func getAllTransactionsIncludingDeleted(
            userId: String,
            limit: Int = 50
        ) async throws -> [Transaction] {
            print("📖 TransactionService: Buscando TODAS transações (incluindo deletadas)")
            print("  📏 Limite: \(limit)")
            
            let collectionPath = "users/\(userId)/transactions"
            
            let transactions: [Transaction] = try await firestoreService.getDocuments(
                from: collectionPath,
                type: Transaction.self,
                limit: limit,
                orderBy: "date",
                descending: true
            )
            
            // Só valida, mas NÃO filtra deletados
            let validTransactions = transactions.filter { isValidTransaction($0) }
            
            print("✅ \(validTransactions.count) transações totais (incluindo deletadas)")
            return validTransactions
        }
    
    // MARK: - 🎯 Regras de Negócio
    /*
     📝 VALIDAÇÕES ESPECÍFICAS DE TRANSAÇÕES
     
     🎯 Regras aplicadas:
     • Valor deve ser positivo
     • Descrição não pode estar vazia
     • Adicione mais regras conforme necessário
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // ❌ ANTES: guard transaction.amount > 0// ✅ AGORA:
        guard transaction.amount != 0 else {
           print("❌ Valor inválido: \(transaction.amount)")
           return false
        }
            
        // 2. Description não pode estar vazia
        guard !transaction.description.isEmpty else {
            print("❌ Validação falhou: descrição vazia")
            return false
        }
            
        // 3. Data não pode ser futura (nova validação!)
        guard transaction.date <= Date() else {
            print("❌ Data futura: \(transaction.date)")
            return false
        }
            
        return true
    }
    
    // MARK: - 🗑️ Deletar Transação
    func deleteTransaction(
        transactionId: String,
        userId: String,
        soft: Bool = true  // 🏷️ Padrão: soft delete
    ) async throws {
        let collectionPath = "users/\(userId)/transactions"
        
        if soft {
            // 🏷️ SOFT DELETE: marca isDeleted
            print("🏷️ TransactionService: Soft delete de \(transactionId)")
            
            // Buscar documento atual
            var transaction = try await firestoreService.getDocument(
                transactionId,
                from: collectionPath,
                as: Transaction.self
            )
            
            // Marcar como deletado
            transaction.isDeleted = true
            transaction.deletedAt = Date()
            
            // Atualizar com as flags
            try await firestoreService.updateDocument(
                transaction,
                documentId: transactionId,
                in: collectionPath
            )
            
            print("✅ Soft delete concluído")
            print("  📅 deletedAt: \(transaction.deletedAt!)")
            
        } else {
            // 🗑️ HARD DELETE: remove permanentemente
            print("🗑️ TransactionService: Hard delete de \(transactionId)")
            
            try await firestoreService.deleteDocument(
                from: collectionPath,
                documentId: transactionId
            )
            
            print("✅ Hard delete concluído - documento removido permanentemente")
        }
        // Invalidar cache após DELETE:
        cacheManager.invalidateCache(for: userId)
    }
    
    func updateTransaction(_ transaction: Transaction) async throws {
        print("✏️ TransactionService: Atualizando transação")
        
        // 🔒 VALIDAR ID
        guard let id = transaction.id else {
            print("❌ Erro: Transação deve ter ID para atualização")
            throw FirestoreError.invalidData
        }
        
        // 🛡️ VALIDAR DADOS (preventivo!)
        guard isValidTransaction(transaction) else {
            print("❌ Erro: Dados inválidos")
            throw FirestoreError.invalidData
        }
        
        // ⏰ ATUALIZAR TIMESTAMP
        var updatedTransaction = transaction
        updatedTransaction.updatedAt = Date()
        
        let collectionPath = "users/\(transaction.userId)/transactions"
        
        try await firestoreService.updateDocument(
            updatedTransaction,
            documentId: id,
            in: collectionPath,
            merge: true  // ⚡ MERGE INTELIGENTE - preserva campos não enviados
        )
        
        print("✅ Transação atualizada com sucesso")
        print("  📅 updatedAt: \(updatedTransaction.updatedAt)")
        
        // Invalidar cache após UPDATE:
        cacheManager.invalidateCache(for: transaction.userId)
    }
    
    // MARK: - 🔄 Real-time Listeners (✨ PARTE 6 - NOVO!)
    
    /*
     👂 LISTENER PARA TRANSAÇÕES EM TEMPO REAL
     
     Escuta mudanças em tempo real e notifica a UI automaticamente.
     Implementa padrão Observer para sincronização automática.
     
     🎯 Como funciona:
     1. Registra interesse nesta query (addSnapshotListener)
     2. Firebase detecta writes/deletes que afetam query
     3. Servidor envia diff (só o que mudou) via WebSocket
     4. Closure é executada AUTOMATICAMENTE
     5. UI atualiza sem usuário fazer nada!
     
     🎯 Parâmetros:
     - userId: ID do usuário proprietário das transações
     - limit: Limite de documentos (padrão 50 para performance)
     - onUpdate: Closure chamada quando dados mudam (fornece [Transaction])
     - onError: Closure chamada quando ocorre erro
     
     ✅ Retorna: ListenerRegistration para cleanup posterior
     
     ⚠️ CRÍTICO:
     - SEMPRE chamar listener.remove() quando não precisar mais!
     - Usar [weak self] na closure para evitar retain cycle
     - Usar DispatchQueue.main.async para atualizar UI
     */
    func startListeningToUserTransactions(
        userId: String,
        limit: Int = 50,
        onUpdate: @escaping ([Transaction]) -> Void,
        onError: @escaping (Error) -> Void
    ) -> ListenerRegistration {
        
        print("👂 === INICIANDO LISTENER TEMPO REAL ===")
        print("👤 Usuário: \(userId)")
        print("📏 Limite: \(limit) transações")
        print("🎯 Objetivo: Sincronização automática em tempo real")
        
        // 🗄️ CONSTRUIR QUERY OTIMIZADA
        let db = Firestore.firestore()
        let query = db.collection("users")
            .document(userId)
            .collection("transactions")
            .order(by: "date", descending: true)  // Mais recentes primeiro
            .limit(to: limit)                     // Limitar para performance
        
        print("📍 Query construída: users/\(userId)/transactions")
        print("🔄 Listener ativo - aguardando mudanças...")
        
        // 👂 ADICIONAR LISTENER (A MÁGICA ACONTECE AQUI!)
        /*
         📝 addSnapshotListener é o coração do tempo real:
         
         O que acontece:
         1. Firestore "marca" esta query como "interessante"
         2. Toda vez que dados desta query mudam, Firestore avisa
         3. A closure abaixo é executada AUTOMATICAMENTE
         4. Recebemos snapshot com dados atualizados
         
         É como assinar notificações push, mas para dados!
         
         Esta closure executa:
         - IMEDIATAMENTE (dados iniciais)
         - TODA VEZ que algo mudar
         - AUTOMATICAMENTE sem a gente chamar nada!
         */
        let listener = query.addSnapshotListener { [weak self] snapshot, error in
            
            // 🚨 TRATAMENTO DE ERRO
            if let error = error {
                print("❌ Erro no listener: \(error.localizedDescription)")
                
                
                // 🎯 NOTIFICAR ERRO NA THREAD PRINCIPAL
                /*
                 ⚠️ CRÍTICO: onError atualiza @Published properties na UI!
                 Precisa executar na main thread, assim como onUpdate.
                 
                 Sem isso: Crash "UIKit must be accessed from main thread"
                 */
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
                return
            }
            
            // 📄 VERIFICAR SNAPSHOT
            guard let snapshot = snapshot else {
                print("⚠️ Snapshot vazio recebido")
                DispatchQueue.main.async {
                    onUpdate([])
                }
                return
            }
            
            print("📦 Snapshot recebido: \(snapshot.documents.count) documentos")
            
            // 🎯 CONVERTER DOCUMENTOS PARA OBJETOS SWIFT
            do {
                // Codable faz a mágica: Firebase JSON → Swift Object
                let allTransactions = try snapshot.documents.map { document in
                    try document.data(as: Transaction.self)
                }
                
                print("✅ Convertidos: \(allTransactions.count) transações")
                
                // 🏷️ FILTRAR DELETADOS (soft delete - Parte 5!)
                /*
                 Por padrão, não mostramos transações deletadas.
                 isDeleted é do modelo atualizado na Parte 5.
                 */
                let activeTransactions = allTransactions.filter { !$0.isDeleted }
                
                print("🏷️ Filtradas: \(activeTransactions.count) ativas (sem deletadas)")
                
                // 🛡️ VALIDAR DADOS (defesa em profundidade)
                /*
                 Dupla validação:
                 1. Antes de salvar (preventiva)
                 2. Depois de buscar (garantia)
                 
                 Protege contra dados corrompidos ou regras mudadas.
                 */
                let validTransactions = activeTransactions.filter {
                    self?.isValidTransaction($0) ?? true
                }
                
                print("✅ Validadas: \(validTransactions.count) transações válidas")
                
                // 🎯 NOTIFICAR UI NA THREAD PRINCIPAL
                /*
                 ⚠️ CRÍTICO: UI só pode ser atualizada na main thread!
                 
                 Listener executa em background thread (Firebase decide).
                 Temos que voltar pra main thread antes de atualizar UI.
                 
                 Sem isso: CRASH garantido!
                 "UIKit must be accessed from main thread"
                 */
                DispatchQueue.main.async {
                    onUpdate(validTransactions)
                }
                
                print("🎨 UI notificada com \(validTransactions.count) transações")
                
            } catch {
                print("❌ Erro ao converter documentos: \(error)")
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
            }
        }
        
        print("📌 Listener registrado com sucesso")
        print("⚡ Sincronização automática ATIVA!")
        
        // ✅ RETORNAR LISTENER PARA CLEANUP POSTERIOR
        /*
         ⚠️ IMPORTANTE: Este listener precisa ser REMOVIDO quando não for mais necessário!
         
         Sem remoção = MEMORY LEAK:
         - Listener continua rodando
         - Consome recursos
         - App fica lento
         - Pode travar
         
         Sempre guardar este return e chamar .remove() depois!
         
         Pattern recomendado:
         1. Guardar em var listener: ListenerRegistration?
         2. Chamar listener?.remove() em stopListening()
         3. Ter deinit que chama stopListening() (rede de segurança)
         */
        return listener
    }
}


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 4: Views/RealtimeDemoView.swift (MODIFICAR)
// ═══════════════════════════════════════════════════════════════════
// 
// ⚠️ ADICIONAR botão de teste APÓS o .toolbar { } e ANTES do .onAppear
// 
// ═══════════════════════════════════════════════════════════════════

import SwiftUI

struct RealtimeDemoView: View {
    @StateObject private var viewModel = RealtimeDemoViewModel()
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {

                    // 🔌 STATUS DE CONEXÃO
                    HStack {
                        Circle()
                            .fill(viewModel.isListening ? Color.green : Color.gray)
                            .frame(width: 8, height: 8)

                        Text(viewModel.isListening ? "Tempo Real Ativo" : "Offline")
                            .font(.caption)
                            .foregroundColor(.secondary)

                        Spacer()
                    }
                    .padding(.horizontal)

                    // 💰 HEADER COM BALANÇO
                    BalanceHeaderView(
                        totalBalance: viewModel.totalBalance,
                        totalIncome: viewModel.totalIncome,
                        totalExpenses: viewModel.totalExpenses,
                        formatter: viewModel.formatCurrency
                    )

                    // 📊 ESTATÍSTICAS
                    VStack(spacing: 8) {
                        HStack(spacing: 12) {
                            StatisticsCardView(
                                icon: "chart.bar.fill",
                                title: "Transações",
                                value: "\(viewModel.transactionCount)",
                                color: .blue
                            )

                            StatisticsCardView(
                                icon: "chart.line.uptrend.xyaxis",
                                title: "Média de Gastos",
                                value: viewModel.formatCurrency(viewModel.averageExpense),
                                color: .orange
                            )
                        }
                    }
                    .padding(.horizontal)

                    // 📋 LISTA DE TRANSAÇÕES
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Transações Recentes")
                            .font(.headline)
                            .padding(.horizontal)

                        if viewModel.transactions.isEmpty {
                            EmptyStateView()
                                .frame(height: 300)
                        } else {
                            ForEach(viewModel.transactions.prefix(20)) { transaction in
                                TransactionCardView(
                                    transaction: transaction,
                                    formatter: viewModel.formatCurrency,
                                    dateFormatter: viewModel.formatDate
                                )
                                .padding(.horizontal)
                            }
                        }
                    }

                    Spacer(minLength: 20)
                }
                .padding(.vertical)
            }
            .navigationTitle("💫 Dashboard")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        viewModel.isListening ? viewModel.stopListening() : viewModel.startListening()
                    }) {
                        Image(systemName: viewModel.isListening ? "pause.circle.fill" : "play.circle.fill")
                            .foregroundColor(viewModel.isListening ? .orange : .green)
                    }
                }
            }
            
            // MARK: - 🎨 Botão de Teste na UI (✨ NOVO NA PARTE 8)
            // 📝 ADICIONAR ESTE CÓDIGO APÓS O FECHAMENTO DO .toolbar:

            #if DEBUG
            .safeAreaInset(edge: .bottom) {
                Button(action: {
                    Task {
                        let tester = StressTestManager()
                        await tester.performStressTest()
                    }
                }) {
                    Label("🧪 Executar Stress Test", systemImage: "bolt.fill")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.orange)
                        .cornerRadius(12)
                }
                .padding()
                .background(Color(UIColor.systemBackground))
            }
            #endif
            
        }
        .onAppear {
            print("📱 Dashboard apareceu - iniciando listener")
            viewModel.startListening()
        }
        .onDisappear {
            print("📱 Dashboard desapareceu - parando listener")
            viewModel.stopListening()
        }
    }
}


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 5: firestore.rules (CONFIGURAR NO FIREBASE CONSOLE)
// ═══════════════════════════════════════════════════════════════════
// 
// 📍 ONDE: Firebase Console → Firestore Database → Rules
// 📝 AÇÃO: Substituir TODAS as rules por estas:
// 
// ═══════════════════════════════════════════════════════════════════

rules_version = '2';

/*
🛡️ FIRESTORE SECURITY RULES - PRODUÇÃO

Estas rules protegem dados com validações server-side.
NUNCA podem ser burladas pelo cliente.

Princípios:
- Autenticação obrigatória
- Cada usuário acessa apenas SEUS dados
- Validações rigorosas em todas operações
- Negar por padrão
*/

service cloud.firestore {
  match /databases/{database}/documents {
    
    // 🚫 REGRA PADRÃO: NEGAR TUDO
    match /{document=**} {
      allow read, write: if false;
    }
    
    // 👤 USUÁRIOS: Somente próprio usuário
    match /users/{userId} {
      allow read, write: if request.auth != null 
                         && request.auth.uid == userId;
      
      // 💰 TRANSAÇÕES: Subcollection com validações
      match /transactions/{transactionId} {
        
        // 📖 READ: Apenas próprio usuário
        allow read: if request.auth != null 
                    && request.auth.uid == userId;
        
        // ➕ CREATE: Validação completa
        allow create: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId);
        
        // ✏️ UPDATE: Validação + não pode mudar dono
        allow update: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId)
                      && resource.data.userId == request.resource.data.userId;
        
        // 🗑️ DELETE: Apenas próprio usuário
        allow delete: if request.auth != null 
                      && request.auth.uid == userId;
      }
    }
    
    // 🏷️ CATEGORIAS: Apenas leitura
    match /categories/{categoryId} {
      allow read: if request.auth != null;
      allow write: if false;
    }
    
    // 🛡️ FUNÇÃO DE VALIDAÇÃO
    function isValidTransaction(data, expectedUserId) {
      return data.keys().hasAll(['amount', 'description', 'categoryId', 'type', 'userId', 'date'])
             && data.amount is number
             && data.amount != 0
             && data.amount > -1000000
             && data.amount < 1000000
             && data.description is string
             && data.description.size() > 0
             && data.description.size() <= 200
             && data.categoryId is string
             && data.categoryId.size() > 0
             && data.type is string
             && data.type in ['income', 'expense']
             && data.userId is string
             && data.userId == expectedUserId
             && data.date is timestamp;
    }
  }
}


// ═══════════════════════════════════════════════════════════════════
// ✅ CHECKLIST DE IMPLEMENTAÇÃO
// ═══════════════════════════════════════════════════════════════════
// 
// ARQUIVOS CRIADOS:
// [ ] Services/StressTestManager.swift
// [ ] Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// [ ] Services/TransactionService.swift - loadTransactions com cache
// [ ] Services/TransactionService.swift - invalidações em create/update/delete
// [ ] Views/RealtimeDemoView.swift - botão de teste
// 
// CONFIGURAÇÕES:
// [ ] Firebase Console - Security Rules publicadas
// 
// TESTES:
// [ ] Stress test executando (50 transações)
// [ ] Cache funcionando (hit/miss nos logs)
// [ ] Security rules bloqueando dados inválidos
// 
// ═══════════════════════════════════════════════════════════════════
