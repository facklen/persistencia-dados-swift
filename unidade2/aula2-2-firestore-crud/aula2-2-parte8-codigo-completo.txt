// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ AULA 2.2 - PARTE 8: TESTES E OTIMIZAÃ‡Ã•ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// Este arquivo contÃ©m TODOS os cÃ³digos criados/modificados na Parte 8
// 
// ARQUIVOS CRIADOS:
// 1. Services/StressTestManager.swift
// 2. Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// 3. Services/TransactionService.swift (cache + invalidaÃ§Ãµes)
// 4. Views/RealtimeDemoView.swift (botÃ£o de teste)
// 
// CONFIGURAÃ‡Ã•ES:
// 5. Firebase Security Rules (firestore.rules)
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 1: Services/StressTestManager.swift (CRIAR NOVO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation

// MARK: - ğŸ§ª Stress Test Manager
/*
 âš¡ SIMULADOR DE STRESS TEST PROFISSIONAL
 
 Este gerenciador testa o app sob condiÃ§Ãµes extremas:
 - MÃºltiplas transaÃ§Ãµes simultÃ¢neas (concorrÃªncia)
 - Performance sob carga
 - ValidaÃ§Ã£o de estabilidade
 
 âš ï¸ IMPORTANTE: Use APENAS em ambiente de desenvolvimento!
 Nunca execute em produÃ§Ã£o pois cria dados de teste.
 */
class StressTestManager {
    // ğŸ“¦ DEPENDÃŠNCIAS
    private let transactionService = TransactionService()
    private let testUserId = "stress_test_user_\(UUID().uuidString)"
    
    // MARK: - ğŸ¯ Teste Principal
    /*
     Executa teste de stress com mÃºltiplas transaÃ§Ãµes paralelas.
     
     Como funciona:
     1. Cria 50 tasks simultÃ¢neas
     2. Cada task adiciona uma transaÃ§Ã£o
     3. TaskGroup aguarda todas completarem
     4. Calcula tempo total e sucesso/erro
     */
    func performStressTest() async {
        print("\nğŸ§ª === INICIANDO STRESS TEST ===")
        print("â±ï¸  Timestamp: \(Date())")
        print("ğŸ‘¤ User ID: \(testUserId)")
        print("ğŸ“Š TransaÃ§Ãµes a criar: 50")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
        
        let startTime = Date()
        var successCount = 0
        var errorCount = 0
        
        // ğŸ¯ CRIAR 50 TRANSAÃ‡Ã•ES EM PARALELO
        await withTaskGroup(of: Result<Void, Error>.self) { group in
            for index in 1...50 {
                group.addTask {
                    do {
                        let transaction = Transaction(
                            userId: self.testUserId,
                            amount: self.randomAmount(index: index),
                            description: "Teste Stress #\(index)",
                            categoryId: "test_category",
                            type: index % 2 == 0 ? .income : .expense,
                            date: Date()
                        )
                        
                        try await self.transactionService.createTransaction(transaction)
                        print("âœ… [\(index)/50] TransaÃ§Ã£o criada com sucesso")
                        return .success(())
                    } catch {
                        print("âŒ [\(index)/50] ERRO: \(error.localizedDescription)")
                        return .failure(error)
                    }
                }
            }
            
            // â³ AGUARDAR TODAS AS TASKS COMPLETAREM
            for await result in group {
                switch result {
                case .success:
                    successCount += 1
                case .failure:
                    errorCount += 1
                }
            }
        }
        
        // â±ï¸ CALCULAR TEMPO TOTAL
        let endTime = Date()
        let duration = endTime.timeIntervalSince(startTime)
        
        // ğŸ“Š RELATÃ“RIO FINAL
        print("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        print("ğŸ¯ === STRESS TEST CONCLUÃDO ===")
        print("â±ï¸  Tempo total: \(String(format: "%.2f", duration)) segundos")
        print("âœ… Sucessos: \(successCount)")
        print("âŒ Erros: \(errorCount)")
        print("ğŸ“ˆ Taxa de sucesso: \(String(format: "%.1f", Double(successCount) / 50.0 * 100))%")
        print("âš¡ TransaÃ§Ãµes/segundo: \(String(format: "%.2f", 50.0 / duration))")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
        
        // âœ… AVALIAÃ‡ÃƒO DE QUALIDADE
        if successCount == 50 {
            print("ğŸ† EXCELENTE! Sistema aguenta carga pesada!")
        } else if successCount >= 45 {
            print("âœ… BOM! Algumas falhas mas estÃ¡vel")
        } else {
            print("âš ï¸ ATENÃ‡ÃƒO! Taxa de erro elevada - revisar implementaÃ§Ã£o")
        }
    }
    
    // MARK: - ğŸ² Helpers
    private func randomAmount(index: Int) -> Double {
        let base = Double.random(in: 10...1000)
        return index % 2 == 0 ? base : -base
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 2: Services/AdvancedCacheManager.swift (CRIAR NOVO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation

// MARK: - ğŸ’¾ Advanced Cache Manager
/*
 ğŸ¯ SISTEMA DE CACHE INTELIGENTE
 
 Reduz reads do Firestore em atÃ© 95%, economizando custos e melhorando performance.
 
 Funcionalidades:
 - Cache com expiraÃ§Ã£o automÃ¡tica (5 minutos)
 - Limpeza automÃ¡tica de cache antigo
 - Thread-safe (pode ser usado de qualquer lugar)
 - Singleton para acesso global
 */
class AdvancedCacheManager {
    // ğŸŒŸ SINGLETON
    static let shared = AdvancedCacheManager()
    
    // ğŸ“¦ ARMAZENAMENTO
    private var transactionCache: [String: [Transaction]] = [:]
    private var cacheTimestamps: [String: Date] = [:]
    
    // âš™ï¸ CONFIGURAÃ‡ÃƒO
    private let cacheExpirationTime: TimeInterval = 300 // 5 minutos
    
    private init() {
        print("ğŸ’¾ AdvancedCacheManager inicializado")
    }
    
    // MARK: - ğŸ“¥ Salvar no Cache
    func cacheTransactions(_ transactions: [Transaction], for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache[cacheKey] = transactions
        cacheTimestamps[cacheKey] = Date()
        
        print("ğŸ’¾ Cache salvo: \(transactions.count) transaÃ§Ãµes para user \(userId)")
        cleanupExpiredCache()
    }
    
    // MARK: - ğŸ“¤ Recuperar do Cache
    func getCachedTransactions(for userId: String) -> [Transaction]? {
        let cacheKey = "transactions_\(userId)"
        
        guard let timestamp = cacheTimestamps[cacheKey],
              let transactions = transactionCache[cacheKey] else {
            print("ğŸ’¾ Cache MISS - nÃ£o existe para user \(userId)")
            return nil
        }
        
        let age = Date().timeIntervalSince(timestamp)
        
        if age < cacheExpirationTime {
            print("ğŸ’¾ Cache HIT - \(transactions.count) transaÃ§Ãµes (\(Int(age))s de idade)")
            return transactions
        } else {
            print("ğŸ’¾ Cache EXPIRADO - idade: \(Int(age))s")
            transactionCache.removeValue(forKey: cacheKey)
            cacheTimestamps.removeValue(forKey: cacheKey)
            return nil
        }
    }
    
    // MARK: - ğŸ§¹ Limpeza AutomÃ¡tica
    private func cleanupExpiredCache() {
        let now = Date()
        var cleanedCount = 0
        
        for (key, timestamp) in cacheTimestamps {
            let age = now.timeIntervalSince(timestamp)
            if age > cacheExpirationTime {
                transactionCache.removeValue(forKey: key)
                cacheTimestamps.removeValue(forKey: key)
                cleanedCount += 1
            }
        }
        
        if cleanedCount > 0 {
            print("ğŸ§¹ Limpeza: \(cleanedCount) cache(s) expirado(s) removido(s)")
        }
    }
    
    // MARK: - ğŸ—‘ï¸ Invalidar Cache
    func invalidateCache(for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache.removeValue(forKey: cacheKey)
        cacheTimestamps.removeValue(forKey: cacheKey)
        print("ğŸ—‘ï¸ Cache invalidado para user \(userId)")
    }
    
    // MARK: - ğŸ“Š EstatÃ­sticas
    func printCacheStats() {
        print("\nğŸ“Š === ESTATÃSTICAS DO CACHE ===")
        print("ğŸ“¦ Caches ativos: \(transactionCache.count)")
        print("â° Timestamps: \(cacheTimestamps.count)")
        
        for (key, timestamp) in cacheTimestamps {
            let age = Date().timeIntervalSince(timestamp)
            let remaining = Int(cacheExpirationTime - age)
            print("  â€¢ \(key): \(Int(age))s, expira em \(max(0, remaining))s")
        }
        print("================================\n")
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 3: Services/TransactionService.swift (MODIFICAR)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// âš ï¸ MODIFICAÃ‡Ã•ES NECESSÃRIAS:
// 1. Alterar funÃ§Ã£o loadTransactions() para usar cache
// 2. Adicionar invalidateCache() em create, update e delete
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸ“ SUBSTITUIR A FUNÃ‡ÃƒO loadTransactions POR ESTA:

func loadTransactions() async throws -> [Transaction] {
    print("\nğŸ“– === LOAD TRANSACTIONS (COM CACHE) ===")
    
    // 1ï¸âƒ£ TENTAR CACHE PRIMEIRO
    if let cachedTransactions = AdvancedCacheManager.shared.getCachedTransactions(for: userId) {
        print("âš¡ Retornando do CACHE - economia de 1 read!")
        return cachedTransactions
    }
    
    // 2ï¸âƒ£ CACHE MISS - BUSCAR DO FIRESTORE
    print("ğŸ”¥ Cache miss - buscando do Firestore...")
    
    let snapshot = try await db.collection("users")
        .document(userId)
        .collection("transactions")
        .order(by: "date", descending: true)
        .limit(to: 50)
        .getDocuments()
    
    let transactions = snapshot.documents.compactMap { doc in
        try? doc.data(as: Transaction.self)
    }
    
    print("ğŸ”¥ Firestore retornou \(transactions.count) transaÃ§Ãµes")
    
    // 3ï¸âƒ£ SALVAR NO CACHE
    AdvancedCacheManager.shared.cacheTransactions(transactions, for: userId)
    print("ğŸ’¾ Cache atualizado!")
    print("================================\n")
    
    return transactions
}

// ğŸ“ ADICIONAR NO FINAL DA FUNÃ‡ÃƒO createTransaction:

// Invalidar cache apÃ³s criar
AdvancedCacheManager.shared.invalidateCache(for: transaction.userId)

// ğŸ“ ADICIONAR NO FINAL DA FUNÃ‡ÃƒO updateTransaction:

// Invalidar cache apÃ³s atualizar
AdvancedCacheManager.shared.invalidateCache(for: userId)

// ğŸ“ ADICIONAR NO FINAL DA FUNÃ‡ÃƒO deleteTransaction:

// Invalidar cache apÃ³s deletar
AdvancedCacheManager.shared.invalidateCache(for: userId)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 4: Views/RealtimeDemoView.swift (MODIFICAR)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// âš ï¸ ADICIONAR botÃ£o de teste APÃ“S o .toolbar { } e ANTES do .onAppear
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸ“ ADICIONAR ESTE CÃ“DIGO APÃ“S O FECHAMENTO DO .toolbar:

#if DEBUG
.safeAreaInset(edge: .bottom) {
    Button(action: {
        Task {
            let tester = StressTestManager()
            await tester.performStressTest()
        }
    }) {
        Label("ğŸ§ª Executar Stress Test", systemImage: "bolt.fill")
            .font(.headline)
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .padding()
            .background(Color.orange)
            .cornerRadius(12)
    }
    .padding()
    .background(Color(UIColor.systemBackground))
}
#endif


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 5: firestore.rules (CONFIGURAR NO FIREBASE CONSOLE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// ğŸ“ ONDE: Firebase Console â†’ Firestore Database â†’ Rules
// ğŸ“ AÃ‡ÃƒO: Substituir TODAS as rules por estas:
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rules_version = '2';

/*
ğŸ›¡ï¸ FIRESTORE SECURITY RULES - PRODUÃ‡ÃƒO

Estas rules protegem dados com validaÃ§Ãµes server-side.
NUNCA podem ser burladas pelo cliente.

PrincÃ­pios:
- AutenticaÃ§Ã£o obrigatÃ³ria
- Cada usuÃ¡rio acessa apenas SEUS dados
- ValidaÃ§Ãµes rigorosas em todas operaÃ§Ãµes
- Negar por padrÃ£o
*/

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ğŸš« REGRA PADRÃƒO: NEGAR TUDO
    match /{document=**} {
      allow read, write: if false;
    }
    
    // ğŸ‘¤ USUÃRIOS: Somente prÃ³prio usuÃ¡rio
    match /users/{userId} {
      allow read, write: if request.auth != null 
                         && request.auth.uid == userId;
      
      // ğŸ’° TRANSAÃ‡Ã•ES: Subcollection com validaÃ§Ãµes
      match /transactions/{transactionId} {
        
        // ğŸ“– READ: Apenas prÃ³prio usuÃ¡rio
        allow read: if request.auth != null 
                    && request.auth.uid == userId;
        
        // â• CREATE: ValidaÃ§Ã£o completa
        allow create: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId);
        
        // âœï¸ UPDATE: ValidaÃ§Ã£o + nÃ£o pode mudar dono
        allow update: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId)
                      && resource.data.userId == request.resource.data.userId;
        
        // ğŸ—‘ï¸ DELETE: Apenas prÃ³prio usuÃ¡rio
        allow delete: if request.auth != null 
                      && request.auth.uid == userId;
      }
    }
    
    // ğŸ·ï¸ CATEGORIAS: Apenas leitura
    match /categories/{categoryId} {
      allow read: if request.auth != null;
      allow write: if false;
    }
    
    // ğŸ›¡ï¸ FUNÃ‡ÃƒO DE VALIDAÃ‡ÃƒO
    function isValidTransaction(data, expectedUserId) {
      return data.keys().hasAll(['amount', 'description', 'categoryId', 'type', 'userId', 'date'])
             && data.amount is number
             && data.amount != 0
             && data.amount > -1000000
             && data.amount < 1000000
             && data.description is string
             && data.description.size() > 0
             && data.description.size() <= 200
             && data.categoryId is string
             && data.categoryId.size() > 0
             && data.type is string
             && data.type in ['income', 'expense']
             && data.userId is string
             && data.userId == expectedUserId
             && data.date is timestamp;
    }
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… CHECKLIST DE IMPLEMENTAÃ‡ÃƒO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// ARQUIVOS CRIADOS:
// [ ] Services/StressTestManager.swift
// [ ] Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// [ ] Services/TransactionService.swift - loadTransactions com cache
// [ ] Services/TransactionService.swift - invalidaÃ§Ãµes em create/update/delete
// [ ] Views/RealtimeDemoView.swift - botÃ£o de teste
// 
// CONFIGURAÃ‡Ã•ES:
// [ ] Firebase Console - Security Rules publicadas
// 
// TESTES:
// [ ] Stress test executando (50 transaÃ§Ãµes)
// [ ] Cache funcionando (hit/miss nos logs)
// [ ] Security rules bloqueando dados invÃ¡lidos
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•