// ═══════════════════════════════════════════════════════════════════
// 📦 AULA 2.2 - PARTE 8: TESTES E OTIMIZAÇÕES
// ═══════════════════════════════════════════════════════════════════
// 
// Este arquivo contém TODOS os códigos criados/modificados na Parte 8
// 
// ARQUIVOS CRIADOS:
// 1. Services/StressTestManager.swift
// 2. Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// 3. Services/TransactionService.swift (cache + invalidações)
// 4. Views/RealtimeDemoView.swift (botão de teste)
// 
// CONFIGURAÇÕES:
// 5. Firebase Security Rules (firestore.rules)
// 
// ═══════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 1: Services/StressTestManager.swift (CRIAR NOVO)
// ═══════════════════════════════════════════════════════════════════

import Foundation

// MARK: - 🧪 Stress Test Manager
/*
 ⚡ SIMULADOR DE STRESS TEST PROFISSIONAL
 
 Este gerenciador testa o app sob condições extremas:
 - Múltiplas transações simultâneas (concorrência)
 - Performance sob carga
 - Validação de estabilidade
 
 ⚠️ IMPORTANTE: Use APENAS em ambiente de desenvolvimento!
 Nunca execute em produção pois cria dados de teste.
 */
class StressTestManager {
    // 📦 DEPENDÊNCIAS
    private let transactionService = TransactionService()
    private let testUserId = "stress_test_user_\(UUID().uuidString)"
    
    // MARK: - 🎯 Teste Principal
    /*
     Executa teste de stress com múltiplas transações paralelas.
     
     Como funciona:
     1. Cria 50 tasks simultâneas
     2. Cada task adiciona uma transação
     3. TaskGroup aguarda todas completarem
     4. Calcula tempo total e sucesso/erro
     */
    func performStressTest() async {
        print("\n🧪 === INICIANDO STRESS TEST ===")
        print("⏱️  Timestamp: \(Date())")
        print("👤 User ID: \(testUserId)")
        print("📊 Transações a criar: 50")
        print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
        
        let startTime = Date()
        var successCount = 0
        var errorCount = 0
        
        // 🎯 CRIAR 50 TRANSAÇÕES EM PARALELO
        await withTaskGroup(of: Result<Void, Error>.self) { group in
            for index in 1...50 {
                group.addTask {
                    do {
                        let transaction = Transaction(
                            userId: self.testUserId,
                            amount: self.randomAmount(index: index),
                            description: "Teste Stress #\(index)",
                            categoryId: "test_category",
                            type: index % 2 == 0 ? .income : .expense,
                            date: Date()
                        )
                        
                        try await self.transactionService.createTransaction(transaction)
                        print("✅ [\(index)/50] Transação criada com sucesso")
                        return .success(())
                    } catch {
                        print("❌ [\(index)/50] ERRO: \(error.localizedDescription)")
                        return .failure(error)
                    }
                }
            }
            
            // ⏳ AGUARDAR TODAS AS TASKS COMPLETAREM
            for await result in group {
                switch result {
                case .success:
                    successCount += 1
                case .failure:
                    errorCount += 1
                }
            }
        }
        
        // ⏱️ CALCULAR TEMPO TOTAL
        let endTime = Date()
        let duration = endTime.timeIntervalSince(startTime)
        
        // 📊 RELATÓRIO FINAL
        print("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
        print("🎯 === STRESS TEST CONCLUÍDO ===")
        print("⏱️  Tempo total: \(String(format: "%.2f", duration)) segundos")
        print("✅ Sucessos: \(successCount)")
        print("❌ Erros: \(errorCount)")
        print("📈 Taxa de sucesso: \(String(format: "%.1f", Double(successCount) / 50.0 * 100))%")
        print("⚡ Transações/segundo: \(String(format: "%.2f", 50.0 / duration))")
        print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
        
        // ✅ AVALIAÇÃO DE QUALIDADE
        if successCount == 50 {
            print("🏆 EXCELENTE! Sistema aguenta carga pesada!")
        } else if successCount >= 45 {
            print("✅ BOM! Algumas falhas mas estável")
        } else {
            print("⚠️ ATENÇÃO! Taxa de erro elevada - revisar implementação")
        }
    }
    
    // MARK: - 🎲 Helpers
    private func randomAmount(index: Int) -> Double {
        let base = Double.random(in: 10...1000)
        return index % 2 == 0 ? base : -base
    }
}


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 2: Services/AdvancedCacheManager.swift (CRIAR NOVO)
// ═══════════════════════════════════════════════════════════════════

import Foundation

// MARK: - 💾 Advanced Cache Manager
/*
 🎯 SISTEMA DE CACHE INTELIGENTE
 
 Reduz reads do Firestore em até 95%, economizando custos e melhorando performance.
 
 Funcionalidades:
 - Cache com expiração automática (5 minutos)
 - Limpeza automática de cache antigo
 - Thread-safe (pode ser usado de qualquer lugar)
 - Singleton para acesso global
 */
class AdvancedCacheManager {
    // 🌟 SINGLETON
    static let shared = AdvancedCacheManager()
    
    // 📦 ARMAZENAMENTO
    private var transactionCache: [String: [Transaction]] = [:]
    private var cacheTimestamps: [String: Date] = [:]
    
    // ⚙️ CONFIGURAÇÃO
    private let cacheExpirationTime: TimeInterval = 300 // 5 minutos
    
    private init() {
        print("💾 AdvancedCacheManager inicializado")
    }
    
    // MARK: - 📥 Salvar no Cache
    func cacheTransactions(_ transactions: [Transaction], for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache[cacheKey] = transactions
        cacheTimestamps[cacheKey] = Date()
        
        print("💾 Cache salvo: \(transactions.count) transações para user \(userId)")
        cleanupExpiredCache()
    }
    
    // MARK: - 📤 Recuperar do Cache
    func getCachedTransactions(for userId: String) -> [Transaction]? {
        let cacheKey = "transactions_\(userId)"
        
        guard let timestamp = cacheTimestamps[cacheKey],
              let transactions = transactionCache[cacheKey] else {
            print("💾 Cache MISS - não existe para user \(userId)")
            return nil
        }
        
        let age = Date().timeIntervalSince(timestamp)
        
        if age < cacheExpirationTime {
            print("💾 Cache HIT - \(transactions.count) transações (\(Int(age))s de idade)")
            return transactions
        } else {
            print("💾 Cache EXPIRADO - idade: \(Int(age))s")
            transactionCache.removeValue(forKey: cacheKey)
            cacheTimestamps.removeValue(forKey: cacheKey)
            return nil
        }
    }
    
    // MARK: - 🧹 Limpeza Automática
    private func cleanupExpiredCache() {
        let now = Date()
        var cleanedCount = 0
        
        for (key, timestamp) in cacheTimestamps {
            let age = now.timeIntervalSince(timestamp)
            if age > cacheExpirationTime {
                transactionCache.removeValue(forKey: key)
                cacheTimestamps.removeValue(forKey: key)
                cleanedCount += 1
            }
        }
        
        if cleanedCount > 0 {
            print("🧹 Limpeza: \(cleanedCount) cache(s) expirado(s) removido(s)")
        }
    }
    
    // MARK: - 🗑️ Invalidar Cache
    func invalidateCache(for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache.removeValue(forKey: cacheKey)
        cacheTimestamps.removeValue(forKey: cacheKey)
        print("🗑️ Cache invalidado para user \(userId)")
    }
    
    // MARK: - 📊 Estatísticas
    func printCacheStats() {
        print("\n📊 === ESTATÍSTICAS DO CACHE ===")
        print("📦 Caches ativos: \(transactionCache.count)")
        print("⏰ Timestamps: \(cacheTimestamps.count)")
        
        for (key, timestamp) in cacheTimestamps {
            let age = Date().timeIntervalSince(timestamp)
            let remaining = Int(cacheExpirationTime - age)
            print("  • \(key): \(Int(age))s, expira em \(max(0, remaining))s")
        }
        print("================================\n")
    }
}


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 3: Services/TransactionService.swift (MODIFICAR)
// ═══════════════════════════════════════════════════════════════════
// 
// ⚠️ MODIFICAÇÕES NECESSÁRIAS:
// 1. Alterar função loadTransactions() para usar cache
// 2. Adicionar invalidateCache() em create, update e delete
// 
// ═══════════════════════════════════════════════════════════════════

// 📝 SUBSTITUIR A FUNÇÃO loadTransactions POR ESTA:

func loadTransactions() async throws -> [Transaction] {
    print("\n📖 === LOAD TRANSACTIONS (COM CACHE) ===")
    
    // 1️⃣ TENTAR CACHE PRIMEIRO
    if let cachedTransactions = AdvancedCacheManager.shared.getCachedTransactions(for: userId) {
        print("⚡ Retornando do CACHE - economia de 1 read!")
        return cachedTransactions
    }
    
    // 2️⃣ CACHE MISS - BUSCAR DO FIRESTORE
    print("🔥 Cache miss - buscando do Firestore...")
    
    let snapshot = try await db.collection("users")
        .document(userId)
        .collection("transactions")
        .order(by: "date", descending: true)
        .limit(to: 50)
        .getDocuments()
    
    let transactions = snapshot.documents.compactMap { doc in
        try? doc.data(as: Transaction.self)
    }
    
    print("🔥 Firestore retornou \(transactions.count) transações")
    
    // 3️⃣ SALVAR NO CACHE
    AdvancedCacheManager.shared.cacheTransactions(transactions, for: userId)
    print("💾 Cache atualizado!")
    print("================================\n")
    
    return transactions
}

// 📝 ADICIONAR NO FINAL DA FUNÇÃO createTransaction:

// Invalidar cache após criar
AdvancedCacheManager.shared.invalidateCache(for: transaction.userId)

// 📝 ADICIONAR NO FINAL DA FUNÇÃO updateTransaction:

// Invalidar cache após atualizar
AdvancedCacheManager.shared.invalidateCache(for: userId)

// 📝 ADICIONAR NO FINAL DA FUNÇÃO deleteTransaction:

// Invalidar cache após deletar
AdvancedCacheManager.shared.invalidateCache(for: userId)


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 4: Views/RealtimeDemoView.swift (MODIFICAR)
// ═══════════════════════════════════════════════════════════════════
// 
// ⚠️ ADICIONAR botão de teste APÓS o .toolbar { } e ANTES do .onAppear
// 
// ═══════════════════════════════════════════════════════════════════

// 📝 ADICIONAR ESTE CÓDIGO APÓS O FECHAMENTO DO .toolbar:

#if DEBUG
.safeAreaInset(edge: .bottom) {
    Button(action: {
        Task {
            let tester = StressTestManager()
            await tester.performStressTest()
        }
    }) {
        Label("🧪 Executar Stress Test", systemImage: "bolt.fill")
            .font(.headline)
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .padding()
            .background(Color.orange)
            .cornerRadius(12)
    }
    .padding()
    .background(Color(UIColor.systemBackground))
}
#endif


// ═══════════════════════════════════════════════════════════════════
// 📄 ARQUIVO 5: firestore.rules (CONFIGURAR NO FIREBASE CONSOLE)
// ═══════════════════════════════════════════════════════════════════
// 
// 📍 ONDE: Firebase Console → Firestore Database → Rules
// 📝 AÇÃO: Substituir TODAS as rules por estas:
// 
// ═══════════════════════════════════════════════════════════════════

rules_version = '2';

/*
🛡️ FIRESTORE SECURITY RULES - PRODUÇÃO

Estas rules protegem dados com validações server-side.
NUNCA podem ser burladas pelo cliente.

Princípios:
- Autenticação obrigatória
- Cada usuário acessa apenas SEUS dados
- Validações rigorosas em todas operações
- Negar por padrão
*/

service cloud.firestore {
  match /databases/{database}/documents {
    
    // 🚫 REGRA PADRÃO: NEGAR TUDO
    match /{document=**} {
      allow read, write: if false;
    }
    
    // 👤 USUÁRIOS: Somente próprio usuário
    match /users/{userId} {
      allow read, write: if request.auth != null 
                         && request.auth.uid == userId;
      
      // 💰 TRANSAÇÕES: Subcollection com validações
      match /transactions/{transactionId} {
        
        // 📖 READ: Apenas próprio usuário
        allow read: if request.auth != null 
                    && request.auth.uid == userId;
        
        // ➕ CREATE: Validação completa
        allow create: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId);
        
        // ✏️ UPDATE: Validação + não pode mudar dono
        allow update: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId)
                      && resource.data.userId == request.resource.data.userId;
        
        // 🗑️ DELETE: Apenas próprio usuário
        allow delete: if request.auth != null 
                      && request.auth.uid == userId;
      }
    }
    
    // 🏷️ CATEGORIAS: Apenas leitura
    match /categories/{categoryId} {
      allow read: if request.auth != null;
      allow write: if false;
    }
    
    // 🛡️ FUNÇÃO DE VALIDAÇÃO
    function isValidTransaction(data, expectedUserId) {
      return data.keys().hasAll(['amount', 'description', 'categoryId', 'type', 'userId', 'date'])
             && data.amount is number
             && data.amount != 0
             && data.amount > -1000000
             && data.amount < 1000000
             && data.description is string
             && data.description.size() > 0
             && data.description.size() <= 200
             && data.categoryId is string
             && data.categoryId.size() > 0
             && data.type is string
             && data.type in ['income', 'expense']
             && data.userId is string
             && data.userId == expectedUserId
             && data.date is timestamp;
    }
  }
}


// ═══════════════════════════════════════════════════════════════════
// ✅ CHECKLIST DE IMPLEMENTAÇÃO
// ═══════════════════════════════════════════════════════════════════
// 
// ARQUIVOS CRIADOS:
// [ ] Services/StressTestManager.swift
// [ ] Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// [ ] Services/TransactionService.swift - loadTransactions com cache
// [ ] Services/TransactionService.swift - invalidações em create/update/delete
// [ ] Views/RealtimeDemoView.swift - botão de teste
// 
// CONFIGURAÇÕES:
// [ ] Firebase Console - Security Rules publicadas
// 
// TESTES:
// [ ] Stress test executando (50 transações)
// [ ] Cache funcionando (hit/miss nos logs)
// [ ] Security rules bloqueando dados inválidos
// 
// ═══════════════════════════════════════════════════════════════════