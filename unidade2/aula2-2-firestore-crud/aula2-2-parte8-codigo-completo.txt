// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ AULA 2.2 - PARTE 8: TESTES E OTIMIZAÃ‡Ã•ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// Este arquivo contÃ©m TODOS os cÃ³digos criados/modificados na Parte 8
// 
// ARQUIVOS CRIADOS:
// 1. Services/StressTestManager.swift
// 2. Services/AdvancedCacheManager.swift
// 
// ARQUIVOS MODIFICADOS:
// 3. Services/TransactionService.swift (cache + invalidaÃ§Ãµes + autenticaÃ§Ã£o)
// 4. Views/RealtimeDemoView.swift (botÃ£o de teste + autenticaÃ§Ã£o)
// 16. Views/CRUDDemoView.swift (autenticaÃ§Ã£o)
// 17. Views/RealtimeDemoViewModel.swift (autenticaÃ§Ã£o)
// 
// CONFIGURAÃ‡Ã•ES:
// 5. Firebase Security Rules (firestore.rules)
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 1: Services/StressTestManager.swift (CRIAR NOVO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation

// MARK: - ğŸ§ª Stress Test Manager
/*
 âš¡ SIMULADOR DE STRESS TEST PROFISSIONAL
 
 Este gerenciador testa o app sob condiÃ§Ãµes extremas:
 - MÃºltiplas transaÃ§Ãµes simultÃ¢neas (concorrÃªncia)
 - Performance sob carga
 - ValidaÃ§Ã£o de estabilidade
 
 âš ï¸ IMPORTANTE: Use APENAS em ambiente de desenvolvimento!
 Nunca execute em produÃ§Ã£o pois cria dados de teste.
 */
class StressTestManager {
    // ğŸ“¦ DEPENDÃŠNCIAS
    private let transactionService = TransactionService()
    private let testUserId = "stress_test_user_\(UUID().uuidString)"
    
    /*private var testUserId: String {
        transactionService.getCurrentUserId()
    }*/
    
    
    // MARK: - ğŸ¯ Teste Principal
    /*
     Executa teste de stress com mÃºltiplas transaÃ§Ãµes paralelas.
     
     Como funciona:
     1. Cria 50 tasks simultÃ¢neas
     2. Cada task adiciona uma transaÃ§Ã£o
     3. TaskGroup aguarda todas completarem
     4. Calcula tempo total e sucesso/erro
     */
    func performStressTest() async {
        print("\nğŸ§ª === INICIANDO STRESS TEST ===")
        print("â±ï¸  Timestamp: \(Date())")
        print("ğŸ‘¤ User ID: \(testUserId)")
        print("ğŸ“Š TransaÃ§Ãµes a criar: 50")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
        
        let startTime = Date()
        var successCount = 0
        var errorCount = 0
        
        // ğŸ¯ CRIAR 50 TRANSAÃ‡Ã•ES EM PARALELO
        await withTaskGroup(of: Result<Void, Error>.self) { group in
            for index in 1...50 {
                group.addTask {
                    do {
                        let transaction = Transaction(
                            amount: self.randomAmount(index: index),
                            description: "Teste Stress #\(index)",
                            type: index % 2 == 0 ? .income : .expense,
                            userId: self.testUserId
                        )
                      
                        // Tentar criar no Firestore
                        _ = try await self.transactionService.createTransaction(transaction)
                        print("âœ… [\(index)/50] TransaÃ§Ã£o criada com sucesso")
                        return .success(())
                    } catch {
                        print("âŒ [\(index)/50] ERRO: \(error.localizedDescription)")
                        return .failure(error)
                    }
                }
            }
            
            // â³ AGUARDAR TODAS AS TASKS COMPLETAREM
            for await result in group {
                switch result {
                case .success:
                    successCount += 1
                case .failure:
                    errorCount += 1
                }
            }
        }
        
        // â±ï¸ CALCULAR TEMPO TOTAL
        let endTime = Date()
        let duration = endTime.timeIntervalSince(startTime)
        
        // ğŸ“Š RELATÃ“RIO FINAL
        print("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        print("ğŸ¯ === STRESS TEST CONCLUÃDO ===")
        print("â±ï¸  Tempo total: \(String(format: "%.2f", duration)) segundos")
        print("âœ… Sucessos: \(successCount)")
        print("âŒ Erros: \(errorCount)")
        print("ğŸ“ˆ Taxa de sucesso: \(String(format: "%.1f", Double(successCount) / 50.0 * 100))%")
        print("âš¡ TransaÃ§Ãµes/segundo: \(String(format: "%.2f", 50.0 / duration))")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
        
        // âœ… AVALIAÃ‡ÃƒO DE QUALIDADE
        if successCount == 50 {
            print("ğŸ† EXCELENTE! Sistema aguenta carga pesada!")
        } else if successCount >= 45 {
            print("âœ… BOM! Algumas falhas mas estÃ¡vel")
        } else {
            print("âš ï¸ ATENÃ‡ÃƒO! Taxa de erro elevada - revisar implementaÃ§Ã£o")
        }
    }
    
    // MARK: - ğŸ² Helpers
    private func randomAmount(index: Int) -> Double {
        let base = Double.random(in: 10...1000)
        return index % 2 == 0 ? base : -base
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 2: Services/AdvancedCacheManager.swift (CRIAR NOVO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation

// MARK: - ğŸ’¾ Advanced Cache Manager
/*
 ğŸ¯ SISTEMA DE CACHE INTELIGENTE
 
 Reduz reads do Firestore em atÃ© 95%, economizando custos e melhorando performance.
 
 Funcionalidades:
 - Cache com expiraÃ§Ã£o automÃ¡tica (5 minutos)
 - Limpeza automÃ¡tica de cache antigo
 - Thread-safe (pode ser usado de qualquer lugar)
 - Singleton para acesso global
 */
class AdvancedCacheManager {
    // ğŸŒŸ SINGLETON
    static let shared = AdvancedCacheManager()
    
    // ğŸ“¦ ARMAZENAMENTO
    private var transactionCache: [String: [Transaction]] = [:]
    private var cacheTimestamps: [String: Date] = [:]
    
    // âš™ï¸ CONFIGURAÃ‡ÃƒO
    private let cacheExpirationTime: TimeInterval = 300 // 5 minutos
    
    private init() {
        print("ğŸ’¾ AdvancedCacheManager inicializado")
    }
    
    // MARK: - ğŸ“¥ Salvar no Cache
    func cacheTransactions(_ transactions: [Transaction], for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache[cacheKey] = transactions
        cacheTimestamps[cacheKey] = Date()
        
        print("ğŸ’¾ Cache salvo: \(transactions.count) transaÃ§Ãµes para user \(userId)")
        cleanupExpiredCache()
    }
    
    // MARK: - ğŸ“¤ Recuperar do Cache
    func getCachedTransactions(for userId: String) -> [Transaction]? {
        let cacheKey = "transactions_\(userId)"
        
        guard let timestamp = cacheTimestamps[cacheKey],
              let transactions = transactionCache[cacheKey] else {
            print("ğŸ’¾ Cache MISS - nÃ£o existe para user \(userId)")
            return nil
        }
        
        let age = Date().timeIntervalSince(timestamp)
        
        if age < cacheExpirationTime {
            print("ğŸ’¾ Cache HIT - \(transactions.count) transaÃ§Ãµes (\(Int(age))s de idade)")
            return transactions
        } else {
            print("ğŸ’¾ Cache EXPIRADO - idade: \(Int(age))s")
            transactionCache.removeValue(forKey: cacheKey)
            cacheTimestamps.removeValue(forKey: cacheKey)
            return nil
        }
    }
    
    // MARK: - ğŸ§¹ Limpeza AutomÃ¡tica
    private func cleanupExpiredCache() {
        let now = Date()
        var cleanedCount = 0
        
        for (key, timestamp) in cacheTimestamps {
            let age = now.timeIntervalSince(timestamp)
            if age > cacheExpirationTime {
                transactionCache.removeValue(forKey: key)
                cacheTimestamps.removeValue(forKey: key)
                cleanedCount += 1
            }
        }
        
        if cleanedCount > 0 {
            print("ğŸ§¹ Limpeza: \(cleanedCount) cache(s) expirado(s) removido(s)")
        }
    }
    
    // MARK: - ğŸ—‘ï¸ Invalidar Cache
    func invalidateCache(for userId: String) {
        let cacheKey = "transactions_\(userId)"
        transactionCache.removeValue(forKey: cacheKey)
        cacheTimestamps.removeValue(forKey: cacheKey)
        print("ğŸ—‘ï¸ Cache invalidado para user \(userId)")
    }
    
    // MARK: - ğŸ“Š EstatÃ­sticas
    func printCacheStats() {
        print("\nğŸ“Š === ESTATÃSTICAS DO CACHE ===")
        print("ğŸ“¦ Caches ativos: \(transactionCache.count)")
        print("â° Timestamps: \(cacheTimestamps.count)")
        
        for (key, timestamp) in cacheTimestamps {
            let age = Date().timeIntervalSince(timestamp)
            let remaining = Int(cacheExpirationTime - age)
            print("  â€¢ \(key): \(Int(age))s, expira em \(max(0, remaining))s")
        }
        print("================================\n")
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 3: Services/TransactionService.swift (MODIFICAR)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// âš ï¸ MODIFICAÃ‡Ã•ES NECESSÃRIAS:
// 1. Corrigir isValidTransaction para aceitar valores negativos
// 2. Alterar funÃ§Ã£o getUserTransactions() para usar cache
// 3. Adicionar invalidateCache() em create, update e delete
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import Foundation
import FirebaseFirestore

// MARK: - ğŸ’¼ Service Especializado de TransaÃ§Ãµes
/*
 ğŸ“ SERVICE COM REGRAS DE NEGÃ“CIO ESPECÃFICAS
 
 ğŸ¯ Por que criar service especializado:
 â€¢ Encapsula regras de negÃ³cio de transaÃ§Ãµes
 â€¢ Usa o FirestoreService genÃ©rico como base
 â€¢ Valida dados antes de salvar
 â€¢ Aplica filtros de negÃ³cio ao carregar
 â€¢ Facilita testes de lÃ³gica de negÃ³cio
 */
class TransactionService {
    private let firestoreService = FirestoreService()
    
    // Adicionar propriedade de cache na classe - Parte 8:
    private let cacheManager = AdvancedCacheManager.shared // âœ… Usar singleton
    
    // MARK: - â• Criar TransaÃ§Ã£o
    /*
     ğŸ“ CRIAÃ‡ÃƒO COM VALIDAÃ‡ÃƒO DE NEGÃ“CIO
     
     ğŸ¯ Processo:
     1. Valida dados da transaÃ§Ã£o
     2. Adiciona userId Ã  transaÃ§Ã£o
     3. Salva no path hierÃ¡rquico correto
     4. Retorna ID do documento criado
     */
    func createTransaction(_ transaction: Transaction, for userId: String) async throws -> String {
        print("ğŸ­ TransactionService: Criando transaÃ§Ã£o para user \(userId)")
        
        // âœ… VALIDAÃ‡Ã•ES DE NEGÃ“CIO
        guard isValidTransaction(transaction) else {
            print("âŒ TransaÃ§Ã£o invÃ¡lida - nÃ£o passou nas validaÃ§Ãµes")
            throw FirestoreError.invalidData
        }
        
        // ğŸ“ Adicionar userId Ã  transaÃ§Ã£o
        var transactionWithUser = transaction
        transactionWithUser.userId = userId
        
        // ğŸ—‚ï¸ Path hierÃ¡rquico NoSQL
        let collectionPath = "users/\(userId)/transactions"
        print("   ğŸ“‚ Path: \(collectionPath)")
        
        // ğŸ’¾ Delegar para service genÃ©rico
        let documentId = try await firestoreService.saveDocument(
            transactionWithUser,
            to: collectionPath
        )
        
        print("âœ… TransaÃ§Ã£o criada com sucesso: \(documentId)")
        
        // Invalidar cache apÃ³s CREATE:
        cacheManager.invalidateCache(for: userId)
        
        return documentId
    }
    
    // MARK: - ğŸ“‹ Buscar TransaÃ§Ãµes do UsuÃ¡rio - (âœ… NOVO - PARTE 8)
    func getUserTransactions(userId: String, limit: Int = 50) async throws -> [Transaction] {
        print("ğŸ“‹ TransactionService: Buscando transaÃ§Ãµes do usuÃ¡rio \(userId)")
        
        // 1ï¸âƒ£ Verificar cache primeiro
        if let cached = cacheManager.getCachedTransactions(for: userId) {
            return cached
        }
        

        // 2ï¸âƒ£ Se nÃ£o tem cache, buscar do Firestore
        let collectionPath = "users/\(userId)/transactions"
        let transactions = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            limit: limit,
            orderBy: "date",
            descending: true
        )

        // âœ… Aplicar filtros de negÃ³cio
        let validTransactions = transactions
            .filter { isValidTransaction($0) }
            .filter { !$0.isDeleted }

        // 3ï¸âƒ£ Salvar no cache
        cacheManager.cacheTransactions(validTransactions, for: userId)


        print("âœ… TransaÃ§Ãµes carregadas e cacheadas: \(validTransactions.count)")
        
        return validTransactions
    }
    
    
    // MARK: - READ Including Deleted (âœ… NOVO - PARTE 5)
        /*
         ğŸ“– BUSCAR TODAS AS TRANSAÃ‡Ã•ES (INCLUINDO DELETADAS)
         
         Ãštil para:
         - AdministraÃ§Ã£o e auditoria
         - RelatÃ³rios completos
         - RecuperaÃ§Ã£o de dados
         - AnÃ¡lise de histÃ³rico completo
         */
        func getAllTransactionsIncludingDeleted(
            userId: String,
            limit: Int = 50
        ) async throws -> [Transaction] {
            print("ğŸ“– TransactionService: Buscando TODAS transaÃ§Ãµes (incluindo deletadas)")
            print("  ğŸ“ Limite: \(limit)")
            
            let collectionPath = "users/\(userId)/transactions"
            
            let transactions: [Transaction] = try await firestoreService.getDocuments(
                from: collectionPath,
                type: Transaction.self,
                limit: limit,
                orderBy: "date",
                descending: true
            )
            
            // SÃ³ valida, mas NÃƒO filtra deletados
            let validTransactions = transactions.filter { isValidTransaction($0) }
            
            print("âœ… \(validTransactions.count) transaÃ§Ãµes totais (incluindo deletadas)")
            return validTransactions
        }
    
    // MARK: - ğŸ¯ Regras de NegÃ³cio
    /*
     ğŸ“ VALIDAÃ‡Ã•ES ESPECÃFICAS DE TRANSAÃ‡Ã•ES
     
     ğŸ¯ Regras aplicadas:
     â€¢ Valor deve ser positivo
     â€¢ DescriÃ§Ã£o nÃ£o pode estar vazia
     â€¢ Adicione mais regras conforme necessÃ¡rio
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // âŒ ANTES: guard transaction.amount > 0// âœ… AGORA:
        guard transaction.amount != 0 else {
           print("âŒ Valor invÃ¡lido: \(transaction.amount)")
           return false
        }
            
        // 2. Description nÃ£o pode estar vazia
        guard !transaction.description.isEmpty else {
            print("âŒ ValidaÃ§Ã£o falhou: descriÃ§Ã£o vazia")
            return false
        }
            
        // 3. Data nÃ£o pode ser futura (nova validaÃ§Ã£o!)
        guard transaction.date <= Date() else {
            print("âŒ Data futura: \(transaction.date)")
            return false
        }
            
        return true
    }
    
    // MARK: - ğŸ—‘ï¸ Deletar TransaÃ§Ã£o
    func deleteTransaction(
        transactionId: String,
        userId: String,
        soft: Bool = true  // ğŸ·ï¸ PadrÃ£o: soft delete
    ) async throws {
        let collectionPath = "users/\(userId)/transactions"
        
        if soft {
            // ğŸ·ï¸ SOFT DELETE: marca isDeleted
            print("ğŸ·ï¸ TransactionService: Soft delete de \(transactionId)")
            
            // Buscar documento atual
            var transaction = try await firestoreService.getDocument(
                transactionId,
                from: collectionPath,
                as: Transaction.self
            )
            
            // Marcar como deletado
            transaction.isDeleted = true
            transaction.deletedAt = Date()
            
            // Atualizar com as flags
            try await firestoreService.updateDocument(
                transaction,
                documentId: transactionId,
                in: collectionPath
            )
            
            print("âœ… Soft delete concluÃ­do")
            print("  ğŸ“… deletedAt: \(transaction.deletedAt!)")
            
        } else {
            // ğŸ—‘ï¸ HARD DELETE: remove permanentemente
            print("ğŸ—‘ï¸ TransactionService: Hard delete de \(transactionId)")
            
            try await firestoreService.deleteDocument(
                from: collectionPath,
                documentId: transactionId
            )
            
            print("âœ… Hard delete concluÃ­do - documento removido permanentemente")
        }
        // Invalidar cache apÃ³s DELETE:
        cacheManager.invalidateCache(for: userId)
    }
    
    func updateTransaction(_ transaction: Transaction) async throws {
        print("âœï¸ TransactionService: Atualizando transaÃ§Ã£o")
        
        // ğŸ”’ VALIDAR ID
        guard let id = transaction.id else {
            print("âŒ Erro: TransaÃ§Ã£o deve ter ID para atualizaÃ§Ã£o")
            throw FirestoreError.invalidData
        }
        
        // ğŸ›¡ï¸ VALIDAR DADOS (preventivo!)
        guard isValidTransaction(transaction) else {
            print("âŒ Erro: Dados invÃ¡lidos")
            throw FirestoreError.invalidData
        }
        
        // â° ATUALIZAR TIMESTAMP
        var updatedTransaction = transaction
        updatedTransaction.updatedAt = Date()
        
        let collectionPath = "users/\(transaction.userId)/transactions"
        
        try await firestoreService.updateDocument(
            updatedTransaction,
            documentId: id,
            in: collectionPath,
            merge: true  // âš¡ MERGE INTELIGENTE - preserva campos nÃ£o enviados
        )
        
        print("âœ… TransaÃ§Ã£o atualizada com sucesso")
        print("  ğŸ“… updatedAt: \(updatedTransaction.updatedAt)")
        
        // Invalidar cache apÃ³s UPDATE:
        cacheManager.invalidateCache(for: transaction.userId)
    }
    
    // MARK: - ğŸ”„ Real-time Listeners (âœ¨ PARTE 6 - NOVO!)
    
    /*
     ğŸ‘‚ LISTENER PARA TRANSAÃ‡Ã•ES EM TEMPO REAL
     
     Escuta mudanÃ§as em tempo real e notifica a UI automaticamente.
     Implementa padrÃ£o Observer para sincronizaÃ§Ã£o automÃ¡tica.
     
     ğŸ¯ Como funciona:
     1. Registra interesse nesta query (addSnapshotListener)
     2. Firebase detecta writes/deletes que afetam query
     3. Servidor envia diff (sÃ³ o que mudou) via WebSocket
     4. Closure Ã© executada AUTOMATICAMENTE
     5. UI atualiza sem usuÃ¡rio fazer nada!
     
     ğŸ¯ ParÃ¢metros:
     - userId: ID do usuÃ¡rio proprietÃ¡rio das transaÃ§Ãµes
     - limit: Limite de documentos (padrÃ£o 50 para performance)
     - onUpdate: Closure chamada quando dados mudam (fornece [Transaction])
     - onError: Closure chamada quando ocorre erro
     
     âœ… Retorna: ListenerRegistration para cleanup posterior
     
     âš ï¸ CRÃTICO:
     - SEMPRE chamar listener.remove() quando nÃ£o precisar mais!
     - Usar [weak self] na closure para evitar retain cycle
     - Usar DispatchQueue.main.async para atualizar UI
     */
    func startListeningToUserTransactions(
        userId: String,
        limit: Int = 50,
        onUpdate: @escaping ([Transaction]) -> Void,
        onError: @escaping (Error) -> Void
    ) -> ListenerRegistration {
        
        print("ğŸ‘‚ === INICIANDO LISTENER TEMPO REAL ===")
        print("ğŸ‘¤ UsuÃ¡rio: \(userId)")
        print("ğŸ“ Limite: \(limit) transaÃ§Ãµes")
        print("ğŸ¯ Objetivo: SincronizaÃ§Ã£o automÃ¡tica em tempo real")
        
        // ğŸ—„ï¸ CONSTRUIR QUERY OTIMIZADA
        let db = Firestore.firestore()
        let query = db.collection("users")
            .document(userId)
            .collection("transactions")
            .order(by: "date", descending: true)  // Mais recentes primeiro
            .limit(to: limit)                     // Limitar para performance
        
        print("ğŸ“ Query construÃ­da: users/\(userId)/transactions")
        print("ğŸ”„ Listener ativo - aguardando mudanÃ§as...")
        
        // ğŸ‘‚ ADICIONAR LISTENER (A MÃGICA ACONTECE AQUI!)
        /*
         ğŸ“ addSnapshotListener Ã© o coraÃ§Ã£o do tempo real:
         
         O que acontece:
         1. Firestore "marca" esta query como "interessante"
         2. Toda vez que dados desta query mudam, Firestore avisa
         3. A closure abaixo Ã© executada AUTOMATICAMENTE
         4. Recebemos snapshot com dados atualizados
         
         Ã‰ como assinar notificaÃ§Ãµes push, mas para dados!
         
         Esta closure executa:
         - IMEDIATAMENTE (dados iniciais)
         - TODA VEZ que algo mudar
         - AUTOMATICAMENTE sem a gente chamar nada!
         */
        let listener = query.addSnapshotListener { [weak self] snapshot, error in
            
            // ğŸš¨ TRATAMENTO DE ERRO
            if let error = error {
                print("âŒ Erro no listener: \(error.localizedDescription)")
                
                
                // ğŸ¯ NOTIFICAR ERRO NA THREAD PRINCIPAL
                /*
                 âš ï¸ CRÃTICO: onError atualiza @Published properties na UI!
                 Precisa executar na main thread, assim como onUpdate.
                 
                 Sem isso: Crash "UIKit must be accessed from main thread"
                 */
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
                return
            }
            
            // ğŸ“„ VERIFICAR SNAPSHOT
            guard let snapshot = snapshot else {
                print("âš ï¸ Snapshot vazio recebido")
                DispatchQueue.main.async {
                    onUpdate([])
                }
                return
            }
            
            print("ğŸ“¦ Snapshot recebido: \(snapshot.documents.count) documentos")
            
            // ğŸ¯ CONVERTER DOCUMENTOS PARA OBJETOS SWIFT
            do {
                // Codable faz a mÃ¡gica: Firebase JSON â†’ Swift Object
                let allTransactions = try snapshot.documents.map { document in
                    try document.data(as: Transaction.self)
                }
                
                print("âœ… Convertidos: \(allTransactions.count) transaÃ§Ãµes")
                
                // ğŸ·ï¸ FILTRAR DELETADOS (soft delete - Parte 5!)
                /*
                 Por padrÃ£o, nÃ£o mostramos transaÃ§Ãµes deletadas.
                 isDeleted Ã© do modelo atualizado na Parte 5.
                 */
                let activeTransactions = allTransactions.filter { !$0.isDeleted }
                
                print("ğŸ·ï¸ Filtradas: \(activeTransactions.count) ativas (sem deletadas)")
                
                // ğŸ›¡ï¸ VALIDAR DADOS (defesa em profundidade)
                /*
                 Dupla validaÃ§Ã£o:
                 1. Antes de salvar (preventiva)
                 2. Depois de buscar (garantia)
                 
                 Protege contra dados corrompidos ou regras mudadas.
                 */
                let validTransactions = activeTransactions.filter {
                    self?.isValidTransaction($0) ?? true
                }
                
                print("âœ… Validadas: \(validTransactions.count) transaÃ§Ãµes vÃ¡lidas")
                
                // ğŸ¯ NOTIFICAR UI NA THREAD PRINCIPAL
                /*
                 âš ï¸ CRÃTICO: UI sÃ³ pode ser atualizada na main thread!
                 
                 Listener executa em background thread (Firebase decide).
                 Temos que voltar pra main thread antes de atualizar UI.
                 
                 Sem isso: CRASH garantido!
                 "UIKit must be accessed from main thread"
                 */
                DispatchQueue.main.async {
                    onUpdate(validTransactions)
                }
                
                print("ğŸ¨ UI notificada com \(validTransactions.count) transaÃ§Ãµes")
                
            } catch {
                print("âŒ Erro ao converter documentos: \(error)")
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
            }
        }
        
        print("ğŸ“Œ Listener registrado com sucesso")
        print("âš¡ SincronizaÃ§Ã£o automÃ¡tica ATIVA!")
        
        // âœ… RETORNAR LISTENER PARA CLEANUP POSTERIOR
        /*
         âš ï¸ IMPORTANTE: Este listener precisa ser REMOVIDO quando nÃ£o for mais necessÃ¡rio!
         
         Sem remoÃ§Ã£o = MEMORY LEAK:
         - Listener continua rodando
         - Consome recursos
         - App fica lento
         - Pode travar
         
         Sempre guardar este return e chamar .remove() depois!
         
         Pattern recomendado:
         1. Guardar em var listener: ListenerRegistration?
         2. Chamar listener?.remove() em stopListening()
         3. Ter deinit que chama stopListening() (rede de seguranÃ§a)
         */
        return listener
    }

    // âœ… ADICIONAR mÃ©todo para pegar UID:
    func getCurrentUserId() -> String {
        return Auth.auth().currentUser?.uid ?? "anonymous"
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 4: Views/RealtimeDemoView.swift (MODIFICAR)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// âš ï¸ ADICIONAR botÃ£o de teste APÃ“S o .toolbar { } e ANTES do .onAppear
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import SwiftUI

struct RealtimeDemoView: View {
    @StateObject private var viewModel = RealtimeDemoViewModel()
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {

                    // ğŸ”Œ STATUS DE CONEXÃƒO
                    HStack {
                        Circle()
                            .fill(viewModel.isListening ? Color.green : Color.gray)
                            .frame(width: 8, height: 8)

                        Text(viewModel.isListening ? "Tempo Real Ativo" : "Offline")
                            .font(.caption)
                            .foregroundColor(.secondary)

                        Spacer()
                    }
                    .padding(.horizontal)

                    // ğŸ’° HEADER COM BALANÃ‡O
                    BalanceHeaderView(
                        totalBalance: viewModel.totalBalance,
                        totalIncome: viewModel.totalIncome,
                        totalExpenses: viewModel.totalExpenses,
                        formatter: viewModel.formatCurrency
                    )

                    // ğŸ“Š ESTATÃSTICAS
                    VStack(spacing: 8) {
                        HStack(spacing: 12) {
                            StatisticsCardView(
                                icon: "chart.bar.fill",
                                title: "TransaÃ§Ãµes",
                                value: "\(viewModel.transactionCount)",
                                color: .blue
                            )

                            StatisticsCardView(
                                icon: "chart.line.uptrend.xyaxis",
                                title: "MÃ©dia de Gastos",
                                value: viewModel.formatCurrency(viewModel.averageExpense),
                                color: .orange
                            )
                        }
                    }
                    .padding(.horizontal)

                    // ğŸ“‹ LISTA DE TRANSAÃ‡Ã•ES
                    VStack(alignment: .leading, spacing: 12) {
                        Text("TransaÃ§Ãµes Recentes")
                            .font(.headline)
                            .padding(.horizontal)

                        if viewModel.transactions.isEmpty {
                            EmptyStateView()
                                .frame(height: 300)
                        } else {
                            ForEach(viewModel.transactions.prefix(20)) { transaction in
                                TransactionCardView(
                                    transaction: transaction,
                                    formatter: viewModel.formatCurrency,
                                    dateFormatter: viewModel.formatDate
                                )
                                .padding(.horizontal)
                            }
                        }
                    }

                    Spacer(minLength: 20)
                }
                .padding(.vertical)
            }
            .navigationTitle("ğŸ’« Dashboard")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        viewModel.isListening ? viewModel.stopListening() : viewModel.startListening()
                    }) {
                        Image(systemName: viewModel.isListening ? "pause.circle.fill" : "play.circle.fill")
                            .foregroundColor(viewModel.isListening ? .orange : .green)
                    }
                }
            }
            
            // MARK: - ğŸ¨ BotÃ£o de Teste na UI (âœ¨ NOVO NA PARTE 8)
            // ğŸ“ ADICIONAR ESTE CÃ“DIGO APÃ“S O FECHAMENTO DO .toolbar:

            #if DEBUG
            .safeAreaInset(edge: .bottom) {
                Button(action: {
                    Task {
                        let tester = StressTestManager()
                        await tester.performStressTest()
                    }
                }) {
                    Label("ğŸ§ª Executar Stress Test", systemImage: "bolt.fill")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.orange)
                        .cornerRadius(12)
                }
                .padding()
                .background(Color(UIColor.systemBackground))
            }
            #endif
            
        }
        .onAppear {
            print("ğŸ“± Dashboard apareceu - iniciando listener")
            viewModel.startListening()
        }
        .onDisappear {
            print("ğŸ“± Dashboard desapareceu - parando listener")
            viewModel.stopListening()
        }
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 5: firestore.rules (CONFIGURAR NO FIREBASE CONSOLE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// ğŸ“ ONDE: Firebase Console â†’ Firestore Database â†’ Rules
// ğŸ“ AÃ‡ÃƒO: Substituir TODAS as rules por estas:
// 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rules_version = '2';

/*
ğŸ›¡ï¸ FIRESTORE SECURITY RULES - PRODUÃ‡ÃƒO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Estas rules protegem dados com validaÃ§Ãµes server-side.
NUNCA podem ser burladas pelo cliente.

PrincÃ­pios:
- AutenticaÃ§Ã£o obrigatÃ³ria
- Cada usuÃ¡rio acessa apenas SEUS dados
- ValidaÃ§Ãµes rigorosas em todas operaÃ§Ãµes
- Negar por padrÃ£o (whitelist, nÃ£o blacklist)
*/

service cloud.firestore {
  match /databases/{database}/documents {

    // ğŸš« REGRA PADRÃƒO: NEGAR TUDO
    /*
     Por seguranÃ§a, negamos TUDO por padrÃ£o.
     Somente paths explicitamente permitidos funcionarÃ£o.
     */
    match /{document=**} {
      allow read, write: if false;
    }

    // ğŸ‘¤ USUÃRIOS: Somente prÃ³prio usuÃ¡rio
    match /users/{userId} {
      /*
       Requisitos:
       1. UsuÃ¡rio deve estar autenticado (logged in)
       2. UID do Firebase Auth deve coincidir com {userId}
       */
      allow read, write: if request.auth != null
                         && request.auth.uid == userId;

      // ğŸ’° TRANSAÃ‡Ã•ES: Subcollection com validaÃ§Ãµes
      match /transactions/{transactionId} {

        // ğŸ“– READ: Apenas prÃ³prio usuÃ¡rio
        allow read: if request.auth != null
                    && request.auth.uid == userId;

        // â• CREATE: ValidaÃ§Ã£o completa
        allow create: if request.auth != null
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId);

        // âœï¸ UPDATE: ValidaÃ§Ã£o + nÃ£o pode mudar dono
        allow update: if request.auth != null
                      && request.auth.uid == userId
                      && isValidTransaction(request.resource.data, userId)
                      && resource.data.userId == request.resource.data.userId;

        // ğŸ—‘ï¸ DELETE: Apenas prÃ³prio usuÃ¡rio
        allow delete: if request.auth != null
                      && request.auth.uid == userId;
      }
    }

    // ğŸ›¡ï¸ FUNÃ‡Ã•ES DE VALIDAÃ‡ÃƒO
    /*
     Validam estrutura e regras de negÃ³cio no servidor.
     Cliente NÃƒO pode burlar essas validaÃ§Ãµes!
     */
    function isValidTransaction(data, expectedUserId) {
      /*
       ValidaÃ§Ãµes:
       1. Campos obrigatÃ³rios existem
       2. Tipos corretos
       3. Valores dentro dos limites
       4. UserId corresponde ao esperado
       */
      return data.keys().hasAll(['amount', 'description', 'type', 'userId', 'date', 'createdAt', 'updatedAt', 'isDeleted'])
             && data.amount is number
             && data.amount != 0                    // âŒ NÃ£o pode ser zero
             && data.amount > -1000000              // âŒ NÃ£o pode ser < -1 milhÃ£o
             && data.amount < 1000000               // âŒ NÃ£o pode ser > 1 milhÃ£o
             && data.description is string
             && data.description.size() > 0         // âŒ NÃ£o pode ser vazia
             && data.description.size() <= 200      // âŒ MÃ¡ximo 200 caracteres
             && data.type is string
             && data.type in ['income', 'expense']  // âŒ Apenas income ou expense
             && data.userId is string
             && data.userId == expectedUserId       // âŒ UserId deve corresponder
             && data.date is timestamp             // âŒ Date deve ser timestamp
             && data.createdAt is timestamp
             && data.updatedAt is timestamp
             && data.isDeleted is bool
             && (!data.keys().hasAny(['deletedAt']) || data.deletedAt is timestamp); // deletedAt opcional
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 6: Transaction.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Foundation
import FirebaseFirestore

// MARK: - ğŸ’° Modelo de TransaÃ§Ã£o
struct Transaction: Identifiable, Codable {
    @DocumentID var id: String?
    var amount: Double
    var description: String
    var type: TransactionType
    var date: Date
    var userId: String
    // âœ¨ NOVOS CAMPOS - PARTE 5: Timestamps de Auditoria
    var createdAt: Date = Date()        // Quando foi criado
    var updatedAt: Date = Date()        // Ãšltima atualizaÃ§Ã£o
    var isDeleted: Bool = false         // Soft delete
    var deletedAt: Date?                // Quando foi deletado
    
    // ğŸ’¡ OPCIONAL: Campos adicionais que podem ser adicionados depois
    // var tags: [String] = []
    // var notes: String?
    
    enum TransactionType: String, Codable, CaseIterable {
        case income = "income"
        case expense = "expense"
        
        var displayName: String {
            switch self {
            case .income: return "Receita"
            case .expense: return "Despesa"
            }
        }
        
        var icon: String {
            switch self {
            case .income: return "arrow.down.circle.fill"
            case .expense: return "arrow.up.circle.fill"
            }
        }
    }
    
    // Inicializador para criar novas transaÃ§Ãµes
    init(amount: Double, description: String, type: TransactionType, userId: String) {
        self.amount = amount
        self.description = description
        self.type = type
        self.date = Date()
        self.userId = userId
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 7: FirebaseTestManager.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Foundation
import FirebaseFirestore

class FirebaseTestManager {
    private let db = Firestore.firestore()
    
    // ğŸ¯ TESTE PRINCIPAL: Create â†’ Read â†’ Delete
    func executeCompleteTest() {
        print("ğŸš€ Iniciando teste completo Firebase...")
        testCreateDocument()
    }
    
    // âœ… TESTE 1: CriaÃ§Ã£o de documento
    private func testCreateDocument() {
        let testData = [
            "message": "Firebase conectado com sucesso!",
            "timestamp": FieldValue.serverTimestamp(),
            "testId": UUID().uuidString
        ] as [String : Any]
        
        db.collection("connection_tests").addDocument(data: testData)
    }

    private func handleConnectionError(_ error: Error) {
        let nsError = error as NSError

        switch nsError.code {
        case 7: // PERMISSION_DENIED
            print("ğŸš« Erro de permissÃ£o - Verificar Security Rules")
        case 14: // UNAVAILABLE
            print("ğŸŒ Sem conexÃ£o com internet")
        case 16: // UNAUTHENTICATED
            print("ğŸ” UsuÃ¡rio nÃ£o autenticado")
        default:
            print("âŒ Erro desconhecido: \(error.localizedDescription)")
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 8: FirestoreConfiguration.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Foundation
import FirebaseCore
import FirebaseFirestore

// MARK: - âš™ï¸ ConfiguraÃ§Ã£o Centralizada do Firestore
/*
 ğŸ“ CLASSE DE CONFIGURAÃ‡ÃƒO AVANÃ‡ADA
 
 ğŸ¯ Expande a configuraÃ§Ã£o bÃ¡sica da Aula 2.1 com:
 â€¢ Cache offline otimizado por ambiente
 â€¢ Logging inteligente
 â€¢ ValidaÃ§Ã£o de settings aplicados
 */
class FirestoreConfiguration {
    
    // ğŸ¯ CONFIGURAÃ‡ÃƒO AVANÃ‡ADA (CHAMADA APÃ“S FirebaseApp.configure())
    static func configureAdvanced() {
        let db = Firestore.firestore()
        
        print("âš™ï¸ Aplicando configuraÃ§Ãµes avanÃ§adas Firestore...")
        print("ğŸ“Š Ambiente: \(EnvironmentConfig.environmentName)")
        
        // ğŸ“Š APLICAR SETTINGS DO AMBIENTE
        db.settings = EnvironmentConfig.firestoreSettings
        
        // ğŸ¯ CONFIGURAR LOGGING
        configureLogging()
        
        // âœ… CONFIRMAR CONFIGURAÃ‡ÃƒO
        logConfigurationStatus(db: db)
    }
    
    // ğŸ“ CONFIGURAÃ‡ÃƒO DE LOGGING
    private static func configureLogging() {
        if EnvironmentConfig.debugLogging {
            print("   ğŸ“ Debug logging: HABILITADO")
            
            // ğŸ” Firebase internal logging (sÃ³ desenvolvimento)
            if Environment.current == .development {
                FirebaseConfiguration.shared.setLoggerLevel(.debug)
            }
        } else {
            print("   ğŸ”‡ Debug logging: DESABILITADO (ProduÃ§Ã£o)")
            FirebaseConfiguration.shared.setLoggerLevel(.error)
        }
    }
    
    // ğŸ“Š LOG DO STATUS DA CONFIGURAÃ‡ÃƒO
    private static func logConfigurationStatus(db: Firestore) {
        let settings = db.settings
        
        print("âœ… ConfiguraÃ§Ã£o avanÃ§ada aplicada:")
        
        // Verificar tipo de cache configurado
        if settings.cacheSettings is MemoryCacheSettings {
            print("   â€¢ Cache: Memory (apenas em memÃ³ria)")
        } else if settings.cacheSettings is PersistentCacheSettings {
            print("   â€¢ Cache: Persistent (disco + memÃ³ria)")
        } else {
            print("   â€¢ Cache: PadrÃ£o")
        }
        
        print("   â€¢ SSL: \(settings.isSSLEnabled ? "ATIVO" : "INATIVO")")
        print("   â€¢ Ambiente: \(EnvironmentConfig.environmentName)")
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 9: EnvironmentConfig.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Foundation
import FirebaseFirestore

// ğŸ—ï¸ CONFIGURAÃ‡ÃƒO PROFISSIONAL DE AMBIENTES
enum Environment {
    case development, staging, production

    static var current: Environment {
        #if DEBUG
        return .development
        #elseif STAGING
        return .staging
        #else
        return .production
        #endif
    }
}


struct EnvironmentConfig {
    static var projectId: String {
        switch Environment.current {
        case .development: return "financas-app-dev"
        case .staging: return "financas-app-staging"
        case .production: return "financas-app-prod"
        }
    }
    
    // âš™ï¸ CONFIGURAÃ‡Ã•ES ESPECÃFICAS DO FIRESTORE
    static var firestoreSettings: FirestoreSettings {
        let settings = FirestoreSettings()
        
        switch Environment.current {
        case .development:
            // ğŸ’¾ DESENVOLVIMENTO: Cache agressivo para velocidade
            settings.cacheSettings = MemoryCacheSettings()
            print("   ğŸ“ Cache: Memory (Development)")
            
        case .staging:
            // ğŸ§ª STAGING: ConfiguraÃ§Ã£o hÃ­brida
            settings.cacheSettings = PersistentCacheSettings(
                sizeBytes: 75_000_000  // âœ… 75MB em bytes
            )
            print("   ğŸ“ Cache: Persistent (Staging)")
            
        case .production:
            // ğŸš€ PRODUÃ‡ÃƒO: Otimizado para bateria e armazenamento
            settings.cacheSettings = PersistentCacheSettings(
                sizeBytes: 50_000_000  // âœ… 50MB em bytes
            )
            print("   ğŸ“ Cache: Persistent (Production)")
        }
        
        // ğŸ›¡ï¸ SEGURANÃ‡A: SSL sempre ativo
        settings.isSSLEnabled = true
        
        return settings
    }
    
    // ğŸ“Š DEBUG LOGGING POR AMBIENTE
    static var debugLogging: Bool {
        switch Environment.current {
        case .development, .staging:
            return true
        case .production:
            return false
        }
    }
    
    // ğŸ“± NOME DO AMBIENTE PARA EXIBIÃ‡ÃƒO
    static var environmentName: String {
        switch Environment.current {
        case .development:
            return "ğŸ”§ Development"
        case .staging:
            return "ğŸ§ª Staging"
        case .production:
            return "ğŸš€ Production"
        }
    }
    
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 10: ConfigurationValidator.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Foundation
import FirebaseFirestore

// MARK: - ğŸ§ª Validador AutomÃ¡tico de ConfiguraÃ§Ã£o
/*
 ğŸ“ VALIDA A CONFIGURAÃ‡ÃƒO DO FIREBASE
 
 ğŸ¯ Testa automaticamente:
 â€¢ ConexÃ£o com Firestore
 â€¢ Settings aplicados corretamente
 â€¢ OperaÃ§Ã£o bÃ¡sica funcionando
 */
class ConfigurationValidator {
    
    // ğŸ§ª RESULTADO DA VALIDAÃ‡ÃƒO
    struct ValidationResult {
        let isValid: Bool
        let message: String
    }
    
    // ğŸ” VALIDAÃ‡ÃƒO COMPLETA
    static func validateSetup() async -> ValidationResult {
        print("\nğŸ§ª Validando configuraÃ§Ã£o avanÃ§ada...")
        
        // âœ… 1. TESTAR CONEXÃƒO
        let connectionOK = await testConnection()
        if !connectionOK {
            return ValidationResult(
                isValid: false,
                message: "âŒ Falha na conexÃ£o com Firestore"
            )
        }
        
        // âœ… 2. VALIDAR SETTINGS
        let settingsOK = validateSettings()
        if !settingsOK {
            return ValidationResult(
                isValid: false,
                message: "âš ï¸ ConfiguraÃ§Ãµes nÃ£o aplicadas corretamente"
            )
        }
        
        // âœ… 3. TESTAR OPERAÃ‡ÃƒO
        let operationOK = await testOperation()
        if !operationOK {
            return ValidationResult(
                isValid: false,
                message: "âŒ Falha no teste de operaÃ§Ã£o"
            )
        }
        
        print("âœ… ValidaÃ§Ã£o completa: SUCESSO!\n")
        return ValidationResult(
            isValid: true,
            message: "ğŸ‰ ConfiguraÃ§Ã£o avanÃ§ada validada!"
        )
    }
    
    // ğŸ”— TESTE DE CONEXÃƒO
    private static func testConnection() async -> Bool {
        do {
            let db = Firestore.firestore()
            print("   ğŸ”— Testando conexÃ£o...")
            
            // OperaÃ§Ã£o mÃ­nima para validar conectividade
            _ = try await db.collection("config_validation")
                .document("test")
                .getDocument()
            
            print("   âœ… ConexÃ£o OK")
            return true
        } catch {
            print("   âŒ Erro de conexÃ£o: \(error.localizedDescription)")
            return false
        }
    }
    
    // âš™ï¸ VALIDAÃ‡ÃƒO DE SETTINGS
    private static func validateSettings() -> Bool {
        let db = Firestore.firestore()
        let settings = db.settings
        
        print("   âš™ï¸ Validando settings aplicados...")
        
        // Verificar configuraÃ§Ãµes crÃ­ticas
        guard settings.isSSLEnabled else {
            print("   âŒ SSL nÃ£o estÃ¡ habilitado")
            return false
        }
        
        // Verificar se cache estÃ¡ configurado corretamente
        // (cacheSettings sempre existe, nÃ£o precisa verificar nil)
        print("   âœ… Cache configurado: \(type(of: settings.cacheSettings))")
        
        print("   âœ… Settings validados")
        return true
    }
    
    // ğŸ’¾ TESTE DE OPERAÃ‡ÃƒO
    private static func testOperation() async -> Bool {
        do {
            let db = Firestore.firestore()
            print("   ğŸ’¾ Testando operaÃ§Ã£o de escrita...")
            
            let testData: [String: Any] = [
                "validated": true,
                "timestamp": Timestamp(),
                "environment": EnvironmentConfig.environmentName
            ]
            
            try await db.collection("config_validation")
                .document("test")
                .setData(testData)
            
            print("   âœ… OperaÃ§Ã£o OK")
            return true
        } catch {
            print("   âŒ Erro na operaÃ§Ã£o: \(error.localizedDescription)")
            return false
        }
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 11: FirestoreService.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Foundation
import FirebaseFirestore

// MARK: - ğŸ”§ Service GenÃ©rico do Firestore
/*
 ğŸ“ SERVICE LAYER BASE - REUTILIZÃVEL
 
 ğŸ¯ Este service Ã© genÃ©rico e funciona com QUALQUER modelo Codable:
 â€¢ Transaction, User, Product, Category, etc.
 â€¢ Uma base sÃ³lida para todos os outros services
 â€¢ Centraliza comunicaÃ§Ã£o com Firestore
 â€¢ Facilita manutenÃ§Ã£o e testes
 */
class FirestoreService {
    private let db = Firestore.firestore()
    
    // MARK: - ğŸ“¥ Buscar Documentos (Generic GET)
    /*
     ğŸ“ MÃ‰TODO GENÃ‰RICO DE LEITURA
     
     ğŸ¯ Funcionalidades:
     â€¢ Funciona com qualquer tipo Codable
     â€¢ Suporta ordenaÃ§Ã£o e limite
     â€¢ Logs educativos para debugging
     â€¢ Error handling robusto
     
     ğŸ’¡ Exemplo de uso:
     let transactions = try await getDocuments(
         from: "transactions",
         type: Transaction.self,
         limit: 10,
         orderBy: "date",
         descending: true
     )
     */
    func getDocuments<T: Codable>(
        from collection: String,
        type: T.Type,
        limit: Int? = nil,
        orderBy field: String? = nil,
        descending: Bool = false
    ) async throws -> [T] {
        print("ğŸ” FirestoreService: Buscando documentos de \(collection)")
        
        do {
            var query: Query = db.collection(collection)
            
            // ğŸ“Š Aplicar ordenaÃ§Ã£o se especificada
            if let orderField = field {
                query = query.order(by: orderField, descending: descending)
                print("   ğŸ“Š Ordenando por: \(orderField) (desc: \(descending))")
            }
            
            // ğŸ”¢ Aplicar limite se especificado
            if let limitCount = limit {
                query = query.limit(to: limitCount)
                print("   ğŸ”¢ Limite: \(limitCount) documentos")
            }
            
            // ğŸŒ Executar query
            let snapshot = try await query.getDocuments()
            
            // ğŸ”„ Decodificar documentos
            let documents = snapshot.documents.compactMap { document -> T? in
                do {
                    let decoded = try document.data(as: type)
                    print("   âœ… Documento decodificado: \(document.documentID)")
                    return decoded
                } catch {
                    print("   âŒ Erro ao decodificar documento \(document.documentID): \(error)")
                    return nil
                }
            }
            
            print("ğŸ“Š Total de documentos carregados: \(documents.count)")
            return documents
            
        } catch {
            print("ğŸ’¥ Erro no FirestoreService: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    
    func getDocument<T: Codable>(
            _ documentId: String,
            from collection: String,
            as type: T.Type
        ) async throws -> T {
            print("ğŸ“– FirestoreService: Buscando documento \(documentId)")
            
            do {
                let docRef = db.collection(collection).document(documentId)
                let document = try await docRef.getDocument(as: type)
                
                print("âœ… Documento encontrado")
                return document
                
            } catch {
                print("âŒ Erro ao buscar documento: \(error)")
                throw FirestoreError.from(error)
            }
    }
    
    // MARK: - ğŸ’¾ Salvar Documento (Generic CREATE/UPDATE)
    /*
     ğŸ“ MÃ‰TODO GENÃ‰RICO DE ESCRITA
     
     ğŸ¯ Funcionalidades:
     â€¢ Cria ou atualiza documentos
     â€¢ Auto-gera ID se nÃ£o fornecido
     â€¢ Retorna o ID do documento salvo
     â€¢ Logs para tracking
     */
    func saveDocument<T: Codable>(
        _ document: T,
        to collection: String,
        documentId: String? = nil
    ) async throws -> String {
        print("ğŸ’¾ FirestoreService: Salvando documento em \(collection)")
        
        do {
            let ref: DocumentReference
            
            if let id = documentId {
                ref = db.collection(collection).document(id)
                print("   ğŸ“ Atualizando documento existente: \(id)")
            } else {
                ref = db.collection(collection).document()
                print("   âœ¨ Criando novo documento com ID: \(ref.documentID)")
            }
            
            try ref.setData(from: document)
            
            print("âœ… Documento salvo com sucesso: \(ref.documentID)")
            return ref.documentID
            
        } catch {
            print("ğŸ’¥ Erro ao salvar documento: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    // MARK: - ğŸ—‘ï¸ Deletar Documento (Generic DELETE)
    func deleteDocument(from collection: String, documentId: String) async throws {
        print("ğŸ—‘ï¸ FirestoreService: Deletando documento \(documentId)")
        
        do {
            try await db.collection(collection).document(documentId).delete()
            print("âœ… Documento deletado com sucesso")
        } catch {
            print("ğŸ’¥ Erro ao deletar: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    func updateDocument<T: Codable>(
            _ document: T,
            documentId: String,
            in collection: String,  // âš¡ MantÃ©m padrÃ£o com saveDocument
            merge: Bool = true
        ) async throws {
            print("âœï¸ FirestoreService: Atualizando \(documentId) em \(collection)")
            print("  âš¡ Modo merge: \(merge)")
            
            do {
                if merge {
                    try db.collection(collection)
                        .document(documentId)
                        .setData(from: document, merge: true)
                } else {
                    try db.collection(collection)
                        .document(documentId)
                        .setData(from: document)
                }
                print("âœ… Documento atualizado com sucesso")
                
            } catch {
                print("âŒ Erro ao atualizar: \(error)")
                throw FirestoreError.from(error)
            }
        }
    
    // MARK: - ğŸ”„ Mapeamento de Erros
    /*
     ğŸ“ TRADUÃ‡ÃƒO DE ERROS DO FIREBASE
     
     ğŸ¯ Converte erros genÃ©ricos do Firebase em erros especÃ­ficos
     do nosso app, com mensagens amigÃ¡veis.
     */
    private func mapFirebaseError(_ error: Error) -> FirestoreError {
        if let firestoreError = error as? FirestoreErrorCode {
            switch firestoreError.code {
            case .notFound:
                return .documentNotFound
            case .permissionDenied:
                return .permissionDenied
            case .resourceExhausted:
                return .quotaExceeded
            default:
                return .networkError(error)
            }
        }
        return .unknown(error)
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 12: FirestoreError.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Foundation

// MARK: - ğŸ›¡ï¸ Sistema de Erros Profissional
/*
 ğŸ“ ERROS CUSTOMIZADOS DO FIRESTORE
 
 ğŸ¯ Por que criar erros customizados:
 â€¢ Mensagens especÃ­ficas e amigÃ¡veis ao usuÃ¡rio
 â€¢ Diferentes tipos de tratamento por tipo de erro
 â€¢ Logs detalhados para debugging
 â€¢ Facilita identificaÃ§Ã£o de problemas em produÃ§Ã£o
 */
enum FirestoreError: LocalizedError {
    case documentNotFound
    case invalidData
    case networkError(Error)
    case permissionDenied
    case quotaExceeded
    case unknown(Error)
    
    // ğŸ“± MENSAGENS AMIGÃVEIS PARA O USUÃRIO
    var errorDescription: String? {
        switch self {
        case .documentNotFound:
            return "Documento nÃ£o encontrado. Verifique se os dados existem."
        case .invalidData:
            return "Dados invÃ¡lidos. Formato nÃ£o suportado."
        case .networkError(let error):
            return "Erro de conexÃ£o: \(error.localizedDescription)"
        case .permissionDenied:
            return "Acesso negado. Verifique suas permissÃµes."
        case .quotaExceeded:
            return "Limite de uso excedido. Tente novamente mais tarde."
        case .unknown(let error):
            return "Erro desconhecido: \(error.localizedDescription)"
        }
    }
    
    static func from(_ error: Error) -> FirestoreError {
            // Converte Error genÃ©rico para NSError para acessar cÃ³digo
            let nsError = error as NSError
            
            switch nsError.code {
            case 7:  // FirestoreErrorCode.permissionDenied
                return .permissionDenied
            case 5:  // FirestoreErrorCode.notFound
                return .documentNotFound
            case 14: // FirestoreErrorCode.unavailable
                return .networkError(error)
            case 8:  // FirestoreErrorCode.resourceExhausted
                return .quotaExceeded
            default:
                return .unknown(error)
            }
        }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 13: FinancasAppApp.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI
import Firebase

@main
struct FinancasAppApp: App {
    
    init() {
           // ğŸ”¥ CONFIGURAÃ‡ÃƒO DO FIREBASE
           configureFirebase()
       }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
    

    private func configureFirebase() {
          print("ğŸ”¥ Iniciando configuraÃ§Ã£o do Firebase...")
          print("ğŸ“Š Ambiente detectado: \(EnvironmentConfig.environmentName)")
          
          // ğŸ“‹ Verificar arquivo de configuraÃ§Ã£o
          guard let path = Bundle.main.path(
              forResource: "GoogleService-Info",
              ofType: "plist"
          ) else {
              print("âŒ GoogleService-Info.plist nÃ£o encontrado!")
              fatalError("Firebase config missing")
          }
          
          print("âœ… Arquivo encontrado em: \(path)")
          
          // ğŸš€ 1. CONFIGURAÃ‡ÃƒO BASE (Aula 2.1)
          FirebaseApp.configure()
          print("âœ… Firebase App inicializado")
          
          // âš™ï¸ 2. CONFIGURAÃ‡ÃƒO AVANÃ‡ADA (Aula 2.2 - NOVO!)
          FirestoreConfiguration.configureAdvanced()
          print("âœ… Firestore otimizado para \(EnvironmentConfig.environmentName)")
          
          print("ğŸ‰ ConfiguraÃ§Ã£o completa finalizada!\n")
      }  
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 14: ContentView.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI

/*
 ğŸ  CONTENTVIEW - TELA PRINCIPAL DO APP
 
 Menu principal com navegaÃ§Ã£o para diferentes demos:
 - CRUD Completo (Parte 5)
 - Tempo Real (Parte 6)
 
 Estrutura:
 - NavigationView (para NavigationLinks funcionarem)
 - CabeÃ§alho visual
 - BotÃµes de demonstraÃ§Ã£o
 - ValidaÃ§Ã£o automÃ¡tica no .task
 */
struct ContentView: View {
    
    var body: some View {
        NavigationView {
            VStack(spacing: 30) {
                
                // ğŸ“± CABEÃ‡ALHO
                VStack(spacing: 10) {
                    Image(systemName: "building.columns.fill")
                        .font(.system(size: 80))
                        .foregroundColor(.blue)
                    
                    Text("ğŸ›¡ï¸ Service Layer Demo")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                    
                    Text("Arquitetura Profissional")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 50)
                
                // ğŸ¯ DEMONSTRAÃ‡Ã•ES
                VStack(spacing: 15) {
                    Text("DemonstraÃ§Ãµes")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    // ============================================================
                    // âœ… CRUD COMPLETO (PARTE 5)
                    // ============================================================
                    NavigationLink(destination: CRUDDemoView()) {
                        HStack {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.green)
                                .font(.title2)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Testar CRUD Completo")
                                    .fontWeight(.semibold)
                                    .foregroundColor(.primary)
                                
                                Text("CREATE + READ + UPDATE + DELETE + Auditoria")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .foregroundColor(.gray)
                        }
                        .padding()
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    // ============================================================
                    // âœ¨ TEMPO REAL (PARTE 6 - NOVO!)
                    // ============================================================
                    NavigationLink(destination: RealtimeDemoView()) {
                        HStack {
                            Image(systemName: "bolt.circle.fill")
                                .foregroundColor(.blue)
                                .font(.title2)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Testar Tempo Real")
                                    .fontWeight(.semibold)
                                    .foregroundColor(.primary)
                                
                                Text("SincronizaÃ§Ã£o AutomÃ¡tica + Timestamps")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .foregroundColor(.gray)
                        }
                        .padding()
                        .background(Color.blue.opacity(0.1))
                        .cornerRadius(10)
                    }
                }
                .padding(.horizontal)
                
                Spacer()
                
                // â„¹ï¸ INFORMAÃ‡ÃƒO DE AMBIENTE
                Text(EnvironmentConfig.environmentName)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.bottom)
            }
            .navigationBarHidden(true)
        }
        .task {
            // ğŸ§ª ValidaÃ§Ã£o automÃ¡tica da configuraÃ§Ã£o
            print("ğŸ§ª Executando validaÃ§Ã£o automÃ¡tica...")
            let result = await ConfigurationValidator.validateSetup()
            
            if result.isValid {
                print("ğŸ‰ App pronto para uso!")
            } else {
                print("âš ï¸ \(result.message)")
            }
        }
    }
}

#Preview {
    ContentView()
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 15: ContentView.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI
import FirebaseFirestore

// âŒ EXEMPLO DE CÃ“DIGO RUIM - NÃƒO USAR EM PRODUÃ‡ÃƒO
// Este cÃ³digo serve apenas para demonstraÃ§Ã£o do problema

struct BadTransactionView: View {
    @State private var transactions: [Transaction] = []
    @State private var isLoading = false
    @State private var errorMessage: String?
    
    var body: some View {
        NavigationView {
            ZStack {
                if isLoading {
                    ProgressView("Carregando...")
                } else if let error = errorMessage {
                    VStack(spacing: 20) {
                        Image(systemName: "exclamationmark.triangle")
                            .font(.system(size: 60))
                            .foregroundColor(.red)
                        Text("Erro ao carregar")
                            .font(.headline)
                        Text(error)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding()
                } else if transactions.isEmpty {
                    VStack(spacing: 20) {
                        Image(systemName: "doc.text")
                            .font(.system(size: 60))
                            .foregroundColor(.gray)
                        Text("Nenhuma transaÃ§Ã£o")
                            .font(.headline)
                        Text("Adicione transaÃ§Ãµes no Firebase Console")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding()
                } else {
                    List(transactions) { transaction in
                        HStack {
                            // Ãcone
                            Image(systemName: transaction.type.icon)
                                .foregroundColor(transaction.type == .income ? .green : .red)
                                .font(.title2)
                            
                            // DescriÃ§Ã£o
                            VStack(alignment: .leading, spacing: 4) {
                                Text(transaction.description)
                                    .font(.headline)
                                Text(transaction.date, style: .date)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            // Valor
                            Text("R$ \(transaction.amount, specifier: "%.2f")")
                                .font(.headline)
                                .foregroundColor(transaction.type == .income ? .green : .red)
                        }
                        .padding(.vertical, 4)
                    }
                }
            }
            .navigationTitle("CÃ³digo Espaguete ğŸ")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: loadTransactions) {
                        Image(systemName: "arrow.clockwise")
                    }
                }
            }
            .onAppear {
                loadTransactions()
            }
        }
    }
    
    // âŒ PROBLEMA: View fazendo TUDO
    // - Conecta diretamente no Firestore
    // - Faz parsing manual
    // - Trata erros de forma bÃ¡sica
    // - LÃ³gica de negÃ³cio misturada com UI
    // - ImpossÃ­vel de testar isoladamente
    // - CÃ³digo duplicado em outras telas
    private func loadTransactions() {
        isLoading = true
        errorMessage = nil
        
        let db = Firestore.firestore()
        
        // ğŸ˜± ConexÃ£o direta sem abstraÃ§Ã£o
        db.collection("transactions").getDocuments { snapshot, error in
            DispatchQueue.main.async {
                self.isLoading = false
                
                if let error = error {
                    // âŒ Error handling bÃ¡sico
                    self.errorMessage = "Erro: \(error.localizedDescription)"
                    print("âŒ Erro ao carregar: \(error)")
                    return
                }
                
                guard let documents = snapshot?.documents else {
                    self.errorMessage = "Nenhum documento encontrado"
                    return
                }
                
                // ğŸ˜± Parsing manual propenso a erros
                var loadedTransactions: [Transaction] = []
                for document in documents {
                    do {
                        let transaction = try document.data(as: Transaction.self)
                        loadedTransactions.append(transaction)
                    } catch {
                        print("âŒ Erro ao decodificar: \(error)")
                    }
                }
                
                self.transactions = loadedTransactions
                print("ğŸ“Š TransaÃ§Ãµes carregadas: \(loadedTransactions.count)")
            }
        }
    }
}

#Preview {
    BadTransactionView()
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 16: CrudDemoView.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI

// MARK: - CRUDDemoView
struct CRUDDemoView: View {
    @StateObject private var viewModel = CRUDDemoViewModel()
    
    var body: some View {
        VStack(spacing: 20) {
            // ğŸ” CabeÃ§alho
            Text("Teste CRUD Completo")
                .font(.title2)
                .fontWeight(.bold)
                .padding(.top)
            
            // â• BotÃ£o Criar
            Button(action: {
                Task { await viewModel.createTransaction() }
            }) {
                Label("Criar Nova TransaÃ§Ã£o", systemImage: "plus.circle.fill")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            
            // ğŸ“‹ BotÃ£o Carregar + Toggle Deletados
            HStack(spacing: 15) {
                Button(action: {
                    Task { await viewModel.loadTransactions() }
                }) {
                    Label("Carregar Lista", systemImage: "list.bullet")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.green.opacity(0.8))
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                
                // âœ¨ TOGGLE MOSTRAR DELETADOS
                Button(action: {
                    Task { await viewModel.toggleShowDeleted() }
                }) {
                    Image(systemName: viewModel.showDeleted ? "eye.fill" : "eye.slash.fill")
                        .font(.title2)
                        .foregroundColor(viewModel.showDeleted ? .orange : .gray)
                        .padding()
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(10)
                }
            }
            
            // âœï¸ BotÃ£o Atualizar
            Button(action: {
                Task { await viewModel.updateFirstTransaction() }
            }) {
                Label("Atualizar Primeira", systemImage: "pencil.circle.fill")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.orange.opacity(0.8))
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            .disabled(viewModel.transactions.isEmpty)
            
            // ğŸ·ï¸ğŸ—‘ï¸ BotÃµes Delete
            HStack(spacing: 15) {
                Button(action: {
                    Task { await viewModel.softDeleteFirst() }
                }) {
                    Label("Soft Delete", systemImage: "tag.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.yellow.opacity(0.8))
                        .foregroundColor(.black)
                        .cornerRadius(10)
                }
                
                Button(action: {
                    Task { await viewModel.hardDeleteFirst() }
                }) {
                    Label("Hard Delete", systemImage: "trash.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.red.opacity(0.8))
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
            }
            .disabled(viewModel.transactions.isEmpty)
            
            // ğŸ“Š Lista de TransaÃ§Ãµes
            List(viewModel.transactions) { transaction in
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Text("R$ \(transaction.amount, specifier: "%.2f")")
                            .font(.headline)
                        Spacer()
                        if transaction.isDeleted {
                            Text("ğŸ·ï¸ DELETED")
                                .font(.caption)
                                .foregroundColor(.red)
                                .padding(4)
                                .background(Color.red.opacity(0.1))
                                .cornerRadius(4)
                        }
                    }
                    
                    Text(transaction.description)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    HStack {
                        VStack(alignment: .leading) {
                            Text("Created: \(transaction.createdAt, style: .time)")
                                .font(.caption2)
                            Text("Updated: \(transaction.updatedAt, style: .time)")
                                .font(.caption2)
                        }
                        
                        Spacer()
                        
                        if let deletedAt = transaction.deletedAt {
                            Text("Deleted: \(deletedAt, style: .time)")
                                .font(.caption2)
                                .foregroundColor(.red)
                        }
                    }
                    .foregroundColor(.gray)
                }
                .padding(.vertical, 4)
            }
            
            // ğŸ’¬ Mensagem de Feedback
            if let message = viewModel.message {
                Text(message)
                    .font(.caption)
                    .foregroundColor(.green)
                    .padding()
                    .background(Color.green.opacity(0.1))
                    .cornerRadius(8)
            }
        }
        .navigationTitle("CRUD Demo")
        .padding()
    }
}

// MARK: - CRUDDemoViewModel
@MainActor
class CRUDDemoViewModel: ObservableObject {
    @Published var transactions: [Transaction] = []
    @Published var message: String?
    @Published var showDeleted: Bool = false  // âœ¨ Toggle para mostrar deletados
    
    private let service = TransactionService()
    private let userId = "demo-user"
    /*private var userId: String {
        service.getCurrentUserId()
    }*/
    
    // â• CRIAR NOVA TRANSAÃ‡ÃƒO
    func createTransaction() async {
        let transaction = Transaction(
            amount: Double.random(in: 10...200),
            description: "Demo Transaction \(Int.random(in: 1...999))",
            type: .expense,
            userId: userId
        )
        
        do {
            let id = try await service.createTransaction(transaction, for: userId)
            message = "âœ… Criado: \(id)"
            await loadTransactions()
        } catch {
            message = "âŒ Erro: \(error.localizedDescription)"
        }
    }
    
    // ğŸ“‹ CARREGAR LISTA (com ou sem deletados)
    func loadTransactions() async {
        do {
            if showDeleted {
                // Mostra TODOS incluindo deletados
                transactions = try await service.getAllTransactionsIncludingDeleted(
                    userId: userId,
                    limit: 50
                )
                message = "âœ… Carregado: \(transactions.count) transaÃ§Ãµes (incluindo deletadas)"
            } else {
                // Mostra sÃ³ ativas (padrÃ£o)
                transactions = try await service.getUserTransactions(
                    userId: userId,
                    limit: 50
                )
                message = "âœ… Carregado: \(transactions.count) transaÃ§Ãµes ativas"
            }
        } catch {
            message = "âŒ Erro: \(error.localizedDescription)"
        }
    }
    
    // ğŸ”„ TOGGLE MOSTRAR DELETADOS
    func toggleShowDeleted() async {
        showDeleted.toggle()
        await loadTransactions()
    }
    
    // âœï¸ ATUALIZAR PRIMEIRA
    func updateFirstTransaction() async {
        guard var first = transactions.first else {
            message = "âŒ Nenhuma transaÃ§Ã£o para atualizar"
            return
        }
        
        first.amount = Double.random(in: 10...200)
        
        do {
            try await service.updateTransaction(first)
            message = "âœ… Atualizado com sucesso"
            await loadTransactions()
        } catch {
            message = "âŒ Erro: \(error.localizedDescription)"
        }
    }
    
    // ğŸ·ï¸ SOFT DELETE
    func softDeleteFirst() async {
        guard let first = transactions.first, let id = first.id else {
            message = "âŒ Nenhuma transaÃ§Ã£o para deletar"
            return
        }
        
        do {
            try await service.deleteTransaction(
                transactionId: id,
                userId: userId,
                soft: true
            )
            message = "âœ… Soft delete realizado"
            await loadTransactions()
        } catch {
            message = "âŒ Erro: \(error.localizedDescription)"
        }
    }
    
    // ğŸ—‘ï¸ HARD DELETE
    func hardDeleteFirst() async {
        guard let first = transactions.first, let id = first.id else {
            message = "âŒ Nenhuma transaÃ§Ã£o para deletar"
            return
        }
        
        do {
            try await service.deleteTransaction(
                transactionId: id,
                userId: userId,
                soft: false
            )
            message = "âœ… Hard delete realizado"
            await loadTransactions()
        } catch {
            message = "âŒ Erro: \(error.localizedDescription)"
        }
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 17: RealtimeDemoViewModel.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI
import FirebaseFirestore

/*
 ğŸ­ VIEWMODEL PARA DEMONSTRAÃ‡ÃƒO DE TEMPO REAL
 
 Gerencia estado e lÃ³gica da tela de demonstraÃ§Ã£o.
 Implementa padrÃ£o MVVM (Model-View-ViewModel).
 
 Responsabilidades:
 - Iniciar/parar listeners
 - Gerenciar estado da UI (@Published)
 - Cleanup adequado (deinit)
 - ConversÃ£o de erros para mensagens
 
 NÃƒO faz:
 - RenderizaÃ§Ã£o (responsabilidade da View)
 - LÃ³gica de negÃ³cio (responsabilidade do Service)
 */
@MainActor
class RealtimeDemoViewModel: ObservableObject {
    
    // MARK: - Published Properties
    
    /*
     @Published: Quando estes valores mudam, SwiftUI re-renderiza a View automaticamente.
     
     Ã‰ o "contrato" entre ViewModel e View:
     - ViewModel atualiza @Published
     - View observa mudanÃ§as
     - SwiftUI re-desenha automaticamente
     
     @MainActor garante que TUDO desta classe executa na main thread (UI-safe).
     */
    @Published var transactions: [Transaction] = []
    @Published var isListening = false
    @Published var message: String?
    
    // MARK: - Private Properties
    
    private let service = TransactionService()
    private let userId = "demo-user"
    /*private var userId: String {
        service.getCurrentUserId()
    }*/
    
    /*
     âš ï¸ CRÃTICO: Guardar ListenerRegistration para poder remover depois!
     
     Sem guardar = NÃ£o consegue parar listener = Memory leak!
     
     `nonisolated(unsafe)` significa:
     - **nonisolated**: "pode ser acessado de qualquer thread"
     - **unsafe**: "eu garanto que Ã© seguro fazer isso"
     
     Ao usarmos o **nonisolated(unsafe)** dizemos que esta property NÃƒO estÃ¡ isolada ao MainActor. Pode ser acessada de qualquer contexto (incluindo deinit) sem passar pelo mecanismo de sincronizaÃ§Ã£o do actor. EU garanto que isso Ã© seguro porque:

     1. Firebase SDK Ã© thread-safe
     2. OperaÃ§Ãµes sÃ£o simples (atribuir/remover)
     3. Property Ã© privada e controlada
     */
    nonisolated(unsafe) private var listener: ListenerRegistration?
    
    // MARK: - Public Methods
    
    /*
     â–¶ï¸ INICIAR LISTENER
     
     ComeÃ§a a observar mudanÃ§as em tempo real.
     */
    func startListening() {
        // ğŸ›¡ï¸ Validar: nÃ£o iniciar se jÃ¡ estÃ¡ escutando
        guard !isListening else {
            message = "âš ï¸ JÃ¡ estÃ¡ escutando!"
            print("âš ï¸ Tentativa de iniciar listener duplicado - ignorado")
            return
        }
        
        print("ğŸ§ ViewModel: Iniciando listener...")
        message = "ğŸ”„ Iniciando listener..."
        
        // ğŸ‘‚ Iniciar listener do service
        /*
         [weak self]: Evita retain cycle (referÃªncia circular).
         
         Sem [weak self]:
         - Listener â†’ retÃ©m closure
         - Closure â†’ retÃ©m self (ViewModel)
         - ViewModel â†’ retÃ©m listener
         - CÃ­rculo vicioso = Memory leak!
         
         Com [weak self]:
         - Closure nÃ£o retÃ©m ViewModel fortemente
         - Quando View desaparece, ViewModel pode ser destruÃ­do
         - deinit executa e remove listener
         
         Ã‰ como ter airbag E cinto:
         - Ideal Ã© usar cinto (stopListening manual)
         - Mas airbag (deinit) salva se esquecer!
         */
        listener = service.startListeningToUserTransactions(
            userId: userId,
            limit: 50,
            onUpdate: { [weak self] transactions in
                // ğŸ¯ Dados atualizados!
                print("ğŸ¯ ViewModel: Recebeu \(transactions.count) transaÃ§Ãµes")
                self?.transactions = transactions
                self?.isListening = true
                self?.message = "âœ… \(transactions.count) transaÃ§Ãµes em tempo real"
            },
            onError: { [weak self] error in
                // ğŸš¨ Erro ocorreu!
                print("âŒ ViewModel: Erro recebido - \(error.localizedDescription)")
                self?.isListening = false
                self?.message = "âŒ Erro: \(error.localizedDescription)"
            }
        )
        
        print("âœ… ViewModel: Listener iniciado com sucesso")
    }
    
    /*
     â¸ï¸ PARAR LISTENER
     
     Para de observar mudanÃ§as e libera recursos.
     */
    func stopListening() {
        print("ğŸ›‘ ViewModel: Parando listener...")
        
        cleanupListener()      // Faz cleanup
        
        isListening = false // Atualiza a UI
        message = "ğŸ›‘ Listener parado"  // Feedback
        
        print("âœ… ViewModel: Listener parado com sucesso")
    }
    
    // âœ… MÃ‰TODO PRIVADO: Cleanup puro (usado pelo deinit)
    nonisolated private func cleanupListener() {
        listener?.remove()
        listener = nil
    }
    
    // MARK: - Lifecycle
    
    /*
     ğŸ§¹ DESTRUTOR (CRÃTICO PARA CLEANUP!)
     
     Executado automaticamente quando ViewModel Ã© destruÃ­do.
     
     Por que Ã© crÃ­tico:
     - View pode desaparecer sem chamar stopListening()
     - ViewModel seria destruÃ­do mas listener continuaria rodando
     - deinit Ã© nossa REDE DE SEGURANÃ‡A
     - Garante que listener sempre serÃ¡ removido
     
     Ã‰ como ter um finally {} automÃ¡tico!
     
     CenÃ¡rios onde deinit salva:
     1. UsuÃ¡rio fecha app bruscamente
     2. NavegaÃ§Ã£o rÃ¡pida entre telas
     3. Erro/crash na view
     4. Memory warning (iOS libera VMs nÃ£o visÃ­veis)
     
     Sem deinit adequado:
     - Listener continua rodando para sempre
     - Consome CPU e rede constantemente
     - MemÃ³ria nunca Ã© liberada
     - App fica progressivamente mais lento
     - iOS pode matar app por excesso de memÃ³ria
     */
    deinit {
        print("ğŸ§¹ ViewModel: deinit chamado - removendo listener")
        cleanupListener()
        print("âœ… ViewModel: Cleanup completo")
    }
    

    // MARK: - ğŸ’° Computed Properties (âœ¨ NOVO NA PARTE 7)
    /*
    âš ï¸ IMPORTANTE: CÃ¡lculos baseados nas Ãºltimas 50 transaÃ§Ãµes
 
    Por questÃµes de performance, o listener carrega apenas as 50
    transaÃ§Ãµes mais recentes. Portanto, estes valores sÃ£o APROXIMADOS
    e representam apenas a atividade recente, nÃ£o o histÃ³rico completo.
 
    Em um app de produÃ§Ã£o, vocÃª deveria:
    1. Usar agregaÃ§Ã£o do Firestore para totais reais
    2. Ter uma collection separada com totais consolidados
    3. Ou calcular totais no backend
    */
    
    /// Saldo das Ãºltimas 50 transaÃ§Ãµes
    var totalBalance: Double {
        transactions.reduce(0.0) { $0 + $1.amount }
    }
    
    /// Total de receitas (valores positivos)
    var totalIncome: Double {
        transactions
            .filter { $0.amount > 0 }
            .reduce(0.0) { $0 + $1.amount }
    }
    
    /// Total de despesas (Ãºltimas 50 transaÃ§Ãµes)
    var totalExpenses: Double {
        abs(transactions
            .filter { $0.amount < 0 }
            .reduce(0.0) { $0 + $1.amount })
    }
    
    /// Quantidade de transaÃ§Ãµes (Ãºltimas 50 transaÃ§Ãµes)
    var transactionCount: Int {
        transactions.count
    }
    
    /// MÃ©dia de gastos (Ãºltimas 50 transaÃ§Ãµes)
    var averageExpense: Double {
        let expenses = transactions.filter { $0.amount < 0 }
        guard !expenses.isEmpty else { return 0 }
        return abs(expenses.reduce(0.0) { $0 + $1.amount }) / Double(expenses.count)
    }
    
    // MARK: - ğŸ¨ Formatadores (âœ¨ NOVO NA PARTE 7)
    
    /// Formata valor para moeda brasileira
    func formatCurrency(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
    }
    
    /// Formata data para formato brasileiro
    func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: date)
    }
    
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 18: BalanceHeaderView.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI

/// CabeÃ§alho com saldo total e estatÃ­sticas de receitas/gastos
struct BalanceHeaderView: View {
    let totalBalance: Double
    let totalIncome: Double
    let totalExpenses: Double
    let formatter: (Double) -> String
    
    var body: some View {
        VStack(spacing: 16) {
            // SALDO PRINCIPAL
            VStack(spacing: 4) {
                Text("Saldo Total")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                Text(formatter(totalBalance))
                    .font(.system(size: 36, weight: .bold, design: .rounded))
                    .foregroundColor(totalBalance >= 0 ? .green : .red)
                    .animation(.easeInOut(duration: 0.3), value: totalBalance)
            }
            
            // RECEITAS E GASTOS
            HStack(spacing: 20) {
                // Receitas
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Image(systemName: "arrow.up.circle.fill")
                            .foregroundColor(.green)
                        Text("Receitas")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    Text(formatter(totalIncome))
                        .font(.headline)
                        .foregroundColor(.green)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                
                Divider()
                    .frame(height: 40)
                
                // Gastos
                VStack(alignment: .trailing, spacing: 4) {
                    HStack {
                        Text("Gastos")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Image(systemName: "arrow.down.circle.fill")
                            .foregroundColor(.red)
                    }
                    Text(formatter(totalExpenses))
                        .font(.headline)
                        .foregroundColor(.red)
                }
                .frame(maxWidth: .infinity, alignment: .trailing)
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(.ultraThinMaterial)
                .shadow(color: .black.opacity(0.1), radius: 10, y: 5)
        )
    }
}

#Preview {
    BalanceHeaderView(
        totalBalance: 2500.50,
        totalIncome: 5000,
        totalExpenses: 2499.50,
        formatter: { value in
            let formatter = NumberFormatter()
            formatter.numberStyle = .currency
            formatter.locale = Locale(identifier: "pt_BR")
            return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
        }
    )
    .padding()
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 19: StatisticsCardView.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI

/*
ğŸ“Š STATISTICS CARD - Card de EstatÃ­stica Individual

Exibe uma mÃ©trica especÃ­fica com Ã­cone e valor.
ReutilizÃ¡vel para diferentes tipos de estatÃ­sticas.
*/
struct StatisticsCardView: View {
    let icon: String
    let title: String
    let value: String
    let color: Color

    var body: some View {
        HStack(spacing: 12) {
            // ÃCONE
            Image(systemName: icon)
                .font(.system(size: 24))
                .foregroundColor(color)
                .frame(width: 40, height: 40)
                .background(color.opacity(0.2))
                .clipShape(Circle())

            // TEXTO
            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.caption)
                    .foregroundColor(.secondary)

                Text(value)
                    .font(.system(size: 16, weight: .semibold, design: .rounded))
                    .foregroundColor(.primary)
            }

            Spacer()
        }
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
        )
    }
}

#Preview {
    VStack(spacing: 12) {
        StatisticsCardView(
            icon: "chart.bar.fill",
            title: "TransaÃ§Ãµes",
            value: "24",
            color: .blue
        )

        StatisticsCardView(
            icon: "chart.line.uptrend.xyaxis",
            title: "MÃ©dia de Gastos",
            value: "R$ 185,50",
            color: .orange
        )
    }
    .padding()
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 20: StatisticsCardView.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI

/*
ğŸ’³ TRANSACTION CARD - Card de TransaÃ§Ã£o Individual

Exibe uma transaÃ§Ã£o com:
- Indicador visual (cor/Ã­cone)
- DescriÃ§Ã£o e data
- Valor formatado
- Design moderno e responsivo
*/
struct TransactionCardView: View {
    let transaction: Transaction
    let formatter: (Double) -> String
    let dateFormatter: (Date) -> String

    private var isIncome: Bool {
        transaction.amount > 0
    }

    var body: some View {
        HStack(spacing: 12) {
            // INDICADOR VISUAL
            Circle()
                .fill(isIncome ? Color.green : Color.red)
                .frame(width: 8, height: 8)

            // INFORMAÃ‡Ã•ES
            VStack(alignment: .leading, spacing: 4) {
                Text(transaction.description)
                    .font(.system(size: 15, weight: .medium))
                    .foregroundColor(.primary)

                Text(dateFormatter(transaction.date))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Spacer()

            // VALOR
            Text(formatter(abs(transaction.amount)))
                .font(.system(size: 16, weight: .semibold, design: .rounded))
                .foregroundColor(isIncome ? .green : .red)
        }
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
        )
    }
}

// Preview comentado pois Transaction precisa ser Hashable



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ ARQUIVO 21: StatisticsCardView.swift (MANTIDO DE PARTES ANTERIORES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import SwiftUI

/*
ğŸ“­ EMPTY STATE - Estado Vazio Informativo

Exibido quando nÃ£o hÃ¡ transaÃ§Ãµes.
Importante para UX - evita tela em branco confusa.
*/
struct EmptyStateView: View {
    var body: some View {
        VStack(spacing: 20) {
            // ÃCONE GRANDE
            Image(systemName: "chart.bar.doc.horizontal")
                .font(.system(size: 60))
                .foregroundColor(.secondary.opacity(0.5))

            // TEXTO PRINCIPAL
            Text("Nenhuma TransaÃ§Ã£o Ainda")
                .font(.title2)
                .fontWeight(.semibold)
                .foregroundColor(.primary)

            // TEXTO SECUNDÃRIO
            Text("Adicione sua primeira transaÃ§Ã£o\npara ver estatÃ­sticas em tempo real!")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)

            // BOTÃƒO DE AÃ‡ÃƒO
            Button(action: {}) {
                HStack {
                    Image(systemName: "plus.circle.fill")
                    Text("Adicionar TransaÃ§Ã£o")
                }
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal, 24)
                .padding(.vertical, 12)
                .background(Color.blue)
                .cornerRadius(12)
            }
            .padding(.top, 8)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

#Preview {
    EmptyStateView()
}


