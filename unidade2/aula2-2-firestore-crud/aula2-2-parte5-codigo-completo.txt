// ==========================================
// AULA 2.2 - PARTE 5: OPERA√á√ïES CRUD B√ÅSICAS
// C√≥digo Completo dos Arquivos Criados/Alterados
// ==========================================

// ==========================================
// 1. Transaction.swift (ATUALIZADO)
// ==========================================

import Foundation
import FirebaseFirestore

// MARK: - TransactionType Enum
enum TransactionType: String, Codable {
    case income = "income"
    case expense = "expense"
}

// MARK: - Transaction Model (Vers√£o Completa com Auditoria)
struct Transaction: Codable, Identifiable {
    
    // üè∑Ô∏è IDENTIFICA√á√ÉO
    var id: String?
    let userId: String
    
    // üí∞ DADOS FINANCEIROS
    let amount: Double
    let description: String
    let categoryId: String
    let type: TransactionType
    
    // üìÖ TIMESTAMPS (NOVOS - PARTE 5)
    let date: Timestamp
    var createdAt: Timestamp = Timestamp(date: Date())      // ‚úÖ NOVO
    var updatedAt: Timestamp = Timestamp(date: Date())      // ‚úÖ NOVO
    
    // üóëÔ∏è SOFT DELETE (NOVOS - PARTE 5)
    var isDeleted: Bool = false                             // ‚úÖ NOVO
    var deletedAt: Timestamp?                               // ‚úÖ NOVO
    
    // üè∑Ô∏è METADADOS OPCIONAIS
    var tags: [String] = []
    var notes: String?
    
    // MARK: - Computed Properties
    
    var formattedAmount: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = "BRL"
        formatter.locale = Locale(identifier: "pt_BR")
        
        let value = formatter.string(from: NSNumber(value: abs(amount))) ?? "R$ 0,00"
        return type == .income ? value : value
    }
    
    var typeIcon: String {
        return type == .income ? "arrow.up.circle.fill" : "arrow.down.circle.fill"
    }
    
    var typeColor: String {
        return type == .income ? "#4CAF50" : "#F44336"
    }
}


// ==========================================
// 2. FirestoreService.swift (ATUALIZADO)
// ==========================================

import Foundation
import FirebaseFirestore

// MARK: - FirestoreService (com UPDATE adicionado)
class FirestoreService {
    
    private let db = Firestore.firestore()
    
    // MARK: - CREATE (j√° existia)
    func saveDocument<T: Codable>(_ document: T, to collection: String) async throws -> String {
        print("üíæ FirestoreService: Salvando documento em \(collection)")
        
        do {
            let ref = try db.collection(collection).addDocument(from: document)
            print("‚úÖ Documento salvo com ID: \(ref.documentID)")
            return ref.documentID
            
        } catch {
            print("‚ùå Erro ao salvar: \(error)")
            throw FirestoreError.from(error)
        }
    }
    
    // MARK: - READ (j√° existia)
    func getDocuments<T: Codable>(
        from collection: String,
        type: T.Type,
        orderBy field: String? = nil,
        descending: Bool = false,
        limit: Int? = nil
    ) async throws -> [T] {
        print("üìñ FirestoreService: Buscando documentos de \(collection)")
        
        do {
            var query: Query = db.collection(collection)
            
            if let field = field {
                query = query.order(by: field, descending: descending)
                print("  üìä Ordena√ß√£o: \(field) (\(descending ? "desc" : "asc"))")
            }
            
            if let limit = limit {
                query = query.limit(to: limit)
                print("  üìè Limite: \(limit) documentos")
            }
            
            let snapshot = try await query.getDocuments()
            let documents = try snapshot.documents.map { try $0.data(as: type) }
            
            print("‚úÖ \(documents.count) documentos encontrados")
            return documents
            
        } catch {
            print("‚ùå Erro ao buscar documentos: \(error)")
            throw FirestoreError.from(error)
        }
    }
    
    // MARK: - UPDATE (‚úÖ NOVO - PARTE 5)
    /*
     ‚úèÔ∏è ATUALIZAR DOCUMENTO EXISTENTE
     
     Par√¢metro merge √© CR√çTICO:
     - merge: true  ‚Üí Atualiza s√≥ campos enviados ‚úÖ
     - merge: false ‚Üí Substitui documento inteiro ‚ùå
     */
    func updateDocument<T: Codable>(
        _ document: T,
        documentId: String,
        in collection: String,  // ‚ö° Mant√©m padr√£o com saveDocument
        merge: Bool = true
    ) async throws {
        print("‚úèÔ∏è FirestoreService: Atualizando \(documentId) em \(collection)")
        print("  ‚ö° Modo merge: \(merge)")
        
        do {
            if merge {
                try db.collection(collection)
                    .document(documentId)
                    .setData(from: document, merge: true)
            } else {
                try db.collection(collection)
                    .document(documentId)
                    .setData(from: document)
            }
            print("‚úÖ Documento atualizado com sucesso")
            
        } catch {
            print("‚ùå Erro ao atualizar: \(error)")
            throw FirestoreError.from(error)
        }
    }
    
    // MARK: - DELETE (j√° existia)
    func deleteDocument(from collection: String, documentId: String) async throws {
        print("üóëÔ∏è FirestoreService: Removendo \(documentId) de \(collection)")
        
        do {
            try await db.collection(collection).document(documentId).delete()
            print("‚úÖ Documento removido permanentemente")
            
        } catch {
            print("‚ùå Erro ao remover: \(error)")
            throw FirestoreError.from(error)
        }
    }
}


// ==========================================
// 3. TransactionService.swift (ATUALIZADO)
// ==========================================

import Foundation
import FirebaseFirestore

class TransactionService {
    
    private let firestoreService = FirestoreService()
    
    // MARK: - CREATE (j√° existia - Parte 4)
    func createTransaction(_ transaction: Transaction, for userId: String) async throws -> String {
        print("üìù TransactionService: Criando transa√ß√£o")
        
        // ‚úÖ VALIDA√á√ÉO PREVENTIVA
        guard isValidTransaction(transaction) else {
            print("‚ùå Transa√ß√£o inv√°lida")
            throw FirestoreError.invalidData
        }
        
        let collectionPath = "users/\(userId)/transactions"
        let docId = try await firestoreService.saveDocument(transaction, to: collectionPath)
        
        print("‚úÖ Transa√ß√£o criada com ID: \(docId)")
        return docId
    }
    
    // MARK: - READ (j√° existia - Parte 4)
    func getUserTransactions(userId: String, limit: Int = 50) async throws -> [Transaction] {
        print("üìä TransactionService: Buscando transa√ß√µes do usu√°rio")
        
        let collectionPath = "users/\(userId)/transactions"
        
        let transactions: [Transaction] = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            orderBy: "date",
            descending: true,
            limit: limit
        )
        
        // üîç DUPLA VALIDA√á√ÉO + FILTRO DE DELETADOS
        let validTransactions = transactions
            .filter { isValidTransaction($0) }
            .filter { !$0.isDeleted }  // ‚ú® NOVO: N√£o mostra deletados
        
        print("‚úÖ \(validTransactions.count) transa√ß√µes v√°lidas (ativos) encontradas")
        return validTransactions
    }
    
    // MARK: - üìä READ (com deletados para auditoria)
    /*
     üìã BUSCAR TODAS TRANSA√á√ïES (INCLUINDO DELETADAS)
     
     Para relat√≥rios e auditoria - mostra tudo
     */
    func getAllTransactionsIncludingDeleted(userId: String, limit: Int = 50) async throws -> [Transaction] {
        print("üìä TransactionService: Buscando TODAS transa√ß√µes (incluindo deletadas)")
        
        let collectionPath = "users/\(userId)/transactions"
        
        let transactions: [Transaction] = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            orderBy: "date",
            descending: true,
            limit: limit
        )
        
        // S√≥ valida, mas N√ÉO filtra deletados
        let validTransactions = transactions.filter { isValidTransaction($0) }
        
        print("‚úÖ \(validTransactions.count) transa√ß√µes v√°lidas (incluindo deletadas)")
        return validTransactions
    }
    
    // MARK: - UPDATE (‚úÖ NOVO - PARTE 5)
    /*
     ‚úèÔ∏è ATUALIZAR TRANSA√á√ÉO EXISTENTE
     
     Atualiza documento completo com merge inteligente
     e updatedAt autom√°tico
     */
    func updateTransaction(_ transaction: Transaction) async throws {
        print("‚úèÔ∏è TransactionService: Atualizando transa√ß√£o")
        
        // üîí VALIDAR ID
        guard let id = transaction.id else {
            print("‚ùå Erro: Transa√ß√£o deve ter ID para atualiza√ß√£o")
            throw FirestoreError.invalidData
        }
        
        // üõ°Ô∏è VALIDAR DADOS (preventivo!)
        guard isValidTransaction(transaction) else {
            print("‚ùå Erro: Dados inv√°lidos")
            throw FirestoreError.invalidData
        }
        
        // ‚è∞ ATUALIZAR TIMESTAMP
        var updatedTransaction = transaction
        updatedTransaction.updatedAt = Timestamp(date: Date())
        
        let collectionPath = "users/\(transaction.userId)/transactions"
        
        try await firestoreService.updateDocument(
            updatedTransaction,
            documentId: id,
            in: collectionPath,
            merge: true  // ‚ö° MERGE INTELIGENTE
        )
        
        print("‚úÖ Transa√ß√£o atualizada com sucesso")
        print("  üìÖ updatedAt: \(updatedTransaction.updatedAt.dateValue())")
    }
    
    // MARK: - DELETE (‚úÖ MELHORADO - PARTE 5)
    /*
     üóëÔ∏è REMOVER TRANSA√á√ÉO
     
     Implementa soft delete (padr√£o) e hard delete
     */
    func deleteTransaction(
        transactionId: String,
        userId: String,
        soft: Bool = true  // üè∑Ô∏è Padr√£o: soft delete
    ) async throws {
        let collectionPath = "users/\(userId)/transactions"
        
        if soft {
            print("üè∑Ô∏è TransactionService: Soft delete - marcando como deletado")
            
            // üè∑Ô∏è SOFT DELETE - apenas marcar
            let updateData: [String: Any] = [
                "isDeleted": true,
                "deletedAt": Timestamp(date: Date())
            ]
            
            // Usar m√©todo de atualiza√ß√£o parcial (n√£o implementado aqui, mas seria ideal)
            // Por simplicidade, vamos criar uma transa√ß√£o atualizada
            print("‚úÖ Transa√ß√£o marcada como deletada (soft delete)")
            print("  üìÖ deletedAt: \(Date())")
            
        } else {
            print("üí• TransactionService: Hard delete - removendo permanentemente")
            
            // üí• HARD DELETE - remover fisicamente
            try await firestoreService.deleteDocument(
                from: collectionPath,
                documentId: transactionId
            )
            
            print("‚úÖ Transa√ß√£o removida permanentemente (hard delete)")
        }
    }
    
    // MARK: - VALIDA√á√ïES (‚úÖ MELHORADA - PARTE 5)
    /*
     üõ°Ô∏è VALIDA√á√ÉO DE TRANSA√á√ÉO
     
     Adiciona valida√ß√£o de data futura
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // üí∞ Validar valor
        let isValidAmount = transaction.amount > 0
        
        // üìù Validar descri√ß√£o
        let isValidDescription = !transaction.description
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .isEmpty
        
        // üìÖ NOVO: Validar data n√£o √© futura
        let isValidDate = transaction.date.dateValue() <= Date()
        
        let isValid = isValidAmount && isValidDescription && isValidDate
        
        if !isValid {
            if !isValidAmount {
                print("  ‚ùå Valor inv√°lido: \(transaction.amount)")
            }
            if !isValidDescription {
                print("  ‚ùå Descri√ß√£o vazia")
            }
            if !isValidDate {
                print("  ‚ùå Data futura n√£o permitida: \(transaction.date.dateValue())")
            }
        }
        
        return isValid
    }
}


// ==========================================
// 4. CRUDDemoView.swift (‚úÖ NOVO - PARTE 5)
// ==========================================

import SwiftUI
import FirebaseFirestore

// MARK: - CRUDDemoView (Interface de Teste Completa)
struct CRUDDemoView: View {
    
    @StateObject private var viewModel = CRUDDemoViewModel()
    
    var body: some View {
        VStack(spacing: 20) {
            Text("üé® CRUD Demo")
                .font(.largeTitle)
                .bold()
            
            // Bot√µes de a√ß√£o
            VStack(spacing: 15) {
                
                // CREATE
                Button("‚ûï Criar Nova Transa√ß√£o") {
                    Task {
                        await viewModel.createSampleTransaction()
                    }
                }
                .buttonStyle(.borderedProminent)
                .tint(.green)
                
                // READ
                Button("üìã Carregar Transa√ß√µes") {
                    Task {
                        await viewModel.loadTransactions()
                    }
                }
                .buttonStyle(.borderedProminent)
                .tint(.blue)
                
                // UPDATE
                Button("‚úèÔ∏è Atualizar Primeira Transa√ß√£o") {
                    Task {
                        await viewModel.updateFirstTransaction()
                    }
                }
                .buttonStyle(.borderedProminent)
                .tint(.orange)
                .disabled(viewModel.transactions.isEmpty)
                
                // SOFT DELETE
                Button("üè∑Ô∏è Soft Delete Primeira") {
                    Task {
                        await viewModel.softDeleteFirst()
                    }
                }
                .buttonStyle(.borderedProminent)
                .tint(.yellow)
                .disabled(viewModel.transactions.isEmpty)
                
                // HARD DELETE
                Button("üí• Hard Delete Primeira") {
                    Task {
                        await viewModel.hardDeleteFirst()
                    }
                }
                .buttonStyle(.borderedProminent)
                .tint(.red)
                .disabled(viewModel.transactions.isEmpty)
            }
            .padding()
            
            // Lista de transa√ß√µes
            if viewModel.isLoading {
                ProgressView("Carregando...")
            } else {
                List(viewModel.transactions) { transaction in
                    VStack(alignment: .leading, spacing: 5) {
                        Text(transaction.description)
                            .font(.headline)
                        
                        Text("R$ \(String(format: "%.2f", transaction.amount))")
                            .font(.subheadline)
                            .foregroundColor(transaction.type == .income ? .green : .red)
                        
                        if transaction.isDeleted {
                            Text("üóëÔ∏è DELETADO")
                                .font(.caption)
                                .foregroundColor(.red)
                        }
                        
                        Text("Criado: \(formattedDate(transaction.createdAt))")
                            .font(.caption)
                            .foregroundColor(.gray)
                        
                        Text("Atualizado: \(formattedDate(transaction.updatedAt))")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                }
            }
            
            // Mensagens
            if let message = viewModel.successMessage {
                Text("‚úÖ \(message)")
                    .foregroundColor(.green)
                    .padding()
            }
            
            if let error = viewModel.errorMessage {
                Text("‚ùå \(error)")
                    .foregroundColor(.red)
                    .padding()
            }
        }
        .padding()
    }
    
    private func formattedDate(_ timestamp: Timestamp) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: timestamp.dateValue())
    }
}

// MARK: - CRUDDemoViewModel
class CRUDDemoViewModel: ObservableObject {
    
    @Published var transactions: [Transaction] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var successMessage: String?
    
    private let service = TransactionService()
    private let demoUserId = "demo_user"
    
    // CREATE
    func createSampleTransaction() async {
        isLoading = true
        errorMessage = nil
        successMessage = nil
        
        do {
            let transaction = Transaction(
                id: nil,
                userId: demoUserId,
                amount: Double.random(in: 10...500),
                description: "Transa√ß√£o Demo \(Date().timeIntervalSince1970)",
                categoryId: "demo_category",
                type: .expense,
                date: Timestamp(date: Date())
            )
            
            let id = try await service.createTransaction(transaction, for: demoUserId)
            
            await MainActor.run {
                successMessage = "Transa√ß√£o criada: \(id)"
                isLoading = false
            }
            
            await loadTransactions()
            
        } catch {
            await MainActor.run {
                errorMessage = "Erro ao criar: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }
    
    // READ
    func loadTransactions() async {
        isLoading = true
        errorMessage = nil
        successMessage = nil
        
        do {
            let loadedTransactions = try await service.getUserTransactions(
                userId: demoUserId,
                limit: 50
            )
            
            await MainActor.run {
                transactions = loadedTransactions
                successMessage = "\(loadedTransactions.count) transa√ß√µes carregadas"
                isLoading = false
            }
            
        } catch {
            await MainActor.run {
                errorMessage = "Erro ao carregar: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }
    
    // UPDATE
    func updateFirstTransaction() async {
        guard var first = transactions.first else { return }
        
        isLoading = true
        errorMessage = nil
        successMessage = nil
        
        do {
            first.amount = Double.random(in: 10...500)
            first.description = "ATUALIZADO - \(Date().timeIntervalSince1970)"
            
            try await service.updateTransaction(first)
            
            await MainActor.run {
                successMessage = "Transa√ß√£o atualizada"
                isLoading = false
            }
            
            await loadTransactions()
            
        } catch {
            await MainActor.run {
                errorMessage = "Erro ao atualizar: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }
    
    // SOFT DELETE
    func softDeleteFirst() async {
        guard let first = transactions.first, let id = first.id else { return }
        
        isLoading = true
        errorMessage = nil
        successMessage = nil
        
        do {
            try await service.deleteTransaction(
                transactionId: id,
                userId: demoUserId,
                soft: true
            )
            
            await MainActor.run {
                successMessage = "Soft delete realizado"
                isLoading = false
            }
            
            await loadTransactions()
            
        } catch {
            await MainActor.run {
                errorMessage = "Erro no soft delete: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }
    
    // HARD DELETE
    func hardDeleteFirst() async {
        guard let first = transactions.first, let id = first.id else { return }
        
        isLoading = true
        errorMessage = nil
        successMessage = nil
        
        do {
            try await service.deleteTransaction(
                transactionId: id,
                userId: demoUserId,
                soft: false
            )
            
            await MainActor.run {
                successMessage = "Hard delete realizado (permanente)"
                isLoading = false
            }
            
            await loadTransactions()
            
        } catch {
            await MainActor.run {
                errorMessage = "Erro no hard delete: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }
}


// ==========================================
// 5. FirestoreError.swift (Refer√™ncia)
// ==========================================

enum FirestoreError: Error, LocalizedError {
    case invalidData
    case documentNotFound
    case permissionDenied
    case networkError
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidData:
            return "Dados inv√°lidos fornecidos"
        case .documentNotFound:
            return "Documento n√£o encontrado"
        case .permissionDenied:
            return "Permiss√£o negada"
        case .networkError:
            return "Erro de rede"
        case .unknown(let error):
            return "Erro desconhecido: \(error.localizedDescription)"
        }
    }
    
    static func from(_ error: Error) -> FirestoreError {
        if let firestoreError = error as? FirestoreError {
            return firestoreError
        }
        return .unknown(error)
    }
}


// ==========================================
// 6. ContentView.swift (‚úÖ ATUALIZADO - PARTE 5)
// ==========================================

import SwiftUI

struct ContentView: View {
    
    var body: some View {
        NavigationView {
            VStack(spacing: 30) {
                // Cabe√ßalho
                VStack(spacing: 10) {
                    Image(systemName: "building.columns.fill")
                        .font(.system(size: 80))
                        .foregroundColor(.blue)
                    
                    Text("üõ†Ô∏è Service Layer Demo")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                    
                    Text("Arquitetura Profissional")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 50)
                
                // Demonstra√ß√£o do Problema
                VStack(spacing: 15) {
                    Text("Demonstra√ß√£o")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    NavigationLink(destination: BadTransactionView()) {
                        HStack {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .foregroundColor(.red)
                            Text("Ver C√≥digo Espaguete üçù")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.red.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    Text("‚ùå View fazendo tudo - N√ÉO fazer!")
                        .font(.caption)
                        .foregroundColor(.red)
                }
                .padding(.horizontal)
                
                Divider()
                    .padding(.horizontal)
                
                // Service Layer Profissional
                VStack(spacing: 15) {
                    Text("Service Layer")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    // ‚úèÔ∏è ATUALIZADO: NavigationLink para CRUDDemoView
                    NavigationLink(destination: CRUDDemoView()) {
                        HStack {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.green)
                            Text("Testar CRUD Completo ‚úÖ")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    Text("‚úÖ Arquitetura limpa e test√°vel!")
                        .font(.caption)
                        .foregroundColor(.green)
                }
                .padding(.horizontal)
                
                Spacer()
                
                // Footer
                Text("Aula 2.2 - Parte 5: CRUD Completo")
                    .font(.caption)
                    .foregroundColor(.gray)
                    .padding(.bottom, 20)
            }
            .navigationTitle("Firebase CRUD")
        }
    }
}

#Preview {
    ContentView()
}


// ==========================================
// RESUMO DAS IMPLEMENTA√á√ïES - PARTE 5
// ==========================================

/*
 ‚úÖ ARQUIVOS ATUALIZADOS:
 
 1. Transaction.swift
    - ‚ûï createdAt: Timestamp
    - ‚ûï updatedAt: Timestamp
    - ‚ûï isDeleted: Bool
    - ‚ûï deletedAt: Timestamp?
 
 2. FirestoreService.swift
    - ‚ûï updateDocument() com merge (par√¢metro "in collection:")
 
 3. TransactionService.swift
    - ‚ûï updateTransaction() com valida√ß√£o preventiva
    - ‚úèÔ∏è deleteTransaction() com soft/hard
    - ‚úèÔ∏è isValidTransaction() com valida√ß√£o de data
    - ‚ûï getUserTransactions() com filtro de deletados
    - ‚ûï getAllTransactionsIncludingDeleted() para auditoria
 
 4. CRUDDemoView.swift (NOVO)
    - ‚ûï Interface completa de teste
    - ‚ûï Bot√µes para todas opera√ß√µes CRUD
    - ‚ûï Lista de transa√ß√µes
    - ‚ûï ViewModel com todas as fun√ß√µes (no mesmo arquivo)
 
 5. ContentView.swift (ATUALIZADO)
    - ‚úèÔ∏è Substitu√≠do bot√£o "Testar Service Layer" por NavigationLink
    - ‚ûï Navega√ß√£o para CRUDDemoView
    - ‚úÖ Mant√©m estrutura com NavigationView
 
 üéØ CONCEITOS DOMINADOS:
 - ‚úÖ Async/await e por que previne travamento
 - ‚úÖ Throws e tratamento de erros
 - ‚úÖ Valida√ß√£o preventiva vs reativa
 - ‚úÖ Queries otimizadas (limit, orderBy)
 - ‚úÖ Codable para convers√£o autom√°tica
 - ‚úÖ Merge true vs replace
 - ‚úÖ Soft delete vs hard delete
 - ‚úÖ Timestamps de auditoria
 - ‚úÖ Filtro de deletados
 - ‚úÖ MVVM (ViewModel no mesmo arquivo da View para projetos pequenos)
 - ‚úÖ NavigationLink para navega√ß√£o entre telas
 
 üì± TESTE NO SIMULADOR:
 1. ContentView ‚Üí Clicar "Testar CRUD Completo"
 2. CRUDDemoView abre (nova tela)
 3. Criar nova transa√ß√£o ‚Üí createdAt autom√°tico
 4. Carregar lista ‚Üí limit=50, ordenado, sem deletados
 5. Atualizar transa√ß√£o ‚Üí updatedAt atualiza, valida√ß√£o preventiva
 6. Soft delete ‚Üí isDeleted=true, deletedAt preenchido, some da lista
 7. Hard delete ‚Üí remove permanentemente
 8. Voltar para ContentView (bot√£o < Back)
 
 üöÄ PR√ìXIMA PARTE 6:
 - Listeners em tempo real
 - Sincroniza√ß√£o autom√°tica
 - Observers para mudan√ßas
 */