// ==========================================
// AULA 2.2 - PARTE 5: OPERA√á√ïES CRUD B√ÅSICAS
// C√≥digo Completo dos Arquivos Criados/Alterados
// ‚úÖ VERS√ÉO CORRIGIDA - com m√©todo from() no FirestoreError
// ==========================================

// ==========================================
// 1. Transaction.swift (‚úÖ ATUALIZADO - Parte 4 + Timestamps)
// ==========================================

import Foundation
import FirebaseFirestore

// MARK: - üí∞ Modelo de Transa√ß√£o (Vers√£o com Auditoria)
struct Transaction: Identifiable, Codable {
    @DocumentID var id: String?
    var amount: Double
    var description: String
    var type: TransactionType
    var date: Date
    var userId: String
    
    // ‚ú® NOVOS CAMPOS - PARTE 5: Timestamps de Auditoria
    var createdAt: Date = Date()        // Quando foi criado
    var updatedAt: Date = Date()        // √öltima atualiza√ß√£o
    var isDeleted: Bool = false         // Soft delete
    var deletedAt: Date?                // Quando foi deletado
    
    enum TransactionType: String, Codable, CaseIterable {
        case income = "income"
        case expense = "expense"
        
        var displayName: String {
            switch self {
            case .income: return "Receita"
            case .expense: return "Despesa"
            }
        }
        
        var icon: String {
            switch self {
            case .income: return "arrow.down.circle.fill"
            case .expense: return "arrow.up.circle.fill"
            }
        }
    }
    
    // Inicializador para criar novas transa√ß√µes
    init(amount: Double, description: String, type: TransactionType, userId: String) {
        self.amount = amount
        self.description = description
        self.type = type
        self.date = Date()
        self.userId = userId
        // createdAt, updatedAt, isDeleted j√° t√™m valores padr√£o
    }
}


// ==========================================
// 2. FirestoreError.swift (‚úÖ CORRIGIDO - com m√©todo from() completo)
// ==========================================

import Foundation

// MARK: - üõ°Ô∏è FirestoreError (CORRIGIDO)
enum FirestoreError: Error, LocalizedError {
    case invalidData
    case documentNotFound
    case permissionDenied
    case networkError
    case quotaExceeded
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidData:
            return "Dados inv√°lidos fornecidos"
        case .documentNotFound:
            return "Documento n√£o encontrado"
        case .permissionDenied:
            return "Permiss√£o negada"
        case .networkError:
            return "Erro de rede"
        case .quotaExceeded:
            return "Limite de uso excedido"
        case .unknown(let error):
            return "Erro desconhecido: \(error.localizedDescription)"
        }
    }
    
    // üéØ CONVERTER ERROS DO FIREBASE (‚úÖ M√âTODO CORRIGIDO)
    /*
     Mapeia c√≥digos de erro do Firebase para nossos erros customizados.
     
     C√≥digos do Firebase:
     - 7  = permissionDenied (acesso negado)
     - 5  = notFound (documento n√£o existe)
     - 14 = unavailable (sem conex√£o)
     - 8  = resourceExhausted (limite excedido)
     
     Benef√≠cios:
     - Mensagens claras e espec√≠ficas
     - Tratamento diferenciado por tipo
     - Logs mais informativos
     - UX melhorada
     */
    static func from(_ error: Error) -> FirestoreError {
        // Converte Error gen√©rico para NSError para acessar c√≥digo
        let nsError = error as NSError
        
        switch nsError.code {
        case 7:  // FirestoreErrorCode.permissionDenied
            return .permissionDenied
        case 5:  // FirestoreErrorCode.notFound
            return .documentNotFound
        case 14: // FirestoreErrorCode.unavailable
            return .networkError(error)
        case 8:  // FirestoreErrorCode.resourceExhausted
            return .quotaExceeded
        default:
            return .unknown(error)
        }
    }
}


// ==========================================
// 3. FirestoreService.swift (‚úÖ ATUALIZADO - com updateDocument)
// ==========================================

import Foundation
import FirebaseFirestore

// MARK: - FirestoreService (com UPDATE adicionado)
class FirestoreService {
    
    private let db = Firestore.firestore()
    
    // MARK: - CREATE (j√° existia)
    func saveDocument<T: Codable>(_ document: T, to collection: String) async throws -> String {
        print("üíæ FirestoreService: Salvando documento em \(collection)")
        
        do {
            let ref = try db.collection(collection).addDocument(from: document)
            print("‚úÖ Documento salvo com ID: \(ref.documentID)")
            return ref.documentID
            
        } catch {
            print("‚ùå Erro ao salvar: \(error)")
            throw FirestoreError.from(error)
        }
    }
    
    // MARK: - READ (j√° existia)
    func getDocuments<T: Codable>(
        from collection: String,
        type: T.Type,
        orderBy field: String? = nil,
        descending: Bool = false,
        limit: Int? = nil
    ) async throws -> [T] {
        print("üìñ FirestoreService: Buscando documentos de \(collection)")
        
        do {
            var query: Query = db.collection(collection)
            
            if let field = field {
                query = query.order(by: field, descending: descending)
                print("  üìä Ordena√ß√£o: \(field) (\(descending ? "desc" : "asc"))")
            }
            
            if let limit = limit {
                query = query.limit(to: limit)
                print("  üìè Limite: \(limit) documentos")
            }
            
            let snapshot = try await query.getDocuments()
            let documents = try snapshot.documents.map { try $0.data(as: type) }
            
            print("‚úÖ \(documents.count) documentos encontrados")
            return documents
            
        } catch {
            print("‚ùå Erro ao buscar documentos: \(error)")
            throw FirestoreError.from(error)
        }
    }
    
    // MARK: - READ Single Document (helper para soft delete)
    func getDocument<T: Codable>(
        _ documentId: String,
        from collection: String,
        as type: T.Type
    ) async throws -> T {
        print("üìñ FirestoreService: Buscando documento \(documentId)")
        
        do {
            let docRef = db.collection(collection).document(documentId)
            let document = try await docRef.getDocument(as: type)
            
            print("‚úÖ Documento encontrado")
            return document
            
        } catch {
            print("‚ùå Erro ao buscar documento: \(error)")
            throw FirestoreError.from(error)
        }
    }
    
    // MARK: - UPDATE (‚úÖ NOVO - PARTE 5)
    /*
     ‚úèÔ∏è ATUALIZAR DOCUMENTO EXISTENTE
     
     Par√¢metro merge √© CR√çTICO:
     - merge: true  ‚Üí Atualiza s√≥ campos enviados ‚úÖ
     - merge: false ‚Üí Substitui documento inteiro ‚ùå
     
     ‚ö†Ô∏è IMPORTANTE: Usa FirestoreError.from() para converter erros
     */
    func updateDocument<T: Codable>(
        _ document: T,
        documentId: String,
        in collection: String,
        merge: Bool = true
    ) async throws {
        print("‚úèÔ∏è FirestoreService: Atualizando \(documentId) em \(collection)")
        print("  ‚ö° Modo merge: \(merge)")
        
        do {
            if merge {
                try db.collection(collection)
                    .document(documentId)
                    .setData(from: document, merge: true)
            } else {
                try db.collection(collection)
                    .document(documentId)
                    .setData(from: document)
            }
            print("‚úÖ Documento atualizado com sucesso")
            
        } catch {
            print("‚ùå Erro ao atualizar: \(error)")
            throw FirestoreError.from(error)  // ‚úÖ Agora funciona!
        }
    }
    
    // MARK: - DELETE (j√° existia)
    func deleteDocument(from collection: String, documentId: String) async throws {
        print("üóëÔ∏è FirestoreService: Removendo \(documentId) de \(collection)")
        
        do {
            try await db.collection(collection).document(documentId).delete()
            print("‚úÖ Documento removido permanentemente")
            
        } catch {
            print("‚ùå Erro ao remover: \(error)")
            throw FirestoreError.from(error)
        }
    }
}


// ==========================================
// 4. TransactionService.swift (‚úÖ ATUALIZADO - UPDATE e DELETE melhorado)
// ==========================================

import Foundation

// MARK: - TransactionService
class TransactionService {
    private let firestoreService = FirestoreService()
    
    // MARK: - CREATE (j√° existia - da Parte 4)
    func createTransaction(
        _ transaction: Transaction,
        for userId: String
    ) async throws -> String {
        print("üìù TransactionService: Criando transa√ß√£o")
        
        // üõ°Ô∏è VALIDA√á√ÉO PREVENTIVA
        guard isValidTransaction(transaction) else {
            print("‚ùå Valida√ß√£o falhou")
            throw FirestoreError.invalidData
        }
        
        let collectionPath = "users/\(userId)/transactions"
        let docId = try await firestoreService.saveDocument(
            transaction,
            to: collectionPath
        )
        
        print("‚úÖ Transa√ß√£o criada com ID: \(docId)")
        return docId
    }
    
    // MARK: - READ (‚úÖ ATUALIZADO - filtro de deletados)
    /*
     üìñ BUSCAR TRANSA√á√ïES DO USU√ÅRIO
     
     Por padr√£o, N√ÉO retorna transa√ß√µes deletadas (soft delete).
     Para incluir deletadas, use getAllTransactionsIncludingDeleted()
     */
    func getUserTransactions(
        userId: String,
        limit: Int = 50
    ) async throws -> [Transaction] {
        print("üìñ TransactionService: Buscando transa√ß√µes do usu√°rio \(userId)")
        print("  üìè Limite: \(limit)")
        
        let collectionPath = "users/\(userId)/transactions"
        
        let transactions: [Transaction] = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            limit: limit,
            orderBy: "date",
            descending: true
        )
        
        // Dupla valida√ß√£o + filtro de deletados
        let activeTransactions = transactions
            .filter { isValidTransaction($0) }
            .filter { !$0.isDeleted }  // ‚ú® NOVO: N√£o mostra deletados
        
        print("‚úÖ \(activeTransactions.count) transa√ß√µes ativas retornadas")
        return activeTransactions
    }
    
    // MARK: - READ Including Deleted (‚úÖ NOVO - PARTE 5)
    /*
     üìñ BUSCAR TODAS AS TRANSA√á√ïES (INCLUINDO DELETADAS)
     
     √ötil para:
     - Administra√ß√£o e auditoria
     - Relat√≥rios completos
     - Recupera√ß√£o de dados
     - An√°lise de hist√≥rico completo
     */
    func getAllTransactionsIncludingDeleted(
        userId: String,
        limit: Int = 50
    ) async throws -> [Transaction] {
        print("üìñ TransactionService: Buscando TODAS transa√ß√µes (incluindo deletadas)")
        print("  üìè Limite: \(limit)")
        
        let collectionPath = "users/\(userId)/transactions"
        
        let transactions: [Transaction] = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            limit: limit,
            orderBy: "date",
            descending: true
        )
        
        // S√≥ valida, mas N√ÉO filtra deletados
        let validTransactions = transactions.filter { isValidTransaction($0) }
        
        print("‚úÖ \(validTransactions.count) transa√ß√µes totais (incluindo deletadas)")
        return validTransactions
    }
    
    // MARK: - UPDATE (‚úÖ NOVO - PARTE 5)
    /*
     ‚úèÔ∏è ATUALIZAR TRANSA√á√ÉO EXISTENTE
     
     Atualiza documento completo com merge inteligente
     e updatedAt autom√°tico
     */
    func updateTransaction(_ transaction: Transaction) async throws {
        print("‚úèÔ∏è TransactionService: Atualizando transa√ß√£o")
        
        // üîí VALIDAR ID
        guard let id = transaction.id else {
            print("‚ùå Erro: Transa√ß√£o deve ter ID para atualiza√ß√£o")
            throw FirestoreError.invalidData
        }
        
        // üõ°Ô∏è VALIDAR DADOS (preventivo!)
        guard isValidTransaction(transaction) else {
            print("‚ùå Erro: Dados inv√°lidos")
            throw FirestoreError.invalidData
        }
        
        // ‚è∞ ATUALIZAR TIMESTAMP
        var updatedTransaction = transaction
        updatedTransaction.updatedAt = Date()
        
        let collectionPath = "users/\(transaction.userId)/transactions"
        
        try await firestoreService.updateDocument(
            updatedTransaction,
            documentId: id,
            in: collectionPath,
            merge: true  // ‚ö° MERGE INTELIGENTE - preserva campos n√£o enviados
        )
        
        print("‚úÖ Transa√ß√£o atualizada com sucesso")
        print("  üìÖ updatedAt: \(updatedTransaction.updatedAt)")
    }
    
    // MARK: - DELETE (‚úÖ MELHORADO - PARTE 5)
    /*
     üóëÔ∏è REMOVER TRANSA√á√ÉO
     
     Implementa soft delete (padr√£o) e hard delete
     
     Soft delete:
     - Marca isDeleted = true
     - Preserva dados para auditoria
     - Compliance e recupera√ß√£o
     
     Hard delete:
     - Remove permanentemente
     - GDPR "direito ao esquecimento"
     - Dados tempor√°rios
     */
    func deleteTransaction(
        transactionId: String,
        userId: String,
        soft: Bool = true  // üè∑Ô∏è Padr√£o: soft delete
    ) async throws {
        let collectionPath = "users/\(userId)/transactions"
        
        if soft {
            // üè∑Ô∏è SOFT DELETE: marca isDeleted
            print("üè∑Ô∏è TransactionService: Soft delete de \(transactionId)")
            
            // Buscar documento atual
            var transaction = try await firestoreService.getDocument(
                transactionId,
                from: collectionPath,
                as: Transaction.self
            )
            
            // Marcar como deletado
            transaction.isDeleted = true
            transaction.deletedAt = Date()
            
            // Atualizar com as flags
            try await firestoreService.updateDocument(
                transaction,
                documentId: transactionId,
                in: collectionPath
            )
            
            print("‚úÖ Soft delete conclu√≠do")
            print("  üìÖ deletedAt: \(transaction.deletedAt!)")
            
        } else {
            // üóëÔ∏è HARD DELETE: remove permanentemente
            print("üóëÔ∏è TransactionService: Hard delete de \(transactionId)")
            
            try await firestoreService.deleteDocument(
                from: collectionPath,
                documentId: transactionId
            )
            
            print("‚úÖ Hard delete conclu√≠do - documento removido permanentemente")
        }
    }
    
    // MARK: - VALIDA√á√ÉO (‚úÖ MELHORADA - PARTE 5)
    /*
     üõ°Ô∏è VALIDA√á√ÉO ROBUSTA
     
     Regras de neg√≥cio espec√≠ficas do dom√≠nio financeiro
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // 1. Amount n√£o pode ser zero
        guard transaction.amount > 0 else {
            print("‚ùå Valor inv√°lido: \(transaction.amount)")
            return false
        }
        
        // 2. Description n√£o pode estar vazia
        guard !transaction.description.isEmpty else {
            print("‚ùå Valida√ß√£o falhou: descri√ß√£o vazia")
            return false
        }
        
        // 3. Data n√£o pode ser futura (nova valida√ß√£o!)
        guard transaction.date <= Date() else {
            print("‚ùå Data futura: \(transaction.date)")
            return false
        }
        
        return true
    }
}


// ==========================================
// 5. CRUDDemoView.swift (‚úÖ NOVO - PARTE 5)
// ==========================================

import SwiftUI

// MARK: - CRUDDemoView
struct CRUDDemoView: View {
    @StateObject private var viewModel = CRUDDemoViewModel()
    
    var body: some View {
        VStack(spacing: 20) {
            // üîù Cabe√ßalho
            Text("Teste CRUD Completo")
                .font(.title2)
                .fontWeight(.bold)
                .padding(.top)
            
            // ‚ûï Bot√£o Criar
            Button(action: {
                Task { await viewModel.createTransaction() }
            }) {
                Label("Criar Nova Transa√ß√£o", systemImage: "plus.circle.fill")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            
            // üìã Bot√£o Carregar + Toggle Deletados
            HStack(spacing: 15) {
                Button(action: {
                    Task { await viewModel.loadTransactions() }
                }) {
                    Label("Carregar Lista", systemImage: "list.bullet")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.green.opacity(0.8))
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                
                // ‚ú® TOGGLE MOSTRAR DELETADOS
                Button(action: {
                    Task { await viewModel.toggleShowDeleted() }
                }) {
                    Image(systemName: viewModel.showDeleted ? "eye.fill" : "eye.slash.fill")
                        .font(.title2)
                        .foregroundColor(viewModel.showDeleted ? .orange : .gray)
                        .padding()
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(10)
                }
            }
            
            // ‚úèÔ∏è Bot√£o Atualizar
            Button(action: {
                Task { await viewModel.updateFirstTransaction() }
            }) {
                Label("Atualizar Primeira", systemImage: "pencil.circle.fill")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.orange.opacity(0.8))
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            .disabled(viewModel.transactions.isEmpty)
            
            // üè∑Ô∏èüóëÔ∏è Bot√µes Delete
            HStack(spacing: 15) {
                Button(action: {
                    Task { await viewModel.softDeleteFirst() }
                }) {
                    Label("Soft Delete", systemImage: "tag.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.yellow.opacity(0.8))
                        .foregroundColor(.black)
                        .cornerRadius(10)
                }
                
                Button(action: {
                    Task { await viewModel.hardDeleteFirst() }
                }) {
                    Label("Hard Delete", systemImage: "trash.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.red.opacity(0.8))
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
            }
            .disabled(viewModel.transactions.isEmpty)
            
            // üìä Lista de Transa√ß√µes
            List(viewModel.transactions) { transaction in
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Text("R$ \(transaction.amount, specifier: "%.2f")")
                            .font(.headline)
                        Spacer()
                        if transaction.isDeleted {
                            Text("üè∑Ô∏è DELETED")
                                .font(.caption)
                                .foregroundColor(.red)
                                .padding(4)
                                .background(Color.red.opacity(0.1))
                                .cornerRadius(4)
                        }
                    }
                    
                    Text(transaction.description)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    HStack {
                        VStack(alignment: .leading) {
                            Text("Created: \(transaction.createdAt, style: .time)")
                                .font(.caption2)
                            Text("Updated: \(transaction.updatedAt, style: .time)")
                                .font(.caption2)
                        }
                        
                        Spacer()
                        
                        if let deletedAt = transaction.deletedAt {
                            Text("Deleted: \(deletedAt, style: .time)")
                                .font(.caption2)
                                .foregroundColor(.red)
                        }
                    }
                    .foregroundColor(.gray)
                }
                .padding(.vertical, 4)
            }
            
            // üí¨ Mensagem de Feedback
            if let message = viewModel.message {
                Text(message)
                    .font(.caption)
                    .foregroundColor(.green)
                    .padding()
                    .background(Color.green.opacity(0.1))
                    .cornerRadius(8)
            }
        }
        .navigationTitle("CRUD Demo")
        .padding()
    }
}

// MARK: - CRUDDemoViewModel
@MainActor
class CRUDDemoViewModel: ObservableObject {
    @Published var transactions: [Transaction] = []
    @Published var message: String?
    @Published var showDeleted: Bool = false  // ‚ú® Toggle para mostrar deletados
    
    private let service = TransactionService()
    private let userId = "demo-user"
    
    // ‚ûï CRIAR NOVA TRANSA√á√ÉO
    func createTransaction() async {
        let transaction = Transaction(
            amount: Double.random(in: 10...200),
            description: "Demo Transaction \(Int.random(in: 1...999))",
            type: .expense,
            userId: userId
        )
        
        do {
            let id = try await service.createTransaction(transaction, for: userId)
            message = "‚úÖ Criado: \(id)"
            await loadTransactions()
        } catch {
            message = "‚ùå Erro: \(error.localizedDescription)"
        }
    }
    
    // üìã CARREGAR LISTA (com ou sem deletados)
    func loadTransactions() async {
        do {
            if showDeleted {
                // Mostra TODOS incluindo deletados
                transactions = try await service.getAllTransactionsIncludingDeleted(
                    userId: userId,
                    limit: 50
                )
                message = "‚úÖ Carregado: \(transactions.count) transa√ß√µes (incluindo deletadas)"
            } else {
                // Mostra s√≥ ativas (padr√£o)
                transactions = try await service.getUserTransactions(
                    userId: userId,
                    limit: 50
                )
                message = "‚úÖ Carregado: \(transactions.count) transa√ß√µes ativas"
            }
        } catch {
            message = "‚ùå Erro: \(error.localizedDescription)"
        }
    }
    
    // üîÑ TOGGLE MOSTRAR DELETADOS
    func toggleShowDeleted() async {
        showDeleted.toggle()
        await loadTransactions()
    }
    
    // ‚úèÔ∏è ATUALIZAR PRIMEIRA
    func updateFirstTransaction() async {
        guard var first = transactions.first else {
            message = "‚ùå Nenhuma transa√ß√£o para atualizar"
            return
        }
        
        first.amount = Double.random(in: 10...200)
        
        do {
            try await service.updateTransaction(first)
            message = "‚úÖ Atualizado com sucesso"
            await loadTransactions()
        } catch {
            message = "‚ùå Erro: \(error.localizedDescription)"
        }
    }
    
    // üè∑Ô∏è SOFT DELETE
    func softDeleteFirst() async {
        guard let first = transactions.first, let id = first.id else {
            message = "‚ùå Nenhuma transa√ß√£o para deletar"
            return
        }
        
        do {
            try await service.deleteTransaction(
                transactionId: id,
                userId: userId,
                soft: true
            )
            message = "‚úÖ Soft delete realizado"
            await loadTransactions()
        } catch {
            message = "‚ùå Erro: \(error.localizedDescription)"
        }
    }
    
    // üóëÔ∏è HARD DELETE
    func hardDeleteFirst() async {
        guard let first = transactions.first, let id = first.id else {
            message = "‚ùå Nenhuma transa√ß√£o para deletar"
            return
        }
        
        do {
            try await service.deleteTransaction(
                transactionId: id,
                userId: userId,
                soft: false
            )
            message = "‚úÖ Hard delete realizado"
            await loadTransactions()
        } catch {
            message = "‚ùå Erro: \(error.localizedDescription)"
        }
    }
}

// ==========================================
// 6. ContentView.swift (‚úÖ ATUALIZADO - PARTE 5)
// ==========================================

import SwiftUI

struct ContentView: View {
    // ========================================================================
    // ‚ùå REMOVER: Estados do teste inline (n√£o precisa mais)
    // Comentado para refer√™ncia:
    // @State private var isTestingService = false
    // @State private var serviceTestResult: String = ""
    // ========================================================================
    
    var body: some View {
        NavigationView {
            VStack(spacing: 30) {
                // Cabe√ßalho
                VStack(spacing: 10) {
                    Image(systemName: "building.columns.fill")
                        .font(.system(size: 80))
                        .foregroundColor(.blue)
                    
                    Text("üèõÔ∏è Service Layer Demo")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                    
                    Text("Arquitetura Profissional")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 50)
                
                // ‚úÖ MANTER: Demonstra√ß√£o do Problema
                VStack(spacing: 15) {
                    Text("Demonstra√ß√£o")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    NavigationLink(destination: BadTransactionView()) {
                        HStack {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .foregroundColor(.red)
                            Text("Ver C√≥digo Espaguete üçù")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.red.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    Text("‚ùå View fazendo tudo - N√ÉO fazer!")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .padding(.horizontal)
                
                Divider()
                    .padding(.horizontal)
                
                // ================================================================
                // ‚úÖ MODIFICADO PARA PARTE 5: NavigationLink para CRUDDemoView
                // ANTES: Tinha bot√£o que executava testServiceLayer() inline
                // AGORA: NavigationLink para tela dedicada de testes
                // ================================================================
                VStack(spacing: 15) {
                    Text("CRUD Completo Implementado! üéâ")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    // ‚úÖ SUBSTITUIR o bot√£o antigo por este NavigationLink:
                    NavigationLink(destination: CRUDDemoView()) {
                        HStack {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.green)
                            Text("Testar CRUD Completo ‚úÖ")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    Text("‚úÖ CREATE + READ + UPDATE + DELETE + Auditoria")
                        .font(.caption)
                        .foregroundColor(.green)
                }
                .padding(.horizontal)
                
                Spacer()
                
                // ‚úÖ MANTER: Informa√ß√£o de ambiente
                Text(EnvironmentConfig.environmentName)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.bottom)
            }
            .navigationBarHidden(true)
        }
        // ‚úÖ MANTER: Task com valida√ß√£o
        .task {
            // üß™ Valida√ß√£o autom√°tica da configura√ß√£o
            print("üß™ Executando valida√ß√£o autom√°tica...")
            let result = await ConfigurationValidator.validateSetup()
            
            if result.isValid {
                print("üéâ App pronto para uso!")
            } else {
                print("‚ö†Ô∏è \(result.message)")
            }
        }
    }
    
    // ========================================================================
    // ‚ùå REMOVER ESTE M√âTODO COMPLETO (testServiceLayer)
    // Agora usamos CRUDDemoView com interface dedicada
    // ========================================================================
    /*
    // M√âTODO ANTIGO - N√ÉO USAR MAIS
    private func testServiceLayer() {
        // ... c√≥digo removido ...
    }
    */
}

#Preview {
    ContentView()
}

// ==========================================
// üìù RESUMO DAS MUDAN√áAS DA PARTE 5
// ==========================================

/*
‚úÖ CORRE√á√ïES E MELHORIAS:

1. FirestoreError.swift:
   - ‚úÖ Adicionado m√©todo from() completo
   - ‚úÖ Mapeia c√≥digos Firebase (7,5,14,8) para erros espec√≠ficos
   - ‚úÖ Mensagens mais claras e profissionais

2. Transaction.swift:
   - ‚úÖ Campos de auditoria: createdAt, updatedAt, isDeleted, deletedAt
   - ‚úÖ Compliance e rastreamento profissional

3. FirestoreService.swift:
   - ‚úÖ M√©todo updateDocument() com merge inteligente
   - ‚úÖ getDocument() helper para soft delete
   - ‚úÖ Todos m√©todos usando FirestoreError.from()

4. TransactionService.swift:
   - ‚úÖ updateTransaction() completo
   - ‚úÖ deleteTransaction() melhorado (soft + hard)
   - ‚úÖ Valida√ß√£o robusta com data futura

5. CRUDDemoView.swift:
   - ‚úÖ Interface completa para testes
   - ‚úÖ ViewModel com @Published
   - ‚úÖ Todos bot√µes CRUD funcionais

6. ContentView.swift:
   - ‚úÖ NavigationLink para CRUDDemoView
   - ‚úÖ Substituiu bot√£o de teste inline

üéØ RESULTADO FINAL:
CRUD profissional + auditoria completa + error handling robusto!
*/
