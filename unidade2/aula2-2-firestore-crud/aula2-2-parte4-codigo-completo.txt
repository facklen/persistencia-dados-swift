================================================================================
AULA 2.2 - PARTE 4: SERVICE LAYER PROFISSIONAL
C√ìDIGO COMPLETO DE TODOS OS ARQUIVOS
================================================================================

Este arquivo cont√©m o c√≥digo completo de todos os arquivos modificados ou
criados nesta aula. Use como refer√™ncia durante a implementa√ß√£o.


================================================================================


================================================================================
A. Transaction.swift 
================================================================================
Status: CRIAR na pasta Models/
Linhas totais: ~40 linhas
Usado por: TransactionService e BadTransactionView
================================================================================

//
//  Transaction.swift
//  FinancasApp
//
//  Created by Di√≥genes Reis on 29/09/25.
//

import Foundation
import FirebaseFirestore

// MARK: - üí∞ Modelo de Transa√ß√£o
struct Transaction: Identifiable, Codable {
    @DocumentID var id: String?
    var amount: Double
    var description: String
    var type: TransactionType
    var date: Date
    var userId: String
    
    enum TransactionType: String, Codable, CaseIterable {
        case income = "income"
        case expense = "expense"
        
        var displayName: String {
            switch self {
            case .income: return "Receita"
            case .expense: return "Despesa"
            }
        }
        
        var icon: String {
            switch self {
            case .income: return "arrow.down.circle.fill"
            case .expense: return "arrow.up.circle.fill"
            }
        }
    }
    
    // Inicializador para criar novas transa√ß√µes
    init(amount: Double, description: String, type: TransactionType, userId: String) {
        self.amount = amount
        self.description = description
        self.type = type
        self.date = Date()
        self.userId = userId
    }
}


================================================================================
B. BadTransactionView.swift 
================================================================================
Status: CRIAR ANTES DA AULA na pasta Views/
Linhas totais: ~95 linhas
Usado para: Demonstrar c√≥digo espaguete (problema)
================================================================================

//
//  BadTransactionView.swift
//  FinancasApp
//
//  Created by Di√≥genes Reis on 29/09/25.
//

import SwiftUI
import FirebaseFirestore

// ‚ùå EXEMPLO DE C√ìDIGO RUIM - N√ÉO USAR EM PRODU√á√ÉO
// Este c√≥digo serve apenas para demonstra√ß√£o do problema

struct BadTransactionView: View {
    @State private var transactions: [Transaction] = []
    @State private var isLoading = false
    @State private var errorMessage: String?
    
    var body: some View {
        NavigationView {
            ZStack {
                if isLoading {
                    ProgressView("Carregando...")
                } else if let error = errorMessage {
                    VStack(spacing: 20) {
                        Image(systemName: "exclamationmark.triangle")
                            .font(.system(size: 60))
                            .foregroundColor(.red)
                        Text("Erro ao carregar")
                            .font(.headline)
                        Text(error)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding()
                } else if transactions.isEmpty {
                    VStack(spacing: 20) {
                        Image(systemName: "doc.text")
                            .font(.system(size: 60))
                            .foregroundColor(.gray)
                        Text("Nenhuma transa√ß√£o")
                            .font(.headline)
                        Text("Adicione transa√ß√µes no Firebase Console")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding()
                } else {
                    List(transactions) { transaction in
                        HStack {
                            // √çcone
                            Image(systemName: transaction.type.icon)
                                .foregroundColor(transaction.type == .income ? .green : .red)
                                .font(.title2)
                            
                            // Descri√ß√£o
                            VStack(alignment: .leading, spacing: 4) {
                                Text(transaction.description)
                                    .font(.headline)
                                Text(transaction.date, style: .date)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            // Valor
                            Text("R$ \(transaction.amount, specifier: "%.2f")")
                                .font(.headline)
                                .foregroundColor(transaction.type == .income ? .green : .red)
                        }
                        .padding(.vertical, 4)
                    }
                }
            }
            .navigationTitle("C√≥digo Espaguete üçù")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: loadTransactions) {
                        Image(systemName: "arrow.clockwise")
                    }
                }
            }
            .onAppear {
                loadTransactions()
            }
        }
    }
    
    // ‚ùå PROBLEMA: View fazendo TUDO
    // - Conecta diretamente no Firestore
    // - Faz parsing manual
    // - Trata erros de forma b√°sica
    // - L√≥gica de neg√≥cio misturada com UI
    // - Imposs√≠vel de testar isoladamente
    // - C√≥digo duplicado em outras telas
    private func loadTransactions() {
        isLoading = true
        errorMessage = nil
        
        let db = Firestore.firestore()
        
        // üò± Conex√£o direta sem abstra√ß√£o
        db.collection("transactions").getDocuments { snapshot, error in
            DispatchQueue.main.async {
                self.isLoading = false
                
                if let error = error {
                    // ‚ùå Error handling b√°sico
                    self.errorMessage = "Erro: \(error.localizedDescription)"
                    print("‚ùå Erro ao carregar: \(error)")
                    return
                }
                
                guard let documents = snapshot?.documents else {
                    self.errorMessage = "Nenhum documento encontrado"
                    return
                }
                
                // üò± Parsing manual propenso a erros
                var loadedTransactions: [Transaction] = []
                for document in documents {
                    do {
                        let transaction = try document.data(as: Transaction.self)
                        loadedTransactions.append(transaction)
                    } catch {
                        print("‚ùå Erro ao decodificar: \(error)")
                    }
                }
                
                self.transactions = loadedTransactions
                print("üìä Transa√ß√µes carregadas: \(loadedTransactions.count)")
            }
        }
    }
}

#Preview {
    BadTransactionView()
}


================================================================================
0. ORGANIZA√á√ÉO DA ESTRUTURA (IN√çCIO DA AULA - 0:00 a 0:45)
================================================================================
A√á√ÉO: Criar Groups no Xcode e organizar arquivos existentes
Tempo: 45 segundos
================================================================================

üìÅ ESTRUTURA DE GROUPS A CRIAR NO XCODE:

FinancasApp/
‚îú‚îÄ‚îÄ App/                          ‚Üê NEW GROUP
‚îÇ   ‚îî‚îÄ‚îÄ FinancasAppApp.swift     ‚Üê MOVER PARA C√Å
‚îú‚îÄ‚îÄ Views/                        ‚Üê NEW GROUP
‚îÇ   ‚îú‚îÄ‚îÄ ContentView.swift        ‚Üê MOVER PARA C√Å
‚îÇ   ‚îî‚îÄ‚îÄ BadTransactionView.swift ‚Üê MOVER PARA C√Å
‚îú‚îÄ‚îÄ Models/                       ‚Üê NEW GROUP
‚îÇ   ‚îî‚îÄ‚îÄ Transaction.swift        ‚Üê J√Å EST√Å AQUI
‚îú‚îÄ‚îÄ Services/                     ‚Üê NEW GROUP (vazio - criar arquivos na aula)
‚îú‚îÄ‚îÄ Configuration/                ‚Üê NEW GROUP
‚îÇ   ‚îú‚îÄ‚îÄ EnvironmentConfig.swift        ‚Üê MOVER PARA C√Å
‚îÇ   ‚îú‚îÄ‚îÄ FirestoreConfiguration.swift   ‚Üê MOVER PARA C√Å
‚îÇ   ‚îî‚îÄ‚îÄ ConfigurationValidator.swift   ‚Üê MOVER PARA C√Å
‚îú‚îÄ‚îÄ Managers/                     ‚Üê NEW GROUP
‚îÇ   ‚îî‚îÄ‚îÄ FirebaseTestManager.swift ‚Üê MOVER PARA C√Å
‚îî‚îÄ‚îÄ Resources/                    ‚Üê NEW GROUP
    ‚îú‚îÄ‚îÄ Assets.xcassets          ‚Üê MOVER PARA C√Å
    ‚îî‚îÄ‚îÄ GoogleService-Info.plist ‚Üê MOVER PARA C√Å

PASSOS NO XCODE:
1. Right-click no grupo FinancasApp
2. New Group ‚Üí "App" (repetir para todas as pastas acima)
3. Arrastar arquivos para os grupos corretos
4. Resultado: Projeto organizado profissionalmente!

üí° RAZ√ÉO PEDAG√ìGICA:
Demonstra que arquitetura profissional come√ßa com organiza√ß√£o visual.
Coerente com a mensagem da aula sobre "Service Layer Profissional".


================================================================================
1. FirestoreError.swift - NOVO
================================================================================
Status: CRIAR NOVO ARQUIVO na pasta Services/
Linhas totais: ~45 linhas
Timing: 1:30 - 2:15 (45 segundos de implementa√ß√£o)
================================================================================

//
//  FirestoreError.swift
//  FinancasApp
//
//  Created by [Seu Nome] on [Data]
//

import Foundation

// MARK: - üõ°Ô∏è Sistema de Erros Profissional
/*
 üìù ERROS CUSTOMIZADOS DO FIRESTORE
 
 üéØ Por que criar erros customizados:
 ‚Ä¢ Mensagens espec√≠ficas e amig√°veis ao usu√°rio
 ‚Ä¢ Diferentes tipos de tratamento por tipo de erro
 ‚Ä¢ Logs detalhados para debugging
 ‚Ä¢ Facilita identifica√ß√£o de problemas em produ√ß√£o
 */
enum FirestoreError: LocalizedError {
    case documentNotFound
    case invalidData
    case networkError(Error)
    case permissionDenied
    case quotaExceeded
    case unknown(Error)
    
    // üì± MENSAGENS AMIG√ÅVEIS PARA O USU√ÅRIO
    var errorDescription: String? {
        switch self {
        case .documentNotFound:
            return "Documento n√£o encontrado. Verifique se os dados existem."
        case .invalidData:
            return "Dados inv√°lidos. Formato n√£o suportado."
        case .networkError(let error):
            return "Erro de conex√£o: \(error.localizedDescription)"
        case .permissionDenied:
            return "Acesso negado. Verifique suas permiss√µes."
        case .quotaExceeded:
            return "Limite de uso excedido. Tente novamente mais tarde."
        case .unknown(let error):
            return "Erro desconhecido: \(error.localizedDescription)"
        }
    }
}


================================================================================
2. FirestoreService.swift - NOVO
================================================================================
Status: CRIAR NOVO ARQUIVO na pasta Services/
Linhas totais: ~120 linhas
Timing: 2:15 - 3:30 (75 segundos de implementa√ß√£o)
================================================================================

//
//  FirestoreService.swift
//  FinancasApp
//
//  Created by [Seu Nome] on [Data]
//

import Foundation
import FirebaseFirestore

// MARK: - üîß Service Gen√©rico do Firestore
/*
 üìù SERVICE LAYER BASE - REUTILIZ√ÅVEL
 
 üéØ Este service √© gen√©rico e funciona com QUALQUER modelo Codable:
 ‚Ä¢ Transaction, User, Product, Category, etc.
 ‚Ä¢ Uma base s√≥lida para todos os outros services
 ‚Ä¢ Centraliza comunica√ß√£o com Firestore
 ‚Ä¢ Facilita manuten√ß√£o e testes
 */
class FirestoreService {
    private let db = Firestore.firestore()
    
    // MARK: - üì• Buscar Documentos (Generic GET)
    /*
     üìù M√âTODO GEN√âRICO DE LEITURA
     
     üéØ Funcionalidades:
     ‚Ä¢ Funciona com qualquer tipo Codable
     ‚Ä¢ Suporta ordena√ß√£o e limite
     ‚Ä¢ Logs educativos para debugging
     ‚Ä¢ Error handling robusto
     
     üí° Exemplo de uso:
     let transactions = try await getDocuments(
         from: "transactions",
         type: Transaction.self,
         limit: 10,
         orderBy: "date",
         descending: true
     )
     */
    func getDocuments<T: Codable>(
        from collection: String,
        type: T.Type,
        limit: Int? = nil,
        orderBy field: String? = nil,
        descending: Bool = false
    ) async throws -> [T] {
        print("üîç FirestoreService: Buscando documentos de \(collection)")
        
        do {
            var query: Query = db.collection(collection)
            
            // üìä Aplicar ordena√ß√£o se especificada
            if let orderField = field {
                query = query.order(by: orderField, descending: descending)
                print("   üìä Ordenando por: \(orderField) (desc: \(descending))")
            }
            
            // üî¢ Aplicar limite se especificado
            if let limitCount = limit {
                query = query.limit(to: limitCount)
                print("   üî¢ Limite: \(limitCount) documentos")
            }
            
            // üåê Executar query
            let snapshot = try await query.getDocuments()
            
            // üîÑ Decodificar documentos
            let documents = snapshot.documents.compactMap { document -> T? in
                do {
                    let decoded = try document.data(as: type)
                    print("   ‚úÖ Documento decodificado: \(document.documentID)")
                    return decoded
                } catch {
                    print("   ‚ùå Erro ao decodificar documento \(document.documentID): \(error)")
                    return nil
                }
            }
            
            print("üìä Total de documentos carregados: \(documents.count)")
            return documents
            
        } catch {
            print("üí• Erro no FirestoreService: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    // MARK: - üíæ Salvar Documento (Generic CREATE/UPDATE)
    /*
     üìù M√âTODO GEN√âRICO DE ESCRITA
     
     üéØ Funcionalidades:
     ‚Ä¢ Cria ou atualiza documentos
     ‚Ä¢ Auto-gera ID se n√£o fornecido
     ‚Ä¢ Retorna o ID do documento salvo
     ‚Ä¢ Logs para tracking
     */
    func saveDocument<T: Codable>(
        _ document: T,
        to collection: String,
        documentId: String? = nil
    ) async throws -> String {
        print("üíæ FirestoreService: Salvando documento em \(collection)")
        
        do {
            let ref: DocumentReference
            
            if let id = documentId {
                ref = db.collection(collection).document(id)
                print("   üìù Atualizando documento existente: \(id)")
            } else {
                ref = db.collection(collection).document()
                print("   ‚ú® Criando novo documento com ID: \(ref.documentID)")
            }
            
            try ref.setData(from: document)
            
            print("‚úÖ Documento salvo com sucesso: \(ref.documentID)")
            return ref.documentID
            
        } catch {
            print("üí• Erro ao salvar documento: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    // MARK: - üóëÔ∏è Deletar Documento (Generic DELETE)
    func deleteDocument(from collection: String, documentId: String) async throws {
        print("üóëÔ∏è FirestoreService: Deletando documento \(documentId)")
        
        do {
            try await db.collection(collection).document(documentId).delete()
            print("‚úÖ Documento deletado com sucesso")
        } catch {
            print("üí• Erro ao deletar: \(error)")
            throw mapFirebaseError(error)
        }
    }
    
    // MARK: - üîÑ Mapeamento de Erros
    /*
     üìù TRADU√á√ÉO DE ERROS DO FIREBASE
     
     üéØ Converte erros gen√©ricos do Firebase em erros espec√≠ficos
     do nosso app, com mensagens amig√°veis.
     */
    private func mapFirebaseError(_ error: Error) -> FirestoreError {
        if let firestoreError = error as? FirestoreErrorCode {
            switch firestoreError.code {
            case .notFound:
                return .documentNotFound
            case .permissionDenied:
                return .permissionDenied
            case .resourceExhausted:
                return .quotaExceeded
            default:
                return .networkError(error)
            }
        }
        return .unknown(error)
    }
}


================================================================================
3. TransactionService.swift - NOVO
================================================================================
Status: CRIAR NOVO ARQUIVO na pasta Services/
Linhas totais: ~90 linhas
Timing: 3:30 - 4:30 (60 segundos de implementa√ß√£o)
================================================================================

//
//  TransactionService.swift
//  FinancasApp
//
//  Created by [Seu Nome] on [Data]
//

import Foundation

// MARK: - üíº Service Especializado de Transa√ß√µes
/*
 üìù SERVICE COM REGRAS DE NEG√ìCIO ESPEC√çFICAS
 
 üéØ Por que criar service especializado:
 ‚Ä¢ Encapsula regras de neg√≥cio de transa√ß√µes
 ‚Ä¢ Usa o FirestoreService gen√©rico como base
 ‚Ä¢ Valida dados antes de salvar
 ‚Ä¢ Aplica filtros de neg√≥cio ao carregar
 ‚Ä¢ Facilita testes de l√≥gica de neg√≥cio
 */
class TransactionService {
    private let firestoreService = FirestoreService()
    
    // MARK: - ‚ûï Criar Transa√ß√£o
    /*
     üìù CRIA√á√ÉO COM VALIDA√á√ÉO DE NEG√ìCIO
     
     üéØ Processo:
     1. Valida dados da transa√ß√£o
     2. Adiciona userId √† transa√ß√£o
     3. Salva no path hier√°rquico correto
     4. Retorna ID do documento criado
     */
    func createTransaction(_ transaction: Transaction, for userId: String) async throws -> String {
        print("üè≠ TransactionService: Criando transa√ß√£o para user \(userId)")
        
        // ‚úÖ VALIDA√á√ïES DE NEG√ìCIO
        guard isValidTransaction(transaction) else {
            print("‚ùå Transa√ß√£o inv√°lida - n√£o passou nas valida√ß√µes")
            throw FirestoreError.invalidData
        }
        
        // üìù Adicionar userId √† transa√ß√£o
        var transactionWithUser = transaction
        transactionWithUser.userId = userId
        
        // üóÇÔ∏è Path hier√°rquico NoSQL
        let collectionPath = "users/\(userId)/transactions"
        print("   üìÇ Path: \(collectionPath)")
        
        // üíæ Delegar para service gen√©rico
        let documentId = try await firestoreService.saveDocument(
            transactionWithUser,
            to: collectionPath
        )
        
        print("‚úÖ Transa√ß√£o criada com sucesso: \(documentId)")
        return documentId
    }
    
    // MARK: - üìã Buscar Transa√ß√µes do Usu√°rio
    /*
     üìù BUSCA COM FILTROS DE NEG√ìCIO
     
     üéØ Processo:
     1. Busca documentos do usu√°rio
     2. Ordena por data (mais recentes primeiro)
     3. Limita quantidade de resultados
     4. Aplica valida√ß√µes de neg√≥cio
     5. Retorna apenas transa√ß√µes v√°lidas
     */
    func getUserTransactions(userId: String, limit: Int = 50) async throws -> [Transaction] {
        print("üìã TransactionService: Buscando transa√ß√µes do usu√°rio \(userId)")
        
        // üóÇÔ∏è Path hier√°rquico
        let collectionPath = "users/\(userId)/transactions"
        
        // üì• Buscar usando service gen√©rico
        let transactions = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            limit: limit,
            orderBy: "date",
            descending: true
        )
        
        // ‚úÖ Aplicar filtros de neg√≥cio
        let validTransactions = transactions.filter { isValidTransaction($0) }
        
        print("‚úÖ Transa√ß√µes v√°lidas carregadas: \(validTransactions.count)")
        return validTransactions
    }
    
    // MARK: - üéØ Regras de Neg√≥cio
    /*
     üìù VALIDA√á√ïES ESPEC√çFICAS DE TRANSA√á√ïES
     
     üéØ Regras aplicadas:
     ‚Ä¢ Valor deve ser positivo
     ‚Ä¢ Descri√ß√£o n√£o pode estar vazia
     ‚Ä¢ Adicione mais regras conforme necess√°rio
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // üí∞ Validar valor
        let isValidAmount = transaction.amount > 0
        
        // üìù Validar descri√ß√£o
        let isValidDescription = !transaction.description.trimmingCharacters(
            in: .whitespacesAndNewlines
        ).isEmpty
        
        // üìä Logs para debugging
        if !isValidAmount {
            print("‚ö†Ô∏è Transa√ß√£o inv√°lida: valor deve ser positivo")
        }
        
        if !isValidDescription {
            print("‚ö†Ô∏è Transa√ß√£o inv√°lida: descri√ß√£o n√£o pode estar vazia")
        }
        
        return isValidAmount && isValidDescription
    }
    
    // MARK: - üóëÔ∏è Deletar Transa√ß√£o
    func deleteTransaction(transactionId: String, userId: String) async throws {
        print("üóëÔ∏è TransactionService: Deletando transa√ß√£o \(transactionId)")
        
        let collectionPath = "users/\(userId)/transactions"
        
        try await firestoreService.deleteDocument(
            from: collectionPath,
            documentId: transactionId
        )
        
        print("‚úÖ Transa√ß√£o deletada")
    }
}


================================================================================
4. ContentView.swift - MODIFICADO
================================================================================
Status: ARQUIVO EXISTENTE - MODIFICAR m√©todo do bot√£o Service Layer
Modifica√ß√µes: Habilitar bot√£o e adicionar teste do TransactionService
Timing: 4:30 - 5:30 (60 segundos de implementa√ß√£o)
================================================================================

//
//  ContentView.swift
//  FinancasApp
//
//  Created by Di√≥genes Reis on 24/09/25.
//

import SwiftUI

struct ContentView: View {
    // ========================================================================
    // ‚úÖ ADICIONAR ESTADOS PARA TESTE DO SERVICE LAYER
    // ========================================================================
    @State private var isTestingService = false
    @State private var serviceTestResult: String = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 30) {
                // Cabe√ßalho
                VStack(spacing: 10) {
                    Image(systemName: "building.columns.fill")
                        .font(.system(size: 80))
                        .foregroundColor(.blue)
                    
                    Text("üèõÔ∏è Service Layer Demo")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                    
                    Text("Arquitetura Profissional")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 50)
                
                // Demonstra√ß√£o do Problema
                VStack(spacing: 15) {
                    Text("Demonstra√ß√£o")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    NavigationLink(destination: BadTransactionView()) {
                        HStack {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .foregroundColor(.red)
                            Text("Ver C√≥digo Espaguete üçù")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.red.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    Text("‚ùå View fazendo tudo - N√ÉO fazer!")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .padding(.horizontal)
                
                Divider()
                    .padding(.horizontal)
                
                // ================================================================
                // ‚úÖ MODIFICAR ESTA SE√á√ÉO COMPLETA - Solu√ß√£o Profissional
                // ================================================================
                VStack(spacing: 15) {
                    Text("Service Layer Implementado! üéâ")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Button(action: testServiceLayer) {
                        HStack {
                            if isTestingService {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                            } else {
                                Image(systemName: "checkmark.shield.fill")
                                    .foregroundColor(.green)
                            }
                            Text(isTestingService ? "Testando..." : "Testar Service Layer")
                                .fontWeight(.semibold)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(10)
                    }
                    .disabled(isTestingService)
                    
                    if !serviceTestResult.isEmpty {
                        Text(serviceTestResult)
                            .font(.caption)
                            .foregroundColor(.green)
                            .multilineTextAlignment(.center)
                    } else {
                        Text("‚úÖ Arquitetura elegante e test√°vel")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .padding(.horizontal)
                
                Spacer()
                
                // Informa√ß√£o de ambiente
                Text(EnvironmentConfig.environmentName)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.bottom)
            }
            .navigationBarHidden(true)
        }
        .task {
            // üß™ Valida√ß√£o autom√°tica da configura√ß√£o
            print("üß™ Executando valida√ß√£o autom√°tica...")
            let result = await ConfigurationValidator.validateSetup()
            
            if result.isValid {
                print("üéâ App pronto para uso!")
            } else {
                print("‚ö†Ô∏è \(result.message)")
            }
        }
    }
    
    // ========================================================================
    // ‚úÖ ADICIONAR TODO ESTE M√âTODO NOVO
    // ========================================================================
    // MARK: - üß™ Teste do Service Layer
    /*
     üìù DEMONSTRA√á√ÉO PR√ÅTICA DO SERVICE LAYER
     
     üéØ Testa:
     ‚Ä¢ Cria√ß√£o de transa√ß√£o usando TransactionService
     ‚Ä¢ Busca de transa√ß√µes do usu√°rio
     ‚Ä¢ Logs educativos no console
     ‚Ä¢ Error handling robusto
     */
    private func testServiceLayer() {
        isTestingService = true
        serviceTestResult = ""
        
        Task {
            do {
                let transactionService = TransactionService()
                
                // üìù Criar transa√ß√£o de teste
                let newTransaction = Transaction(
                    amount: 50.00,
                    description: "Teste Service Layer",
                    type: .income,
                    userId: "demo_user"
                )
                
                print("üìù Criando transa√ß√£o de teste...")
                let transactionId = try await transactionService.createTransaction(
                    newTransaction,
                    for: "demo_user"
                )
                
                print("‚úÖ Transa√ß√£o criada: \(transactionId)")
                
                // üìã Buscar transa√ß√µes
                print("üìã Buscando transa√ß√µes...")
                let transactions = try await transactionService.getUserTransactions(
                    userId: "demo_user"
                )
                
                print("‚úÖ Transa√ß√µes carregadas: \(transactions.count)")
                
                // ‚úÖ Atualizar UI
                await MainActor.run {
                    serviceTestResult = "‚úÖ Service Layer funcionando! \(transactions.count) transa√ß√µes carregadas."
                    isTestingService = false
                }
                
            } catch {
                print("‚ùå Erro no teste: \(error)")
                
                await MainActor.run {
                    serviceTestResult = "‚ùå Erro: \(error.localizedDescription)"
                    isTestingService = false
                }
            }
        }
    }
}

#Preview {
    ContentView()
}


================================================================================
RESUMO DAS MODIFICA√á√ïES - AULA 2.2 PARTE 4
================================================================================

üóÇÔ∏è ORGANIZA√á√ÉO (In√≠cio da aula - 0:00 a 0:45):
   ‚Ä¢ Criar 7 Groups no Xcode: App, Views, Models, Services, Configuration, 
     Managers, Resources
   ‚Ä¢ Mover arquivos existentes para groups corretos
   ‚Ä¢ Resultado: Estrutura profissional e organizada

‚ú® ARQUIVOS NOVOS (Criados na Parte 4):
   ‚Ä¢ Models/Transaction.swift
   ‚Ä¢ Services/FirestoreError.swift (~45 linhas)
   ‚Ä¢ Services/FirestoreService.swift (~120 linhas)
   ‚Ä¢ Services/TransactionService.swift (~90 linhas)

‚úèÔ∏è ARQUIVOS MODIFICADOS (Da Parte 3 para Parte 4):
   ‚Ä¢ Views/ContentView.swift
     - Adicionar estados: isTestingService, serviceTestResult
     - Modificar se√ß√£o do bot√£o Service Layer (habilitar)
     - Adicionar m√©todo testServiceLayer() completo

‚úÖ ARQUIVOS MANTIDOS SEM ALTERA√á√ÉO:
   ‚Ä¢ App/FinancasAppApp.swift
   ‚Ä¢ Views/BadTransactionView.swift
   ‚Ä¢ Configuration/EnvironmentConfig.swift
   ‚Ä¢ Configuration/FirestoreConfiguration.swift
   ‚Ä¢ Configuration/ConfigurationValidator.swift
   ‚Ä¢ Managers/FirebaseTestManager.swift
   ‚Ä¢ Resources/GoogleService-Info.plist


================================================================================
ESTRUTURA FINAL DO PROJETO AP√ìS PARTE 4
================================================================================

FinancasApp/
‚îú‚îÄ‚îÄ FinancasApp/
‚îÇ   ‚îú‚îÄ‚îÄ App/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FinancasAppApp.swift ‚úÖ
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ContentView.swift ‚úÖ (modificado)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BadTransactionView.swift ‚úÖ
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Transaction.swift ‚úÖ
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Services/ ‚≠ê ARQUIVOS CRIADOS NESTA AULA
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FirestoreError.swift ‚úÖ NOVO
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FirestoreService.swift ‚úÖ NOVO
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransactionService.swift ‚úÖ NOVO
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Configuration/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EnvironmentConfig.swift ‚úÖ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FirestoreConfiguration.swift ‚úÖ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ConfigurationValidator.swift ‚úÖ
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Managers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FirebaseTestManager.swift ‚úÖ
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Resources/
‚îÇ       ‚îú‚îÄ‚îÄ Assets.xcassets ‚úÖ
‚îÇ       ‚îî‚îÄ‚îÄ GoogleService-Info.plist ‚úÖ

üí° NOTA: A estrutura em pastas/groups foi criada NO IN√çCIO da aula (0:00-0:45)
como parte do ensino de arquitetura profissional.


================================================================================
LOGS ESPERADOS NO CONSOLE AP√ìS IMPLEMENTA√á√ÉO
================================================================================

üî• Iniciando configura√ß√£o do Firebase...
üìä Ambiente detectado: üîß Development
‚úÖ Arquivo encontrado
‚úÖ Firebase App inicializado
‚öôÔ∏è Aplicando configura√ß√µes avan√ßadas Firestore...
üìä Ambiente: üîß Development
   üìÅ Cache: 100MB (Development)
   üìù Debug logging: HABILITADO
‚úÖ Configura√ß√£o avan√ßada aplicada:
   ‚Ä¢ Cache offline: ATIVO
   ‚Ä¢ Tamanho cache: 100MB
   ‚Ä¢ SSL: ATIVO
   ‚Ä¢ Ambiente: üîß Development
‚úÖ Firestore otimizado para üîß Development
üéâ Configura√ß√£o completa finalizada!

üß™ Executando valida√ß√£o autom√°tica...
üß™ Validando configura√ß√£o avan√ßada...
   üîó Testando conex√£o...
   ‚úÖ Conex√£o OK
   ‚öôÔ∏è Validando settings aplicados...
   ‚úÖ Settings validados
   üíæ Testando opera√ß√£o de escrita...
   ‚úÖ Opera√ß√£o OK
‚úÖ Valida√ß√£o completa: SUCESSO!
üéâ App pronto para uso!

[Ao clicar em "Testar Service Layer"]

üìù Criando transa√ß√£o de teste...
üè≠ TransactionService: Criando transa√ß√£o para user demo_user
   üìÇ Path: users/demo_user/transactions
üíæ FirestoreService: Salvando documento em users/demo_user/transactions
   ‚ú® Criando novo documento com ID: ABC123XYZ
‚úÖ Documento salvo com sucesso: ABC123XYZ
‚úÖ Transa√ß√£o criada com sucesso: ABC123XYZ
‚úÖ Transa√ß√£o criada: ABC123XYZ

üìã Buscando transa√ß√µes...
üìã TransactionService: Buscando transa√ß√µes do usu√°rio demo_user
üîç FirestoreService: Buscando documentos de users/demo_user/transactions
   üìä Ordenando por: date (desc: true)
   üî¢ Limite: 50 documentos
   ‚úÖ Documento decodificado: ABC123XYZ
üìä Total de documentos carregados: 1
‚úÖ Transa√ß√µes v√°lidas carregadas: 1
‚úÖ Transa√ß√µes carregadas: 1


================================================================================
COMPARA√á√ÉO: ANTES (C√≥digo Espaguete) vs DEPOIS (Service Layer)
================================================================================

‚ùå ANTES (BadTransactionView):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ View fazendo TUDO
‚Ä¢ Conex√£o direta com Firestore na View
‚Ä¢ Error handling b√°sico e gen√©rico
‚Ä¢ Parsing manual propenso a erros
‚Ä¢ L√≥gica de neg√≥cio misturada com UI
‚Ä¢ Imposs√≠vel de testar isoladamente
‚Ä¢ C√≥digo duplicado em m√∫ltiplas telas
‚Ä¢ Dif√≠cil de manter e evoluir

‚úÖ DEPOIS (Service Layer):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ View focada apenas em UI
‚Ä¢ FirestoreService gen√©rico reutiliz√°vel
‚Ä¢ TransactionService com regras de neg√≥cio
‚Ä¢ Error handling robusto e espec√≠fico
‚Ä¢ Separa√ß√£o clara de responsabilidades
‚Ä¢ F√°cil de testar (mocks simples)
‚Ä¢ C√≥digo reutilizado entre telas
‚Ä¢ F√°cil de manter e escalar

Aspecto              | C√≥digo Espaguete  | Service Layer
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Organiza√ß√£o          | Tudo misturado    | Cada classe uma fun√ß√£o
Testabilidade        | Dif√≠cil           | F√°cil e r√°pido
Reutiliza√ß√£o         | C√≥digo duplicado  | Services compartilhados
Manuten√ß√£o           | Quebra tudo       | Mudan√ßas localizadas
Error Handling       | Try/catch b√°sico  | Sistema robusto
Performance          | N√£o otimizada     | Cache inteligente
Code Review          | Rejeitado         | Aprovado
N√≠vel Desenvolvedor  | Junior            | S√™nior


================================================================================
CONCEITOS-CHAVE IMPLEMENTADOS NA PARTE 4
================================================================================

üèóÔ∏è ARQUITETURA:
   ‚úÖ Service Layer Pattern
   ‚úÖ Separation of Concerns
   ‚úÖ Single Responsibility Principle
   ‚úÖ Generic Programming com Swift

üí° BOAS PR√ÅTICAS:
   ‚úÖ Error handling customizado
   ‚úÖ Logging educativo detalhado
   ‚úÖ Valida√ß√µes de neg√≥cio centralizadas
   ‚úÖ C√≥digo auto-documentado

üß™ TESTABILIDADE:
   ‚úÖ Services isolados e injet√°veis
   ‚úÖ F√°cil cria√ß√£o de mocks
   ‚úÖ L√≥gica de neg√≥cio test√°vel

üéØ QUALIDADE:
   ‚úÖ Reutiliza√ß√£o m√°xima de c√≥digo
   ‚úÖ Manuten√ß√£o facilitada
   ‚úÖ Escalabilidade garantida
   ‚úÖ Padr√µes da ind√∫stria aplicados



================================================================================
FIM DO C√ìDIGO COMPLETO - AULA 2.2 PARTE 4
================================================================================