// ==========================================
// AULA 2.2 - PARTE 6: LISTENERS EM TEMPO REAL
// C√≥digo Completo dos Arquivos Criados/Alterados
// ‚úÖ COMPAT√çVEL COM PARTE 5: Timestamps + Soft Delete
// ==========================================

/*
 üìã PR√â-REQUISITOS DA PARTE 5:
 
 ‚úÖ Transaction.swift com timestamps:
    - createdAt: Date
    - updatedAt: Date
    - isDeleted: Bool
    - deletedAt: Date?
 
 ‚úÖ FirestoreError.swift com m√©todo from()
 ‚úÖ FirestoreService.swift completo
 ‚úÖ Soft delete implementado
 ‚úÖ CRUDDemoView naveg√°vel
 ‚úÖ ContentView com NavigationView
 
 üéØ NESTA PARTE ADICIONAMOS:
 
 ‚ú® M√©todo listener em TransactionService (startListeningToUserTransactions)
 ‚ú® RealtimeDemoViewModel completo
 ‚ú® RealtimeDemoView com timestamps vis√≠veis
 ‚ú® NavigationLink adicional em ContentView
 ‚ú® Sincroniza√ß√£o autom√°tica funcionando
*/


// ==========================================
// 1. TransactionService.swift (ARQUIVO COMPLETO - Parte 5 + 6)
// ==========================================

import Foundation
import FirebaseFirestore

/*
 üõ†Ô∏è TRANSACTION SERVICE - SERVI√áO DE NEG√ìCIO
 
 Camada de servi√ßo que orquestra opera√ß√µes de transa√ß√µes.
 Implementa CRUD completo + Listeners em tempo real.
 
 Responsabilidades:
 - Valida√ß√µes de neg√≥cio
 - Orquestra√ß√£o de chamadas Firestore
 - Tratamento de erros espec√≠ficos
 - Gerenciamento de listeners
 
 N√ÉO faz:
 - Manipula√ß√£o direta do Firestore (usa FirestoreService)
 - Atualiza√ß√£o de UI (responsabilidade da ViewModel)
*/
class TransactionService {
    
    private let firestoreService = FirestoreService()
    
    // MARK: - CREATE (Parte 4/5)
    
    /*
     ‚ûï CRIAR NOVA TRANSA√á√ÉO
     
     Fluxo:
     1. Valida dados preventivamente
     2. Delega cria√ß√£o para FirestoreService
     3. Retorna ID gerado pelo Firebase
     
     Por que validar ANTES de enviar?
     - Economia (n√£o gasta read/write Firebase)
     - Performance (erro imediato vs esperar rede)
     - Consist√™ncia (banco sempre com dados v√°lidos)
     */
    func createTransaction(
        _ transaction: Transaction,
        for userId: String
    ) async throws -> String {
        print("üìù TransactionService: Criando transa√ß√£o")
        
        // üõ°Ô∏è VALIDA√á√ÉO PREVENTIVA
        guard isValidTransaction(transaction) else {
            print("‚ùå Valida√ß√£o falhou")
            throw FirestoreError.invalidData
        }
        
        let collectionPath = "users/\(userId)/transactions"
        let docId = try await firestoreService.saveDocument(
            transaction,
            to: collectionPath
        )
        
        print("‚úÖ Transa√ß√£o criada com ID: \(docId)")
        return docId
    }
    
    // MARK: - READ (Parte 4/5)
    
    /*
     üìñ BUSCAR TRANSA√á√ïES DO USU√ÅRIO
     
     Por padr√£o, N√ÉO retorna transa√ß√µes deletadas (soft delete).
     Para incluir deletadas, use getAllTransactionsIncludingDeleted()
     
     Par√¢metros:
     - userId: ID do usu√°rio propriet√°rio
     - limit: M√°ximo de docs (padr√£o 50 para performance)
     
     Retorna: Array de transa√ß√µes ATIVAS (isDeleted = false)
     */
    func getUserTransactions(
        userId: String,
        limit: Int = 50
    ) async throws -> [Transaction] {
        print("üìñ TransactionService: Buscando transa√ß√µes do usu√°rio \(userId)")
        print("  üìè Limite: \(limit)")
        
        let collectionPath = "users/\(userId)/transactions"
        
        let transactions: [Transaction] = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            orderBy: "date",
            descending: true,
            limit: limit
        )
        
        // Dupla valida√ß√£o + filtro de deletados
        let activeTransactions = transactions
            .filter { isValidTransaction($0) }
            .filter { !$0.isDeleted }  // ‚ú® N√ÉO mostra deletados
        
        print("‚úÖ \(activeTransactions.count) transa√ß√µes ativas retornadas")
        return activeTransactions
    }
    
    /*
     üìñ BUSCAR TODAS AS TRANSA√á√ïES (INCLUINDO DELETADAS)
     
     √ötil para:
     - Administra√ß√£o e auditoria
     - Relat√≥rios completos
     - Recupera√ß√£o de dados
     - An√°lise de hist√≥rico completo
     */
    func getAllTransactionsIncludingDeleted(
        userId: String,
        limit: Int = 50
    ) async throws -> [Transaction] {
        print("üìñ TransactionService: Buscando TODAS transa√ß√µes (incluindo deletadas)")
        print("  üìè Limite: \(limit)")
        
        let collectionPath = "users/\(userId)/transactions"
        
        let transactions: [Transaction] = try await firestoreService.getDocuments(
            from: collectionPath,
            type: Transaction.self,
            orderBy: "date",
            descending: true,
            limit: limit
        )
        
        // S√≥ valida, mas N√ÉO filtra deletados
        let validTransactions = transactions.filter { isValidTransaction($0) }
        
        print("‚úÖ \(validTransactions.count) transa√ß√µes totais (incluindo deletadas)")
        return validTransactions
    }
    
    // MARK: - UPDATE (Parte 5)
    
    /*
     ‚úèÔ∏è ATUALIZAR TRANSA√á√ÉO EXISTENTE
     
     Atualiza documento completo com merge inteligente
     e updatedAt autom√°tico
     */
    func updateTransaction(_ transaction: Transaction) async throws {
        print("‚úèÔ∏è TransactionService: Atualizando transa√ß√£o")
        
        // üîí VALIDAR ID
        guard let id = transaction.id else {
            print("‚ùå Erro: Transa√ß√£o deve ter ID para atualiza√ß√£o")
            throw FirestoreError.invalidData
        }
        
        // üõ°Ô∏è VALIDAR DADOS (preventivo!)
        guard isValidTransaction(transaction) else {
            print("‚ùå Erro: Dados inv√°lidos")
            throw FirestoreError.invalidData
        }
        
        // ‚è∞ ATUALIZAR TIMESTAMP
        var updatedTransaction = transaction
        updatedTransaction.updatedAt = Date()
        
        let collectionPath = "users/\(transaction.userId)/transactions"
        
        try await firestoreService.updateDocument(
            updatedTransaction,
            documentId: id,
            in: collectionPath,
            merge: true  // ‚ö° MERGE INTELIGENTE - preserva campos n√£o enviados
        )
        
        print("‚úÖ Transa√ß√£o atualizada com sucesso")
        print("  üìÖ updatedAt: \(updatedTransaction.updatedAt)")
    }
    
    // MARK: - DELETE (Parte 5)
    
    /*
     üóëÔ∏è REMOVER TRANSA√á√ÉO
     
     Implementa soft delete (padr√£o) e hard delete
     
     Soft delete:
     - Marca isDeleted = true
     - Preserva dados para auditoria
     - Compliance e recupera√ß√£o
     
     Hard delete:
     - Remove permanentemente
     - GDPR "direito ao esquecimento"
     - Dados tempor√°rios
     */
    func deleteTransaction(
        transactionId: String,
        userId: String,
        soft: Bool = true  // üè∑Ô∏è Padr√£o: soft delete
    ) async throws {
        let collectionPath = "users/\(userId)/transactions"
        
        if soft {
            // üè∑Ô∏è SOFT DELETE: marca isDeleted
            print("üè∑Ô∏è TransactionService: Soft delete de \(transactionId)")
            
            // Buscar documento atual
            var transaction = try await firestoreService.getDocument(
                transactionId,
                from: collectionPath,
                as: Transaction.self
            )
            
            // Marcar como deletado
            transaction.isDeleted = true
            transaction.deletedAt = Date()
            
            // Atualizar com as flags
            try await firestoreService.updateDocument(
                transaction,
                documentId: transactionId,
                in: collectionPath
            )
            
            print("‚úÖ Soft delete conclu√≠do")
            print("  üìÖ deletedAt: \(transaction.deletedAt!)")
            
        } else {
            // üóëÔ∏è HARD DELETE: remove permanentemente
            print("üóëÔ∏è TransactionService: Hard delete de \(transactionId)")
            
            try await firestoreService.deleteDocument(
                from: collectionPath,
                documentId: transactionId
            )
            
            print("‚úÖ Hard delete conclu√≠do - documento removido permanentemente")
        }
    }
    
    // MARK: - üîÑ Real-time Listeners (‚ú® PARTE 6 - NOVO!)
    
    /*
     üëÇ LISTENER PARA TRANSA√á√ïES EM TEMPO REAL
     
     Escuta mudan√ßas em tempo real e notifica a UI automaticamente.
     Implementa padr√£o Observer para sincroniza√ß√£o autom√°tica.
     
     üéØ Como funciona:
     1. Registra interesse nesta query (addSnapshotListener)
     2. Firebase detecta writes/deletes que afetam query
     3. Servidor envia diff (s√≥ o que mudou) via WebSocket
     4. Closure √© executada AUTOMATICAMENTE
     5. UI atualiza sem usu√°rio fazer nada!
     
     üéØ Par√¢metros:
     - userId: ID do usu√°rio propriet√°rio das transa√ß√µes
     - limit: Limite de documentos (padr√£o 50 para performance)
     - onUpdate: Closure chamada quando dados mudam (fornece [Transaction])
     - onError: Closure chamada quando ocorre erro
     
     ‚úÖ Retorna: ListenerRegistration para cleanup posterior
     
     ‚ö†Ô∏è CR√çTICO: 
     - SEMPRE chamar listener.remove() quando n√£o precisar mais!
     - Usar [weak self] na closure para evitar retain cycle
     - Usar DispatchQueue.main.async para atualizar UI
     */
    func startListeningToUserTransactions(
        userId: String,
        limit: Int = 50,
        onUpdate: @escaping ([Transaction]) -> Void,
        onError: @escaping (Error) -> Void
    ) -> ListenerRegistration {
        
        print("üëÇ === INICIANDO LISTENER TEMPO REAL ===")
        print("üë§ Usu√°rio: \(userId)")
        print("üìè Limite: \(limit) transa√ß√µes")
        print("üéØ Objetivo: Sincroniza√ß√£o autom√°tica em tempo real")
        
        // üóÑÔ∏è CONSTRUIR QUERY OTIMIZADA
        let db = Firestore.firestore()
        let query = db.collection("users")
            .document(userId)
            .collection("transactions")
            .order(by: "date", descending: true)  // Mais recentes primeiro
            .limit(to: limit)                     // Limitar para performance
        
        print("üìç Query constru√≠da: users/\(userId)/transactions")
        print("üîÑ Listener ativo - aguardando mudan√ßas...")
        
        // üëÇ ADICIONAR LISTENER (A M√ÅGICA ACONTECE AQUI!)
        /*
         üìù addSnapshotListener √© o cora√ß√£o do tempo real:
         
         O que acontece:
         1. Firestore "marca" esta query como "interessante"
         2. Toda vez que dados desta query mudam, Firestore avisa
         3. A closure abaixo √© executada AUTOMATICAMENTE
         4. Recebemos snapshot com dados atualizados
         
         √â como assinar notifica√ß√µes push, mas para dados!
         
         Esta closure executa:
         - IMEDIATAMENTE (dados iniciais)
         - TODA VEZ que algo mudar
         - AUTOMATICAMENTE sem a gente chamar nada!
         */
        let listener = query.addSnapshotListener { [weak self] snapshot, error in
            
            // üö® TRATAMENTO DE ERRO
            if let error = error {
                print("‚ùå Erro no listener: \(error.localizedDescription)")

                // üéØ NOTIFICAR ERRO NA THREAD PRINCIPAL
                /*
                ‚ö†Ô∏è CR√çTICO: onError atualiza @Published properties na UI!
                Precisa executar na main thread, assim como onUpdate.
     
                Sem isso: Crash "UIKit must be accessed from main thread"
                */
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
                return
            }
            
            // üìÑ VERIFICAR SNAPSHOT
            guard let snapshot = snapshot else {
                print("‚ö†Ô∏è Snapshot vazio recebido")
                DispatchQueue.main.async {
                    onUpdate([])
                }
                return
            }
            
            print("üì¶ Snapshot recebido: \(snapshot.documents.count) documentos")
            
            // üéØ CONVERTER DOCUMENTOS PARA OBJETOS SWIFT
            do {
                // Codable faz a m√°gica: Firebase JSON ‚Üí Swift Object
                let allTransactions = try snapshot.documents.map { document in
                    try document.data(as: Transaction.self)
                }
                
                print("‚úÖ Convertidos: \(allTransactions.count) transa√ß√µes")
                
                // üè∑Ô∏è FILTRAR DELETADOS (soft delete - Parte 5!)
                /*
                 Por padr√£o, n√£o mostramos transa√ß√µes deletadas.
                 isDeleted √© do modelo atualizado na Parte 5.
                 */
                let activeTransactions = allTransactions.filter { !$0.isDeleted }
                
                print("üè∑Ô∏è Filtradas: \(activeTransactions.count) ativas (sem deletadas)")
                
                // üõ°Ô∏è VALIDAR DADOS (defesa em profundidade)
                /*
                 Dupla valida√ß√£o:
                 1. Antes de salvar (preventiva)
                 2. Depois de buscar (garantia)
                 
                 Protege contra dados corrompidos ou regras mudadas.
                 */
                let validTransactions = activeTransactions.filter { 
                    self?.isValidTransaction($0) ?? true 
                }
                
                print("‚úÖ Validadas: \(validTransactions.count) transa√ß√µes v√°lidas")
                
                // üéØ NOTIFICAR UI NA THREAD PRINCIPAL
                /*
                 ‚ö†Ô∏è CR√çTICO: UI s√≥ pode ser atualizada na main thread!
                 
                 Listener executa em background thread (Firebase decide).
                 Temos que voltar pra main thread antes de atualizar UI.
                 
                 Sem isso: CRASH garantido!
                 "UIKit must be accessed from main thread"
                 */
                DispatchQueue.main.async {
                    onUpdate(validTransactions)
                }
                
                print("üé® UI notificada com \(validTransactions.count) transa√ß√µes")
                
            } catch {
                print("‚ùå Erro ao converter documentos: \(error)")
                DispatchQueue.main.async {
                    onError(FirestoreError.from(error))
                }
            }
        }
        
        print("üìå Listener registrado com sucesso")
        print("‚ö° Sincroniza√ß√£o autom√°tica ATIVA!")
        
        // ‚úÖ RETORNAR LISTENER PARA CLEANUP POSTERIOR
        /*
         ‚ö†Ô∏è IMPORTANTE: Este listener precisa ser REMOVIDO quando n√£o for mais necess√°rio!
         
         Sem remo√ß√£o = MEMORY LEAK:
         - Listener continua rodando
         - Consome recursos
         - App fica lento
         - Pode travar
         
         Sempre guardar este return e chamar .remove() depois!
         
         Pattern recomendado:
         1. Guardar em var listener: ListenerRegistration?
         2. Chamar listener?.remove() em stopListening()
         3. Ter deinit que chama stopListening() (rede de seguran√ßa)
         */
        return listener
    }
    
    // MARK: - VALIDA√á√ÉO (Parte 5)
    
    /*
     üõ°Ô∏è VALIDA√á√ÉO ROBUSTA
     
     Regras de neg√≥cio espec√≠ficas do dom√≠nio financeiro
     */
    private func isValidTransaction(_ transaction: Transaction) -> Bool {
        // 1. Amount n√£o pode ser zero
        guard transaction.amount > 0 else {
            print("‚ùå Valor inv√°lido: \(transaction.amount)")
            return false
        }
        
        // 2. Description n√£o pode estar vazia
        guard !transaction.description.isEmpty else {
            print("‚ùå Valida√ß√£o falhou: descri√ß√£o vazia")
            return false
        }
        
        // 3. Data n√£o pode ser futura
        guard transaction.date <= Date() else {
            print("‚ùå Data futura: \(transaction.date)")
            return false
        }
        
        return true
    }
}


// ==========================================
// 2. RealtimeDemoViewModel.swift (ARQUIVO COMPLETO - NOVO)
// ==========================================

import SwiftUI
import FirebaseFirestore

/*
 üé≠ VIEWMODEL PARA DEMONSTRA√á√ÉO DE TEMPO REAL
 
 Gerencia estado e l√≥gica da tela de demonstra√ß√£o.
 Implementa padr√£o MVVM (Model-View-ViewModel).
 
 Responsabilidades:
 - Iniciar/parar listeners
 - Gerenciar estado da UI (@Published)
 - Cleanup adequado (deinit)
 - Convers√£o de erros para mensagens
 
 N√ÉO faz:
 - Renderiza√ß√£o (responsabilidade da View)
 - L√≥gica de neg√≥cio (responsabilidade do Service)
 */
@MainActor
class RealtimeDemoViewModel: ObservableObject {
    
    // MARK: - Published Properties
    
    /*
     @Published: Quando estes valores mudam, SwiftUI re-renderiza a View automaticamente.
     
     √â o "contrato" entre ViewModel e View:
     - ViewModel atualiza @Published
     - View observa mudan√ßas
     - SwiftUI re-desenha automaticamente
     
     @MainActor garante que TUDO desta classe executa na main thread (UI-safe).
     */
    @Published var transactions: [Transaction] = []
    @Published var isListening = false
    @Published var message: String?
    
    // MARK: - Private Properties
    
    private let service = TransactionService()
    private let userId = "demo-user"
    
    /*
     ‚ö†Ô∏è CR√çTICO: Guardar ListenerRegistration para poder remover depois!
     
     Sem guardar = N√£o consegue parar listener = Memory leak!
     
    `nonisolated(unsafe)` significa:
     - **nonisolated**: "pode ser acessado de qualquer thread"
     - **unsafe**: "eu garanto que √© seguro fazer isso"
     
     Ao usarmos o **nonisolated(unsafe)** dizemos que esta property N√ÉO est√° isolada ao MainActor. Pode ser acessada de qualquer contexto (incluindo deinit) sem passar pelo mecanismo de sincroniza√ß√£o do actor. EU garanto que isso √© seguro porque:

     1. Firebase SDK √© thread-safe
     2. Opera√ß√µes s√£o simples (atribuir/remover)
     3. Property √© privada e controlada    
     */
    nonisolated(unsafe) private var listener: ListenerRegistration?
    
    // MARK: - Public Methods
    
    /*
     ‚ñ∂Ô∏è INICIAR LISTENER
     
     Come√ßa a observar mudan√ßas em tempo real.
     */
    func startListening() {
        // üõ°Ô∏è Validar: n√£o iniciar se j√° est√° escutando
        guard !isListening else {
            message = "‚ö†Ô∏è J√° est√° escutando!"
            print("‚ö†Ô∏è Tentativa de iniciar listener duplicado - ignorado")
            return
        }
        
        print("üéß ViewModel: Iniciando listener...")
        message = "üîÑ Iniciando listener..."
        
        // üëÇ Iniciar listener do service
        /*
         [weak self]: Evita retain cycle (refer√™ncia circular).
         
         Sem [weak self]:
         - Listener ‚Üí ret√©m closure
         - Closure ‚Üí ret√©m self (ViewModel)
         - ViewModel ‚Üí ret√©m listener
         - C√≠rculo vicioso = Memory leak!
         
         Com [weak self]:
         - Closure n√£o ret√©m ViewModel fortemente
         - Quando View desaparece, ViewModel pode ser destru√≠do
         - deinit executa e remove listener
         
         √â como ter airbag E cinto:
         - Ideal √© usar cinto (stopListening manual)
         - Mas airbag (deinit) salva se esquecer!
         */
        listener = service.startListeningToUserTransactions(
            userId: userId,
            limit: 50,
            onUpdate: { [weak self] transactions in
                // üéØ Dados atualizados!
                print("üéØ ViewModel: Recebeu \(transactions.count) transa√ß√µes")
                self?.transactions = transactions
                self?.isListening = true
                self?.message = "‚úÖ \(transactions.count) transa√ß√µes em tempo real"
            },
            onError: { [weak self] error in
                // üö® Erro ocorreu!
                print("‚ùå ViewModel: Erro recebido - \(error.localizedDescription)")
                self?.isListening = false
                self?.message = "‚ùå Erro: \(error.localizedDescription)"
            }
        )
        
        print("‚úÖ ViewModel: Listener iniciado com sucesso")
    }
    
    /*
     ‚è∏Ô∏è PARAR LISTENER
     
     Para de observar mudan√ßas e libera recursos.
     */
    func stopListening() {
        print("üõë ViewModel: Parando listener...")
        
        cleanupListener()      // Faz cleanup
        
        isListening = false // Atualiza a UI
        message = "üõë Listener parado"  // Feedback
                
        print("‚úÖ ViewModel: Listener parado com sucesso")
    }

    // ‚úÖ M√âTODO PRIVADO: Cleanup puro (usado pelo deinit)
    nonisolated private func cleanupListener() {
        listener?.remove()
        listener = nil
    }

    // MARK: - Lifecycle
    
    /*
     üßπ DESTRUTOR (CR√çTICO PARA CLEANUP!)
     
     Executado automaticamente quando ViewModel √© destru√≠do.
     
     Por que √© cr√≠tico:
     - View pode desaparecer sem chamar stopListening()
     - ViewModel seria destru√≠do mas listener continuaria rodando
     - deinit √© nossa REDE DE SEGURAN√áA
     - Garante que listener sempre ser√° removido
     
     √â como ter um finally {} autom√°tico!
     
     Cen√°rios onde deinit salva:
     1. Usu√°rio fecha app bruscamente
     2. Navega√ß√£o r√°pida entre telas
     3. Erro/crash na view
     4. Memory warning (iOS libera VMs n√£o vis√≠veis)
     
     Sem deinit adequado:
     - Listener continua rodando para sempre
     - Consome CPU e rede constantemente
     - Mem√≥ria nunca √© liberada
     - App fica progressivamente mais lento
     - iOS pode matar app por excesso de mem√≥ria
     */
    deinit {
        print("üßπ ViewModel: deinit chamado - removendo listener")
        cleanupListener()      // Faz cleanup
        print("‚úÖ ViewModel: Cleanup completo")
    }
}


// ==========================================
// 3. RealtimeDemoView.swift (ARQUIVO COMPLETO - NOVO)
// ==========================================

import SwiftUI

/*
 üé® VIEW PARA DEMONSTRA√á√ÉO DE TEMPO REAL
 
 Interface visual que demonstra sincroniza√ß√£o autom√°tica.
 
 Features:
 - Indicador visual de status (üéß escutando / üîá parado)
 - Bot√µes para iniciar/parar listener
 - Lista com transa√ß√µes atualizando em tempo real
 - Timestamps de auditoria vis√≠veis (Parte 5!)
 */
struct RealtimeDemoView: View {
    
    /*
     @StateObject: Cria e mant√©m ViewModel vivo enquanto View existe.
     
     @StateObject vs @ObservedObject:
     - @StateObject: View DONA do objeto (cria e destr√≥i)
     - @ObservedObject: View s√≥ OBSERVA (recebe pronto)
     
     Aqui usamos @StateObject porque esta View cria o ViewModel.
     Quando View desaparece ‚Üí SwiftUI destr√≥i @StateObject ‚Üí deinit executa!
     */
    @StateObject private var viewModel = RealtimeDemoViewModel()
    
    var body: some View {
        VStack(spacing: 20) {
            
            // üìç CABE√áALHO
            Text("‚ö° Tempo Real Demo")
                .font(.title2)
                .fontWeight(.bold)
                .padding(.top)
            
            // üéß STATUS DO LISTENER
            /*
             Indicador visual: usu√°rio sabe se est√° sincronizando.
             
             Verde (üéß Escutando): Dados atualizando automaticamente
             Cinza (üîá Parado): Sem sincroniza√ß√£o
             
             UX profissional: feedback visual constante do estado do sistema
             */
            HStack(spacing: 10) {
                Circle()
                    .fill(viewModel.isListening ? Color.green : Color.gray)
                    .frame(width: 12, height: 12)
                    .animation(.easeInOut, value: viewModel.isListening)
                
                Text(viewModel.isListening ? "üéß Escutando" : "üîá Parado")
                    .font(.subheadline)
                    .foregroundColor(viewModel.isListening ? .green : .gray)
            }
            .padding(10)
            .background(Color.gray.opacity(0.1))
            .cornerRadius(20)
            
            // üéõÔ∏è BOT√ïES DE CONTROLE
            HStack(spacing: 15) {
                // ‚ñ∂Ô∏è Iniciar Listener
                Button(action: {
                    viewModel.startListening()
                }) {
                    Label("Iniciar", systemImage: "play.circle.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(viewModel.isListening ? Color.gray.opacity(0.3) : Color.green.opacity(0.8))
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .disabled(viewModel.isListening)
                
                // ‚è∏Ô∏è Parar Listener
                Button(action: {
                    viewModel.stopListening()
                }) {
                    Label("Parar", systemImage: "stop.circle.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(!viewModel.isListening ? Color.gray.opacity(0.3) : Color.red.opacity(0.8))
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .disabled(!viewModel.isListening)
            }
            
            // üí¨ MENSAGEM DE FEEDBACK
            if let message = viewModel.message {
                Text(message)
                    .font(.caption)
                    .foregroundColor(message.contains("‚ùå") ? .red : .green)
                    .padding(10)
                    .background(
                        (message.contains("‚ùå") ? Color.red : Color.green)
                            .opacity(0.1)
                    )
                    .cornerRadius(8)
            }
            
            // üìã LISTA DE TRANSA√á√ïES EM TEMPO REAL
            /*
             ‚ú® ATUALIZA AUTOMATICAMENTE!
             
             Quando Firebase detecta mudan√ßa:
             1. Listener notifica ViewModel
             2. ViewModel atualiza @Published transactions
             3. SwiftUI detecta mudan√ßa
             4. Lista re-renderiza AUTOMATICAMENTE
             
             Sem apertar NADA! ü§Ø
             
             Magia do SwiftUI + Combine + Listeners:
             - ViewModel √© @ObservableObject
             - transactions √© @Published
             - View observa com @StateObject
             - Mudan√ßa propaga automaticamente
             */
            List(viewModel.transactions) { transaction in
                VStack(alignment: .leading, spacing: 8) {
                    
                    // üí∞ VALOR + STATUS
                    HStack {
                        Text("R$ \(transaction.amount, specifier: "%.2f")")
                            .font(.headline)
                            .foregroundColor(.primary)
                        
                        Spacer()
                        
                        // üè∑Ô∏è Badge de Deletado (se soft deleted)
                        if transaction.isDeleted {
                            Text("üè∑Ô∏è DELETED")
                                .font(.caption)
                                .foregroundColor(.white)
                                .padding(4)
                                .background(Color.red)
                                .cornerRadius(4)
                        }
                    }
                    
                    // üìù DESCRI√á√ÉO
                    Text(transaction.description)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    // ‚ú® TIMESTAMPS DE AUDITORIA (PARTE 5!)
                    /*
                     Mostra quando foi:
                     - Created: Criado pela primeira vez (nunca muda)
                     - Updated: √öltima modifica√ß√£o (atualiza em tempo real!)
                     - Deleted: Quando foi deletado (se deletado)
                     
                     Estes campos v√™m do Transaction.swift atualizado na Parte 5!
                     
                     A m√°gica: quando UPDATE acontece em outro dispositivo:
                     1. updatedAt muda no Firestore
                     2. Listener detecta mudan√ßa
                     3. UI atualiza timestamp AUTOMATICAMENTE
                     4. Usu√°rio v√™ mudan√ßa em tempo real! ‚ö°
                     */
                    HStack(spacing: 15) {
                        // Timestamps cria√ß√£o e atualiza√ß√£o
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Created: \(transaction.createdAt, style: .time)")
                                .font(.caption2)
                            Text("Updated: \(transaction.updatedAt, style: .time)")
                                .font(.caption2)
                        }
                        .foregroundColor(.gray)
                        
                        Spacer()
                        
                        // Timestamp de dele√ß√£o (se existir)
                        if let deletedAt = transaction.deletedAt {
                            Text("Deleted: \(deletedAt, style: .time)")
                                .font(.caption2)
                                .foregroundColor(.red)
                        }
                    }
                }
                .padding(.vertical, 4)
            }
            .listStyle(.plain)
        }
        .navigationTitle("‚ö° Tempo Real")
        .padding()
        
        /*
         üìù NOTA: N√£o precisamos chamar stopListening() manualmente!
         
         Quando esta View desaparece:
         1. SwiftUI destr√≥i @StateObject (viewModel)
         2. deinit do ViewModel √© chamado automaticamente
         3. deinit chama stopListening()
         4. Listener √© removido
         5. Cleanup completo! ‚úÖ
         
         √â a beleza de usar deinit como rede de seguran√ßa!
         √â como ter airbag no carro - pode n√£o precisar, mas salva se acontecer algo.
         
         Pattern: Defensive Programming
         - 1¬™ linha: stopListening() manual (ideal path)
         - 2¬™ linha: deinit autom√°tico (fallback)
         */
    }
}

// Preview para desenvolvimento
#Preview {
    NavigationView {
        RealtimeDemoView()
    }
}


// ==========================================
// 4. ContentView.swift (ARQUIVO COMPLETO - Atualizado)
// ==========================================

import SwiftUI

/*
 üè† CONTENTVIEW - TELA PRINCIPAL DO APP
 
 Menu principal com navega√ß√£o para diferentes demos:
 - CRUD Completo (Parte 5)
 - Tempo Real (Parte 6)
 
 Estrutura:
 - NavigationView (para NavigationLinks funcionarem)
 - Cabe√ßalho visual
 - Bot√µes de demonstra√ß√£o
 - Valida√ß√£o autom√°tica no .task
 */
struct ContentView: View {
    
    var body: some View {
        NavigationView {
            VStack(spacing: 30) {
                
                // üì± CABE√áALHO
                VStack(spacing: 10) {
                    Image(systemName: "building.columns.fill")
                        .font(.system(size: 80))
                        .foregroundColor(.blue)
                    
                    Text("üõ°Ô∏è Service Layer Demo")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                    
                    Text("Arquitetura Profissional")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 50)
                
                // üéØ DEMONSTRA√á√ïES
                VStack(spacing: 15) {
                    Text("Demonstra√ß√µes")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    // ============================================================
                    // ‚úÖ CRUD COMPLETO (PARTE 5)
                    // ============================================================
                    NavigationLink(destination: CRUDDemoView()) {
                        HStack {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.green)
                                .font(.title2)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Testar CRUD Completo")
                                    .fontWeight(.semibold)
                                    .foregroundColor(.primary)
                                
                                Text("CREATE + READ + UPDATE + DELETE + Auditoria")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .foregroundColor(.gray)
                        }
                        .padding()
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(10)
                    }
                    
                    // ============================================================
                    // ‚ú® TEMPO REAL (PARTE 6 - NOVO!)
                    // ============================================================
                    NavigationLink(destination: RealtimeDemoView()) {
                        HStack {
                            Image(systemName: "bolt.circle.fill")
                                .foregroundColor(.blue)
                                .font(.title2)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Testar Tempo Real")
                                    .fontWeight(.semibold)
                                    .foregroundColor(.primary)
                                
                                Text("Sincroniza√ß√£o Autom√°tica + Timestamps")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .foregroundColor(.gray)
                        }
                        .padding()
                        .background(Color.blue.opacity(0.1))
                        .cornerRadius(10)
                    }
                }
                .padding(.horizontal)
                
                Spacer()
                
                // ‚ÑπÔ∏è INFORMA√á√ÉO DE AMBIENTE
                Text(EnvironmentConfig.environmentName)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.bottom)
            }
            .navigationBarHidden(true)
        }
        .task {
            // üß™ Valida√ß√£o autom√°tica da configura√ß√£o
            print("üß™ Executando valida√ß√£o autom√°tica...")
            let result = await ConfigurationValidator.validateSetup()
            
            if result.isValid {
                print("üéâ App pronto para uso!")
            } else {
                print("‚ö†Ô∏è \(result.message)")
            }
        }
    }
}

#Preview {
    ContentView()
}


// ==========================================
// üìù RESUMO DAS MUDAN√áAS DA PARTE 6
// ==========================================

/*
‚úÖ ADICIONADO √Ä PARTE 5:

1. TransactionService.swift:
   ‚ú® M√©todo startListeningToUserTransactions() COMPLETO
   ‚ú® Filtra isDeleted (soft delete da Parte 5)
   ‚ú® Valida dados (dupla valida√ß√£o mantida)
   ‚ú® DispatchQueue.main.async (thread safety)
   ‚ú® Retorna ListenerRegistration (para cleanup)
   ‚ú® Coment√°rios educativos linha por linha

2. RealtimeDemoViewModel.swift (NOVO - ARQUIVO COMPLETO):
   ‚ú® @MainActor para thread safety total
   ‚ú® @Published properties para UI reativa
   ‚ú® startListening() e stopListening()
   ‚ú® [weak self] para evitar retain cycles
   ‚ú® deinit para cleanup autom√°tico (rede de seguran√ßa)
   ‚ú® Tratamento de erros com mensagens

3. RealtimeDemoView.swift (NOVO - ARQUIVO COMPLETO):
   ‚ú® @StateObject para gerenciar ViewModel
   ‚ú® Indicador visual de status (üéß/üîá animado)
   ‚ú® Bot√µes para iniciar/parar listener
   ‚ú® Lista com timestamps vis√≠veis (Parte 5!)
   ‚ú® UI atualiza automaticamente (SwiftUI magic)
   ‚ú® Feedback visual constante

4. ContentView.swift (ARQUIVO COMPLETO - ATUALIZADO):
   ‚ú® NavigationLink para RealtimeDemoView
   ‚ú® Mant√©m NavigationLink do CRUDDemoView
   ‚ú® Dois bot√µes com √≠cones e descri√ß√µes
   ‚ú® Layout consistente e profissional

üéØ RESULTADO FINAL:
App profissional com:
- CRUD completo (Parte 5)
- Sincroniza√ß√£o autom√°tica em tempo real (Parte 6)
- Auditoria profissional integrada
- Thread safety garantido
- Memory management correto
- Arquitetura MVVM escal√°vel
- UX moderna e responsiva

üíº N√çVEL: EMPRESARIAL! üöÄ
*/


// ==========================================
// üß™ COMO TESTAR
// ==========================================

/*
1Ô∏è‚É£ RODAR APP:
   - Command+R no Xcode
   - Simulador abre ContentView

2Ô∏è‚É£ NAVEGAR PARA TEMPO REAL:
   - Clicar bot√£o "Testar Tempo Real ‚ö°"
   - RealtimeDemoView abre

3Ô∏è‚É£ INICIAR LISTENER:
   - Clicar "‚ñ∂Ô∏è Iniciar"
   - Indicador fica verde (üéß Escutando)
   - Console mostra:
     üëÇ === INICIANDO LISTENER ===
     üîÑ Listener ativo - aguardando mudan√ßas...

4Ô∏è‚É£ TESTAR SINCRONIZA√á√ÉO (CREATE):
   - Voltar ao ContentView (< Back)
   - Entrar em "Testar CRUD Completo ‚úÖ"
   - Criar nova transa√ß√£o
   - Voltar para "Testar Tempo Real ‚ö°"
   - ‚ú® Transa√ß√£o aparece AUTOMATICAMENTE!
   - Timestamps vis√≠veis (Created, Updated)

5Ô∏è‚É£ TESTAR UPDATE EM TEMPO REAL:
   - Ir em CRUD Demo
   - Atualizar uma transa√ß√£o (mudar valor)
   - Voltar para Tempo Real Demo
   - ‚ú® Valor muda AUTOMATICAMENTE!
   - ‚ú® Updated timestamp muda AUTOMATICAMENTE!

6Ô∏è‚É£ TESTAR SOFT DELETE:
   - Ir em CRUD Demo
   - Fazer soft delete de uma transa√ß√£o
   - Voltar para Tempo Real Demo
   - ‚ú® Transa√ß√£o SOME da lista AUTOMATICAMENTE!
   - Ainda existe no Firestore (auditoria)

7Ô∏è‚É£ PARAR LISTENER:
   - Clicar "‚è∏Ô∏è Parar"
   - Indicador fica cinza (üîá Parado)
   - Console mostra:
     üõë Listener parado

8Ô∏è‚É£ TESTAR CLEANUP:
   - Iniciar listener novamente
   - Sair da tela (voltar)
   - Console mostra:
     üßπ ViewModel: deinit chamado - removendo listener
     ‚úÖ ViewModel: Cleanup completo

‚úÖ SE TUDO FUNCIONOU:
   - Sincroniza√ß√£o autom√°tica OK
   - Timestamps aparecem e atualizam
   - Cleanup sem memory leaks
   - App n√≠vel EMPRESARIAL! üéâ

üì± TESTE ADICIONAL (DOIS SIMULADORES):
   - Abrir app em 2 simuladores simultaneamente
   - Iniciar listener em ambos
   - Criar transa√ß√£o no simulador 1
   - ‚ú® Aparece INSTANTANEAMENTE no simulador 2!
   - Isso √© TEMPO REAL! üî•
*/


// ==========================================
// üêõ TROUBLESHOOTING
// ==========================================

/*
‚ùå PROBLEMA: Listener n√£o atualiza
‚úÖ SOLU√á√ÉO:
   - Verificar Firebase conectado (FirebaseApp.configure())
   - Verificar regras de seguran√ßa no Firebase Console
   - Confirmar userId correto ("demo-user")
   - Logs no console mostram erros?

‚ùå PROBLEMA: App trava ao atualizar lista
‚úÖ SOLU√á√ÉO:
   - Confirmar DispatchQueue.main.async nas closures
   - Sem isso = update UI em background thread = CRASH
   - Adicionar nos dois lugares: onUpdate E onError

‚ùå PROBLEMA: Memory leak (app fica lento)
‚úÖ SOLU√á√ÉO:
   - Verificar [weak self] nas closures (startListening)
   - Verificar deinit sendo chamado (console mostra?)
   - Confirmar listener?.remove() no deinit
   - Usar Instruments > Leaks para debug detalhado

‚ùå PROBLEMA: Timestamps n√£o aparecem
‚úÖ SOLU√á√ÉO:
   - Confirmar Transaction.swift tem campos da Parte 5:
     * createdAt: Date
     * updatedAt: Date
     * isDeleted: Bool
     * deletedAt: Date?
   - Recompilar projeto (Command+Shift+K, Command+B)

‚ùå PROBLEMA: Bot√µes n√£o funcionam
‚úÖ SOLU√á√ÉO:
   - Verificar ContentView tem NavigationView
   - NavigationLink precisa de NavigationView pai
   - Confirmar arquivos criados:
     * RealtimeDemoViewModel.swift
     * RealtimeDemoView.swift

‚ùå PROBLEMA: Console mostra "UIKit not on main thread"
‚úÖ SOLU√á√ÉO:
   - Adicionar DispatchQueue.main.async { } em TODAS as closures
   - ViewModel precisa ter @MainActor
   - Nunca atualizar @Published fora da main thread

üÜò AINDA COM PROBLEMAS?
   - Limpar build folder (Command+Shift+K)
   - Rebuild (Command+B)
   - Reiniciar simulador
   - Verificar console para erros espec√≠ficos
   - Comparar c√≥digo com este arquivo completo
*/
