// ==========================================
// AULA 2.2 - PARTE 7: C√ìDIGO COMPLETO
// ‚úÖ CORRIGIDO - 100% compat√≠vel com Parte 6
// ==========================================

/*
 üìã ESTRUTURA DE ARQUIVOS:
 
 1. RealtimeDemoViewModel.swift (MODIFICADO)
 2. RealtimeDemoView.swift (MODIFICADO - Dashboard)
 3. Components/BalanceHeaderView.swift (NOVO)
 4. Components/StatisticsCardView.swift (NOVO)
 5. Components/TransactionCardView.swift (NOVO)
 6. Components/EmptyStateView.swift (NOVO)
*/


// ==========================================
// 1Ô∏è‚É£ RealtimeDemoViewModel.swift
// ==========================================

import SwiftUI
import FirebaseFirestore

@MainActor
class RealtimeDemoViewModel: ObservableObject {
    
    // MARK: - üìä Published Properties (DA PARTE 6)
    @Published var transactions: [Transaction] = []
    @Published var isListening = false
    @Published var message: String?
    
    // MARK: - üîß Dependencies (DA PARTE 6)
    private let service = TransactionService()
    private let userId = "demo_user"
    
    // MARK: - üéÆ Listener (DA PARTE 6 - ESSENCIAL!)
    /// ‚ö†Ô∏è nonisolated(unsafe) permite acesso no deinit
    nonisolated(unsafe) private var listener: ListenerRegistration?
    
    
    // MARK: - üì° Listener Control (DA PARTE 6)
    
    func startListening() {
        guard !isListening else {
            message = "‚ö†Ô∏è J√° est√° escutando!"
            return
        }
        
        print("‚ñ∂Ô∏è ViewModel: Iniciando listener...")
     
        listener = service.startListeningToUserTransactions(
            userId: userId,
            limit: 50,
            onUpdate: { [weak self] transactions in
                print("‚úÖ ViewModel: \(transactions.count) transa√ß√µes recebidas")
                self?.transactions = transactions
                self?.isListening = true
                self?.message = "‚úÖ Sincronizando (\(transactions.count) transa√ß√µes)"
            },
            onError: { [weak self] error in
                print("‚ùå ViewModel: Erro no listener: \(error.localizedDescription)")
                self?.isListening = false
                self?.message = "‚ùå Erro: \(error.localizedDescription)"
            }
        )

        print("‚úÖ ViewModel: Listener iniciado com sucesso")
    }

    }
    
    func stopListening() {
        print("üõë ViewModel: Parando listener...")
        cleanupListener()
        isListening = false
        message = "üõë Listener parado"
        print("‚úÖ ViewModel: Listener parado com sucesso")
    }
    
    // MARK: - üßπ Cleanup (DA PARTE 6 - CR√çTICO!)
    
    /// Limpa o listener (usado por stopListening e deinit)
    nonisolated private func cleanupListener() {
        listener?.remove()
        listener = nil
    }
    
    deinit {
        print("üßπ ViewModel: deinit chamado")
        cleanupListener()
        print("‚úÖ ViewModel: Cleanup completo")
    }
    
    
    // MARK: - üí∞ Computed Properties (‚ú® NOVO NA PARTE 7)
    /*
    ‚ö†Ô∏è IMPORTANTE: C√°lculos baseados nas √∫ltimas 50 transa√ß√µes
 
    Por quest√µes de performance, o listener carrega apenas as 50 
    transa√ß√µes mais recentes. Portanto, estes valores s√£o APROXIMADOS
    e representam apenas a atividade recente, n√£o o hist√≥rico completo.
 
    Em um app de produ√ß√£o, voc√™ deveria:
    1. Usar agrega√ß√£o do Firestore para totais reais
    2. Ter uma collection separada com totais consolidados
    3. Ou calcular totais no backend
    */
    
    /// Saldo das √∫ltimas 50 transa√ß√µes
    var totalBalance: Double {
        transactions.reduce(0.0) { $0 + $1.amount }
    }
    
    /// Total de receitas (valores positivos)
    var totalIncome: Double {
        transactions
            .filter { $0.amount > 0 }
            .reduce(0.0) { $0 + $1.amount }
    }
    
    /// Total de receitas (√∫ltimas 50 transa√ß√µes)
    var totalExpenses: Double {
        abs(transactions
            .filter { $0.amount < 0 }
            .reduce(0.0) { $0 + $1.amount })
    }
    
    /// Quantidade de transa√ß√µes (√∫ltimas 50 transa√ß√µes)
    var transactionCount: Int {
        transactions.count
    }
    
    /// M√©dia de gastos (√∫ltimas 50 transa√ß√µes)
    var averageExpense: Double {
        let expenses = transactions.filter { $0.amount < 0 }
        guard !expenses.isEmpty else { return 0 }
        return abs(expenses.reduce(0.0) { $0 + $1.amount }) / Double(expenses.count)
    }
    
    // MARK: - üé® Formatadores (‚ú® NOVO NA PARTE 7)
    
    /// Formata valor para moeda brasileira
    func formatCurrency(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
    }
    
    /// Formata data para formato brasileiro
    func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: date)
    }
}


// ==========================================
// 2Ô∏è‚É£ RealtimeDemoView.swift (Dashboard Completo)
// ==========================================

import SwiftUI

struct RealtimeDemoView: View {
    @StateObject private var viewModel = RealtimeDemoViewModel()
    
    var body: some View {
        NavigationView {
            ZStack {
                // Background gradient
                LinearGradient(
                    colors: [Color.blue.opacity(0.1), Color.purple.opacity(0.1)],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                
                ScrollView {
                    VStack(spacing: 20) {
                        // üí∞ CABE√áALHO COM SALDO
                        BalanceHeaderView(
                            totalBalance: viewModel.totalBalance,
                            totalIncome: viewModel.totalIncome,
                            totalExpenses: viewModel.totalExpenses,
                            formatter: viewModel.formatCurrency
                        )
                        .padding(.horizontal)
                        
                        // üìä ESTAT√çSTICAS
                        HStack(spacing: 15) {
                            StatisticsCardView(
                                title: "Transa√ß√µes",
                                value: "\(viewModel.transactionCount)",
                                icon: "list.bullet",
                                color: .blue
                            )
                            
                            StatisticsCardView(
                                title: "M√©dia Gastos",
                                value: viewModel.formatCurrency(viewModel.averageExpense),
                                icon: "chart.bar",
                                color: .orange
                            )
                        }
                        .padding(.horizontal)
                        
                        // üìã LISTA DE TRANSA√á√ïES
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Transa√ß√µes Recentes")
                                .font(.headline)
                                .padding(.horizontal)
                            
                            if viewModel.transactions.isEmpty {
                                EmptyStateView()
                                    .padding(.top, 40)
                            } else {
                                ForEach(viewModel.transactions) { transaction in
                                    TransactionCardView(
                                        transaction: transaction,
                                        formatter: viewModel.formatCurrency,
                                        dateFormatter: viewModel.formatDate
                                    )
                                    .padding(.horizontal)
                                }
                            }
                        }
                        .padding(.top, 10)
                    }
                    .padding(.vertical)
                }
            }
            .navigationTitle("üí∞ Dashboard")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        if viewModel.isListening {
                            viewModel.stopListening()
                        } else {
                            viewModel.startListening()
                        }
                    }) {
                        Image(systemName: viewModel.isListening ? "stop.circle.fill" : "play.circle.fill")
                            .foregroundColor(viewModel.isListening ? .red : .green)
                            .font(.title2)
                    }
                }
            }
            .overlay(alignment: .bottom) {
                if let message = viewModel.message {
                    Text(message)
                        .font(.caption)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 8)
                        .background(.ultraThinMaterial)
                        .cornerRadius(20)
                        .padding(.bottom, 20)
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }
            }
        }
    }
}


// ==========================================
// 3Ô∏è‚É£ Components/BalanceHeaderView.swift
// ==========================================

import SwiftUI

/// Cabe√ßalho com saldo total e estat√≠sticas de receitas/gastos
struct BalanceHeaderView: View {
    let totalBalance: Double
    let totalIncome: Double
    let totalExpenses: Double
    let formatter: (Double) -> String
    
    var body: some View {
        VStack(spacing: 16) {
            // SALDO PRINCIPAL
            VStack(spacing: 4) {
                Text("Saldo Total")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                Text(formatter(totalBalance))
                    .font(.system(size: 36, weight: .bold, design: .rounded))
                    .foregroundColor(totalBalance >= 0 ? .green : .red)
                    .animation(.easeInOut(duration: 0.3), value: totalBalance)
            }
            
            // RECEITAS E GASTOS
            HStack(spacing: 20) {
                // Receitas
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Image(systemName: "arrow.up.circle.fill")
                            .foregroundColor(.green)
                        Text("Receitas")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    Text(formatter(totalIncome))
                        .font(.headline)
                        .foregroundColor(.green)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                
                Divider()
                    .frame(height: 40)
                
                // Gastos
                VStack(alignment: .trailing, spacing: 4) {
                    HStack {
                        Text("Gastos")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Image(systemName: "arrow.down.circle.fill")
                            .foregroundColor(.red)
                    }
                    Text(formatter(totalExpenses))
                        .font(.headline)
                        .foregroundColor(.red)
                }
                .frame(maxWidth: .infinity, alignment: .trailing)
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(.ultraThinMaterial)
                .shadow(color: .black.opacity(0.1), radius: 10, y: 5)
        )
    }
}


// ==========================================
// 4Ô∏è‚É£ Components/StatisticsCardView.swift
// ==========================================

import SwiftUI

/// Card de estat√≠stica individual (transa√ß√µes, m√©dia, etc)
struct StatisticsCardView: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(color)
                
                Spacer()
            }
            
            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)
            
            Text(value)
                .font(.headline)
                .foregroundColor(.primary)
        }
        .padding(16)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(.ultraThinMaterial)
                .shadow(color: .black.opacity(0.05), radius: 5, y: 2)
        )
    }
}


// ==========================================
// 5Ô∏è‚É£ Components/TransactionCardView.swift
// ==========================================

import SwiftUI

/// Card individual de transa√ß√£o
struct TransactionCardView: View {
    let transaction: Transaction
    let dateFormatter: (Date) -> String
    let currencyFormatter: (Double) -> String
    
    var body: some View {
        HStack(spacing: 12) {
            // √çcone
            Image(systemName: transaction.amount > 0 ? "arrow.up.circle.fill" : "arrow.down.circle.fill")
                .font(.title2)
                .foregroundColor(transaction.amount > 0 ? .green : .red)
            
            // Descri√ß√£o e Data
            VStack(alignment: .leading, spacing: 4) {
                Text(transaction.description)
                    .font(.headline)
                
                Text(dateFormatter(transaction.date))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // Valor
            Text(currencyFormatter(transaction.amount))
                .font(.headline)
                .foregroundColor(transaction.amount > 0 ? .green : .red)
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(.ultraThinMaterial)
                .shadow(color: .black.opacity(0.05), radius: 5, y: 2)
        )
    }
}


// ==========================================
// 6Ô∏è‚É£ Components/EmptyStateView.swift
// ==========================================

import SwiftUI

/// Estado vazio quando n√£o h√° transa√ß√µes
struct EmptyStateView: View {
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "tray")
                .font(.system(size: 60))
                .foregroundColor(.secondary)
            
            Text("Nenhuma transa√ß√£o ainda")
                .font(.headline)
                .foregroundColor(.secondary)
            
            Text("Suas transa√ß√µes aparecer√£o aqui em tempo real")
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 60)
    }
}


// ==========================================
// üìù RESUMO - O QUE MUDOU DA PARTE 6 ‚Üí 7
// ==========================================

/*
 ‚úÖ PARTE 6 (Base):
 - TransactionService com listeners
 - RealtimeDemoViewModel b√°sico
 - Lista simples de transa√ß√µes
 - Start/Stop listener funcionando
 
 ‚ú® PARTE 7 (Evolu√ß√£o):
 - ViewModel: + computed properties + formatadores + init + handleError
 - View: Dashboard completo com componentes
 - 4 componentes novos: BalanceHeader, Statistics, TransactionCard, EmptyState
 - Design profissional com gradientes e shadows
 - Estados visuais (vazio, carregando)
 
 üîí COMPATIBILIDADE:
 - nonisolated(unsafe) listener MANTIDO
 - cleanupListener() MANTIDO
 - deinit MANTIDO
 - Mesmos nomes de propriedades
 - C√≥digo da P6 funciona sem mudan√ßas
 */
