// ==========================================
// AULA 2.2 - PARTE 7: DASHBOARD SWIFTUI PROFISSIONAL
// C√≥digo Completo dos Arquivos Criados/Modificados
// ‚úÖ CONTINUA DA PARTE 6: Listeners funcionando
// ==========================================

/*
 üìã PR√â-REQUISITOS DA PARTE 6:
 
 ‚úÖ TransactionService com listeners implementados
 ‚úÖ RealtimeDemoViewModel b√°sico funcionando
 ‚úÖ RealtimeDemoView com lista simples
 ‚úÖ Sincroniza√ß√£o em tempo real ativa
 
 üéØ NESTA PARTE ADICIONAMOS:
 
 ‚ú® Computed properties reativas no ViewModel
 ‚ú® Formatadores para UI
 ‚ú® 4 componentes visuais reutiliz√°veis
 ‚ú® Dashboard profissional completo
 ‚ú® Estados visuais (empty, loading, error)
*/


// ==========================================
// 1. RealtimeDemoViewModel.swift (ARQUIVO MODIFICADO - adicionar ao existente)
// ==========================================

import SwiftUI
import FirebaseFirestore

/*
 üé≠ REALTIME DEMO VIEWMODEL - VERS√ÉO EVOLU√çDA
 
 Parte 6: Gest√£o b√°sica de listeners
 Parte 7: + Computed properties + Formatadores
*/
@MainActor
class RealtimeDemoViewModel: ObservableObject {
    
    // MARK: - üìä Published Properties (DA PARTE 6)
    @Published var transactions: [Transaction] = []
    @Published var isListening = false
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var connectionStatus = "üîç Inicializando..."
    
    // MARK: - üîß Dependencies (DA PARTE 6)
    private let transactionService = TransactionService()
    private let currentUserId = "realtime_demo_user"
    private var transactionListener: ListenerRegistration?
    
    // MARK: - üí∞ Computed Properties Reativas (‚ú® PARTE 7 - NOVO!)
    
    /*
     üßÆ SALDO TOTAL
     
     Calcula automaticamente a partir de todas transa√ß√µes.
     Receitas s√£o positivas, gastos negativos.
     
     üîÑ Reativo: Sempre que `transactions` muda via listener,
     esta propriedade recalcula automaticamente e
     SwiftUI re-renderiza qualquer Text() que use totalBalance!
     */
    var totalBalance: Double {
        transactions.reduce(0.0) { $0 + $1.amount }
    }
    
    /*
     üíö TOTAL DE RECEITAS
     
     Soma apenas valores positivos (receitas).
     Usa filter + reduce = pipeline funcional elegante!
     
     Por que filter primeiro?
     - Performance: s√≥ soma o que interessa
     - Clareza: inten√ß√£o expl√≠cita no c√≥digo
     */
    var totalIncome: Double {
        transactions
            .filter { $0.amount > 0 }
            .reduce(0.0) { $0 + $1.amount }
    }
    
    /*
     ‚ù§Ô∏è TOTAL DE GASTOS
     
     Soma apenas valores negativos (gastos).
     Retorna valor absoluto para exibi√ß√£o (gastos como positivos).
     
     Por que abs()? UI mostra "R$ 500" n√£o "R$ -500"
     */
    var totalExpenses: Double {
        abs(transactions
            .filter { $0.amount < 0 }
            .reduce(0.0) { $0 + $1.amount })
    }
    
    /*
     üìä QUANTIDADE DE TRANSA√á√ïES
     
     Simple count, mas super √∫til para:
     - Exibir estat√≠sticas
     - Controlar empty states
     - Analytics e m√©tricas
     */
    var transactionCount: Int {
        transactions.count
    }
    
    /*
     üìà M√âDIA DE GASTOS
     
     √ötil para mostrar insights financeiros ao usu√°rio.
     Guard protege contra divis√£o por zero!
     
     Se n√£o houver gastos, retorna 0 (n√£o crash, n√£o NaN).
     */
    var averageExpense: Double {
        let expenses = transactions.filter { $0.amount < 0 }
        guard !expenses.isEmpty else { return 0 }
        return abs(expenses.reduce(0.0) { $0 + $1.amount }) / Double(expenses.count)
    }
    
    // MARK: - üé® Formatadores para UI (‚ú® PARTE 7 - NOVO!)
    
    /*
     üíµ FORMATAR MOEDA
     
     Transforma Double em String formatada bonita:
     1234.56 ‚Üí "R$ 1.234,56"
     
     Por que fun√ß√£o e n√£o computed property?
     - Precisa receber par√¢metro (value)
     - Reutiliz√°vel para qualquer valor
     - Pode ser passada como closure
     */
    func formatCurrency(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
    }
    
    /*
     üìÖ FORMATAR DATA
     
     Transforma Date em String leg√≠vel:
     Date() ‚Üí "12/10/2024 14:30"
     
     Configura√ß√£o locale garante formato brasileiro.
     */
    func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: date)
    }
    
    // MARK: - üîÑ Lifecycle (DA PARTE 6 - mantido)
    
    init() {
        print("üé≠ RealtimeDemoViewModel: Inicializando...")
    }
    
    deinit {
        stopListening()
        print("üßπ RealtimeDemoViewModel: Destru√≠do e listener removido")
    }
    
    // MARK: - üëÇ Listener Management (DA PARTE 6 - mantido)
    
    func startListening() {
        print("üéØ ViewModel: Iniciando escuta em tempo real...")
        
        guard !isListening else {
            print("‚ö†Ô∏è Listener j√° est√° ativo")
            return
        }
        
        isLoading = true
        connectionStatus = "üì° Conectando ao tempo real..."
        errorMessage = nil
        
        stopListening()
        
        transactionListener = transactionService.startListeningToUserTransactions(
            userId: currentUserId,
            limit: 50,
            onUpdate: { [weak self] transactions in
                DispatchQueue.main.async {
                    self?.handleTransactionsUpdate(transactions)
                }
            },
            onError: { [weak self] error in
                DispatchQueue.main.async {
                    self?.handleListenerError(error)
                }
            }
        )
        
        isListening = true
        connectionStatus = "‚úÖ Tempo real ativo"
        
        print("‚úÖ ViewModel: Listener ativo e aguardando mudan√ßas")
    }
    
    func stopListening() {
        print("üõë ViewModel: Parando listener...")
        
        transactionListener?.remove()
        transactionListener = nil
        isListening = false
        connectionStatus = "‚è∏Ô∏è Tempo real pausado"
        
        print("‚úÖ ViewModel: Listener removido com sucesso")
    }
    
    // MARK: - üîÑ Event Handlers (DA PARTE 6 - mantido)
    
    private func handleTransactionsUpdate(_ newTransactions: [Transaction]) {
        let previousCount = transactions.count
        let newCount = newTransactions.count
        
        print("üîÑ ViewModel: Recebendo atualiza√ß√£o...")
        print("   üìä Transa√ß√µes anteriores: \(previousCount)")
        print("   üìä Transa√ß√µes novas: \(newCount)")
        print("   üìà Diferen√ßa: \(newCount - previousCount)")
        
        transactions = newTransactions
        isLoading = false
        errorMessage = nil
        connectionStatus = "‚úÖ Sincronizado ‚Ä¢ \(newTransactions.count) transa√ß√µes"
        
        if newCount > previousCount {
            print("üéâ Novas transa√ß√µes detectadas!")
        }
    }
    
    private func handleListenerError(_ error: Error) {
        print("‚ùå ViewModel: Erro no listener: \(error.localizedDescription)")
        
        errorMessage = "Erro na sincroniza√ß√£o: \(error.localizedDescription)"
        isLoading = false
        connectionStatus = "üî¥ Erro na conex√£o"
    }
}


// ==========================================
// 2. Components/BalanceHeaderView.swift (‚ú® ARQUIVO NOVO)
// ==========================================

import SwiftUI

/*
 üí∞ BALANCE HEADER - Cabe√ßalho com Saldo e Estat√≠sticas
 
 Componente reutiliz√°vel que exibe:
 - Saldo total (com cor indicando positivo/negativo)
 - Total de receitas (verde)
 - Total de gastos (vermelho)
 - Anima√ß√µes suaves nas mudan√ßas de valor
 
 Design profissional com:
 - Shadow sutil para profundidade
 - Cores sem√¢nticas (verde=bom, vermelho=ruim)
 - Typography hier√°rquica (tamanhos diferentes)
 - Espa√ßamento consistente
 */
struct BalanceHeaderView: View {
    // PROPRIEDADES
    let totalBalance: Double
    let totalIncome: Double
    let totalExpenses: Double
    let formatter: (Double) -> String
    
    var body: some View {
        VStack(spacing: 16) {
            // üí∞ SALDO PRINCIPAL
            VStack(spacing: 4) {
                Text("Saldo Total")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                Text(formatter(totalBalance))
                    .font(.system(size: 36, weight: .bold, design: .rounded))
                    .foregroundColor(totalBalance >= 0 ? .green : .red)
                    .animation(.easeInOut(duration: 0.3), value: totalBalance)
                    // ‚ú® Anima√ß√£o suave quando valor muda!
            }
            
            // DIVIDER VISUAL
            Divider()
                .padding(.horizontal, 40)
            
            // üìä RECEITAS E GASTOS
            HStack(spacing: 40) {
                // üíö RECEITAS
                VStack(spacing: 4) {
                    HStack(spacing: 4) {
                        Image(systemName: "arrow.up.circle.fill")
                            .foregroundColor(.green)
                        Text("Receitas")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Text(formatter(totalIncome))
                        .font(.system(size: 18, weight: .semibold, design: .rounded))
                        .foregroundColor(.green)
                }
                
                // ‚ù§Ô∏è GASTOS
                VStack(spacing: 4) {
                    HStack(spacing: 4) {
                        Image(systemName: "arrow.down.circle.fill")
                            .foregroundColor(.red)
                        Text("Gastos")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Text(formatter(totalExpenses))
                        .font(.system(size: 18, weight: .semibold, design: .rounded))
                        .foregroundColor(.red)
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
                .shadow(color: .black.opacity(0.1), radius: 5, x: 0, y: 2)
        )
        .padding(.horizontal)
    }
}

// PREVIEW PARA DESENVOLVIMENTO
#Preview {
    BalanceHeaderView(
        totalBalance: 2500.50,
        totalIncome: 5000,
        totalExpenses: 2499.50,
        formatter: { value in
            let formatter = NumberFormatter()
            formatter.numberStyle = .currency
            formatter.locale = Locale(identifier: "pt_BR")
            return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
        }
    )
    .padding()
}


// ==========================================
// 3. Components/StatisticsCardView.swift (‚ú® ARQUIVO NOVO)
// ==========================================

import SwiftUI

/*
 üìä STATISTICS CARD - Card de Estat√≠stica Individual
 
 Componente gen√©rico e reutiliz√°vel para exibir:
 - √çcone SF Symbol com cor customizada
 - T√≠tulo da m√©trica
 - Valor formatado
 
 Benef√≠cios da reutiliza√ß√£o:
 - Consist√™ncia visual em todo app
 - F√°cil manuten√ß√£o (muda em um lugar)
 - Menos c√≥digo duplicado
 - Test√°vel isoladamente
 */
struct StatisticsCardView: View {
    // PROPRIEDADES CONFIGUR√ÅVEIS
    let icon: String        // Nome do SF Symbol
    let title: String       // Ex: "Transa√ß√µes"
    let value: String       // Ex: "24" ou "R$ 185,50"
    let color: Color        // Cor tem√°tica do card
    
    var body: some View {
        HStack(spacing: 12) {
            // üé® √çCONE CIRCULAR
            Image(systemName: icon)
                .font(.system(size: 24))
                .foregroundColor(color)
                .frame(width: 40, height: 40)
                .background(color.opacity(0.2))  // Fundo com 20% opacity
                .clipShape(Circle())
            
            // üìù TEXTO
            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text(value)
                    .font(.system(size: 16, weight: .semibold, design: .rounded))
                    .foregroundColor(.primary)
            }
            
            Spacer()
        }
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
        )
    }
}

// PREVIEW COM EXEMPLOS
#Preview {
    VStack(spacing: 12) {
        StatisticsCardView(
            icon: "chart.bar.fill",
            title: "Transa√ß√µes",
            value: "24",
            color: .blue
        )
        
        StatisticsCardView(
            icon: "chart.line.uptrend.xyaxis",
            title: "M√©dia de Gastos",
            value: "R$ 185,50",
            color: .orange
        )
    }
    .padding()
}


// ==========================================
// 4. Components/TransactionCardView.swift (‚ú® ARQUIVO NOVO)
// ==========================================

import SwiftUI

/*
 üí≥ TRANSACTION CARD - Card de Transa√ß√£o Individual
 
 Exibe uma transa√ß√£o com design moderno:
 - Indicador visual de tipo (receita/gasto)
 - Descri√ß√£o e data formatada
 - Valor com cor sem√¢ntica
 - Layout responsivo
 
 Por que computed property isIncome?
 - Evita repetir l√≥gica (transaction.amount > 0)
 - Melhora legibilidade do c√≥digo
 - Facilita manuten√ß√£o
 */
struct TransactionCardView: View {
    let transaction: Transaction
    let formatter: (Double) -> String
    let dateFormatter: (Date) -> String
    
    // COMPUTED PROPERTY
    private var isIncome: Bool {
        transaction.amount > 0
    }
    
    var body: some View {
        HStack(spacing: 12) {
            // üéØ INDICADOR VISUAL
            Circle()
                .fill(isIncome ? Color.green : Color.red)
                .frame(width: 8, height: 8)
            
            // üìù INFORMA√á√ïES
            VStack(alignment: .leading, spacing: 4) {
                Text(transaction.description)
                    .font(.system(size: 15, weight: .medium))
                    .foregroundColor(.primary)
                
                Text(dateFormatter(transaction.date))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // üí∞ VALOR
            Text(formatter(abs(transaction.amount)))
                .font(.system(size: 16, weight: .semibold, design: .rounded))
                .foregroundColor(isIncome ? .green : .red)
        }
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
        )
    }
}

/*
 ‚ö†Ô∏è PREVIEW COMENTADO
 
 Transaction precisa ser Hashable/Identifiable para funcionar em listas.
 Em app real, garantir que Transaction conforma esses protocolos.
 */


// ==========================================
// 5. Components/EmptyStateView.swift (‚ú® ARQUIVO NOVO)
// ==========================================

import SwiftUI

/*
 üì≠ EMPTY STATE - Estado Vazio Informativo
 
 Exibido quando lista de transa√ß√µes est√° vazia.
 
 Por que importante?
 - UX: Evita tela em branco confusa
 - Educa√ß√£o: Ensina usu√°rio o que fazer
 - Engajamento: Incentiva primeira a√ß√£o
 - Profissionalismo: Mostra cuidado com detalhes
 
 Elementos obrigat√≥rios de Empty State:
 1. √çcone grande (visual anchor)
 2. Texto principal (explica situa√ß√£o)
 3. Texto secund√°rio (pr√≥ximos passos)
 4. Call-to-action (bot√£o de a√ß√£o)
 */
struct EmptyStateView: View {
    var body: some View {
        VStack(spacing: 20) {
            // üé® √çCONE GRANDE
            Image(systemName: "chart.bar.doc.horizontal")
                .font(.system(size: 60))
                .foregroundColor(.secondary.opacity(0.5))
            
            // üìù TEXTO PRINCIPAL
            Text("Nenhuma Transa√ß√£o Ainda")
                .font(.title2)
                .fontWeight(.semibold)
                .foregroundColor(.primary)
            
            // üìã TEXTO SECUND√ÅRIO
            Text("Adicione sua primeira transa√ß√£o\npara ver estat√≠sticas em tempo real!")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)
            
            // üîµ BOT√ÉO DE A√á√ÉO
            Button(action: {
                // Em implementa√ß√£o real, abrir sheet de adicionar
                print("üìù Bot√£o adicionar pressionado")
            }) {
                HStack {
                    Image(systemName: "plus.circle.fill")
                    Text("Adicionar Transa√ß√£o")
                }
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal, 24)
                .padding(.vertical, 12)
                .background(Color.blue)
                .cornerRadius(12)
            }
            .padding(.top, 8)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// PREVIEW
#Preview {
    EmptyStateView()
}


// ==========================================
// 6. RealtimeDemoView.swift (ARQUIVO MODIFICADO - substituir body)
// ==========================================

import SwiftUI

/*
 üí´ REALTIME DEMO VIEW - Dashboard Profissional Completo
 
 Parte 6: Lista b√°sica de transa√ß√µes
 Parte 7: Dashboard completo com estat√≠sticas
 
 Estrutura do Dashboard:
 1. Status de conex√£o (topo)
 2. Header com balan√ßo (BalanceHeaderView)
 3. Cards de estat√≠sticas (StatisticsCardView)
 4. Lista de transa√ß√µes ou empty state
 
 Responsabilidades da View:
 - Renderiza√ß√£o (o que mostrar)
 - Layout (como organizar)
 - Intera√ß√£o (eventos de usu√°rio)
 
 N√ÉO faz:
 - L√≥gica de neg√≥cio (ViewModel)
 - Acesso direto a dados (Service)
 - C√°lculos complexos (ViewModel)
 */
struct RealtimeDemoView: View {
    @StateObject private var viewModel = RealtimeDemoViewModel()
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    
                    // üîå STATUS DE CONEX√ÉO
                    HStack {
                        Circle()
                            .fill(viewModel.isListening ? Color.green : Color.gray)
                            .frame(width: 8, height: 8)
                        
                        Text(viewModel.isListening ? "Tempo Real Ativo" : "Offline")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Spacer()
                    }
                    .padding(.horizontal)
                    
                    // üí∞ HEADER COM BALAN√áO
                    BalanceHeaderView(
                        totalBalance: viewModel.totalBalance,
                        totalIncome: viewModel.totalIncome,
                        totalExpenses: viewModel.totalExpenses,
                        formatter: viewModel.formatCurrency
                    )
                    
                    // üìä ESTAT√çSTICAS
                    VStack(spacing: 8) {
                        HStack(spacing: 12) {
                            StatisticsCardView(
                                icon: "chart.bar.fill",
                                title: "Transa√ß√µes",
                                value: "\(viewModel.transactionCount)",
                                color: .blue
                            )
                            
                            StatisticsCardView(
                                icon: "chart.line.uptrend.xyaxis",
                                title: "M√©dia de Gastos",
                                value: viewModel.formatCurrency(viewModel.averageExpense),
                                color: .orange
                            )
                        }
                    }
                    .padding(.horizontal)
                    
                    // üìã LISTA DE TRANSA√á√ïES
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Transa√ß√µes Recentes")
                            .font(.headline)
                            .padding(.horizontal)
                        
                        if viewModel.transactions.isEmpty {
                            // üì≠ EMPTY STATE
                            EmptyStateView()
                                .frame(height: 300)
                        } else {
                            // üìã LISTA
                            ForEach(viewModel.transactions.prefix(20)) { transaction in
                                TransactionCardView(
                                    transaction: transaction,
                                    formatter: viewModel.formatCurrency,
                                    dateFormatter: viewModel.formatDate
                                )
                                .padding(.horizontal)
                            }
                        }
                    }
                    
                    Spacer(minLength: 20)
                }
                .padding(.vertical)
            }
            .navigationTitle("üí´ Dashboard")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        viewModel.isListening ? viewModel.stopListening() : viewModel.startListening()
                    }) {
                        Image(systemName: viewModel.isListening ? "pause.circle.fill" : "play.circle.fill")
                            .foregroundColor(viewModel.isListening ? .orange : .green)
                    }
                }
            }
        }
        .onAppear {
            print("üì± Dashboard apareceu - iniciando listener")
            viewModel.startListening()
        }
        .onDisappear {
            print("üì± Dashboard desapareceu - parando listener")
            viewModel.stopListening()
        }
    }
}

// PREVIEW
#Preview {
    RealtimeDemoView()
}


// ==========================================
// üìù RESUMO DAS MUDAN√áAS
// ==========================================

/*
 ‚úÖ PARTE 6 ‚Üí PARTE 7: EVOLU√á√ÉO, N√ÉO REPETI√á√ÉO
 
 O que mantivemos da Parte 6:
 - TransactionService com listeners
 - RealtimeDemoViewModel b√°sico
 - Gest√£o de listeners (start/stop)
 - Sincroniza√ß√£o em tempo real
 
 O que adicionamos na Parte 7:
 - Computed properties para c√°lculos
 - Formatadores para UI
 - 4 componentes visuais profissionais
 - Dashboard completo e bonito
 - Estados visuais (empty, loading)
 
 Arquivos criados (5):
 1. BalanceHeaderView.swift
 2. StatisticsCardView.swift
 3. TransactionCardView.swift
 4. EmptyStateView.swift
 5. Este arquivo de documenta√ß√£o
 
 Arquivos modificados (2):
 1. RealtimeDemoViewModel.swift (+computed properties)
 2. RealtimeDemoView.swift (dashboard completo)
 
 üéØ RESULTADO:
 Transformamos interface b√°sica em dashboard profissional
 mantendo toda l√≥gica de listeners da Parte 6!
 */