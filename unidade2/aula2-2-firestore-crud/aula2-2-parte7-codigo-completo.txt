// ==========================================
// AULA 2.2 - PARTE 7: C√ìDIGO COMPLETO
// ==========================================

/*
 üìã ESTRUTURA DE ARQUIVOS:
 
 1. RealtimeDemoViewModel.swift (MODIFICADO)
 2. RealtimeDemoView.swift (MODIFICADO - Dashboard)
 3. Components/BalanceHeaderView.swift (NOVO)
 4. Components/StatisticsCardView.swift (NOVO)
 5. Components/TransactionCardView.swift (NOVO)
 6. Components/EmptyStateView.swift (NOVO)
*/


// ==========================================
// 1Ô∏è‚É£ RealtimeDemoViewModel.swift
// ==========================================

import SwiftUI
import FirebaseFirestore

@MainActor
class RealtimeDemoViewModel: ObservableObject {
    
    // MARK: - üìä Published Properties (DA PARTE 6)
    @Published var transactions: [Transaction] = []
    @Published var isListening = false
    @Published var message: String?
    
    // MARK: - üîß Dependencies (DA PARTE 6)
    private let service = TransactionService()
    private let userId = "demo_user"
    
    // MARK: - üéÆ Listener (DA PARTE 6 - ESSENCIAL!)
    /// ‚ö†Ô∏è nonisolated(unsafe) permite acesso no deinit
    nonisolated(unsafe) private var listener: ListenerRegistration?
    
    
    // MARK: - üì° Listener Control (DA PARTE 6)
    
    func startListening() {
        guard !isListening else {
            message = "‚ö†Ô∏è J√° est√° escutando!"
            return
        }
        
        print("‚ñ∂Ô∏è ViewModel: Iniciando listener...")
     
        listener = service.startListeningToUserTransactions(
            userId: userId,
            limit: 50,
            onUpdate: { [weak self] transactions in
                print("‚úÖ ViewModel: \(transactions.count) transa√ß√µes recebidas")
                self?.transactions = transactions
                self?.isListening = true
                self?.message = "‚úÖ Sincronizando (\(transactions.count) transa√ß√µes)"
            },
            onError: { [weak self] error in
                print("‚ùå ViewModel: Erro no listener: \(error.localizedDescription)")
                self?.isListening = false
                self?.message = "‚ùå Erro: \(error.localizedDescription)"
            }
        )

        print("‚úÖ ViewModel: Listener iniciado com sucesso")
    }

    }
    
    func stopListening() {
        print("üõë ViewModel: Parando listener...")
        cleanupListener()
        isListening = false
        message = "üõë Listener parado"
        print("‚úÖ ViewModel: Listener parado com sucesso")
    }
    
    // MARK: - üßπ Cleanup (DA PARTE 6 - CR√çTICO!)
    
    /// Limpa o listener (usado por stopListening e deinit)
    nonisolated private func cleanupListener() {
        listener?.remove()
        listener = nil
    }
    
    deinit {
        print("üßπ ViewModel: deinit chamado")
        cleanupListener()
        print("‚úÖ ViewModel: Cleanup completo")
    }
    
    
    // MARK: - üí∞ Computed Properties (‚ú® NOVO NA PARTE 7)
    /*
    ‚ö†Ô∏è IMPORTANTE: C√°lculos baseados nas √∫ltimas 50 transa√ß√µes
 
    Por quest√µes de performance, o listener carrega apenas as 50 
    transa√ß√µes mais recentes. Portanto, estes valores s√£o APROXIMADOS
    e representam apenas a atividade recente, n√£o o hist√≥rico completo.
 
    Em um app de produ√ß√£o, voc√™ deveria:
    1. Usar agrega√ß√£o do Firestore para totais reais
    2. Ter uma collection separada com totais consolidados
    3. Ou calcular totais no backend
    */
    
    /// Saldo das √∫ltimas 50 transa√ß√µes
    var totalBalance: Double {
        transactions.reduce(0.0) { $0 + $1.amount }
    }
    
    /// Total de receitas (valores positivos)
    var totalIncome: Double {
        transactions
            .filter { $0.amount > 0 }
            .reduce(0.0) { $0 + $1.amount }
    }
    
    /// Total de despesas (√∫ltimas 50 transa√ß√µes)
    var totalExpenses: Double {
        abs(transactions
            .filter { $0.amount < 0 }
            .reduce(0.0) { $0 + $1.amount })
    }
    
    /// Quantidade de transa√ß√µes (√∫ltimas 50 transa√ß√µes)
    var transactionCount: Int {
        transactions.count
    }
    
    /// M√©dia de gastos (√∫ltimas 50 transa√ß√µes)
    var averageExpense: Double {
        let expenses = transactions.filter { $0.amount < 0 }
        guard !expenses.isEmpty else { return 0 }
        return abs(expenses.reduce(0.0) { $0 + $1.amount }) / Double(expenses.count)
    }
    
    // MARK: - üé® Formatadores (‚ú® NOVO NA PARTE 7)
    
    /// Formata valor para moeda brasileira
    func formatCurrency(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
    }
    
    /// Formata data para formato brasileiro
    func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: date)
    }
}


// ==========================================
// 2Ô∏è‚É£ RealtimeDemoView.swift (Dashboard Completo)
// ==========================================

import SwiftUI

struct RealtimeDemoView: View {
    @StateObject private var viewModel = RealtimeDemoViewModel()
    
    var body: some View {
    NavigationView {
        ScrollView {
            VStack(spacing: 20) {

                // üîå STATUS DE CONEX√ÉO
                HStack {
                    Circle()
                        .fill(viewModel.isListening ? Color.green : Color.gray)
                        .frame(width: 8, height: 8)

                    Text(viewModel.isListening ? "Tempo Real Ativo" : "Offline")
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Spacer()
                }
                .padding(.horizontal)

                // üí∞ HEADER COM BALAN√áO
                BalanceHeaderView(
                    totalBalance: viewModel.totalBalance,
                    totalIncome: viewModel.totalIncome,
                    totalExpenses: viewModel.totalExpenses,
                    formatter: viewModel.formatCurrency
                )

                // üìä ESTAT√çSTICAS
                VStack(spacing: 8) {
                    HStack(spacing: 12) {
                        StatisticsCardView(
                            icon: "chart.bar.fill",
                            title: "Transa√ß√µes",
                            value: "\(viewModel.transactionCount)",
                            color: .blue
                        )

                        StatisticsCardView(
                            icon: "chart.line.uptrend.xyaxis",
                            title: "M√©dia de Gastos",
                            value: viewModel.formatCurrency(viewModel.averageExpense),
                            color: .orange
                        )
                    }
                }
                .padding(.horizontal)

                // üìã LISTA DE TRANSA√á√ïES
                VStack(alignment: .leading, spacing: 12) {
                    Text("Transa√ß√µes Recentes")
                        .font(.headline)
                        .padding(.horizontal)

                    if viewModel.transactions.isEmpty {
                        EmptyStateView()
                            .frame(height: 300)
                    } else {
                        ForEach(viewModel.transactions.prefix(20)) { transaction in
                            TransactionCardView(
                                transaction: transaction,
                                formatter: viewModel.formatCurrency,
                                dateFormatter: viewModel.formatDate
                            )
                            .padding(.horizontal)
                        }
                    }
                }

                Spacer(minLength: 20)
            }
            .padding(.vertical)
        }
        .navigationTitle("üí´ Dashboard")
        .navigationBarTitleDisplayMode(.large)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: {
                    viewModel.isListening ? viewModel.stopListening() : viewModel.startListening()
                }) {
                    Image(systemName: viewModel.isListening ? "pause.circle.fill" : "play.circle.fill")
                        .foregroundColor(viewModel.isListening ? .orange : .green)
                }
            }
        }
    }
    .onAppear {
        print("üì± Dashboard apareceu - iniciando listener")
        viewModel.startListening()
    }
    .onDisappear {
        print("üì± Dashboard desapareceu - parando listener")
        viewModel.stopListening()
    }
  }
}


// ==========================================
// 3Ô∏è‚É£ Components/BalanceHeaderView.swift
// ==========================================

import SwiftUI

/*
üí∞ BALANCE HEADER - Cabe√ßalho com Saldo e Estat√≠sticas

Mostra vis√£o geral financeira:
- Saldo total (verde se positivo, vermelho se negativo)
- Total de receitas
- Total de gastos
- Anima√ß√µes suaves nas mudan√ßas
*/
struct BalanceHeaderView: View {
    let totalBalance: Double
    let totalIncome: Double
    let totalExpenses: Double
    let formatter: (Double) -> String

    var body: some View {
        VStack(spacing: 16) {
            // üí∞ SALDO PRINCIPAL
            VStack(spacing: 4) {
                Text("Saldo Total")
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                Text(formatter(totalBalance))
                    .font(.system(size: 36, weight: .bold, design: .rounded))
                    .foregroundColor(totalBalance >= 0 ? .green : .red)
                    .animation(.easeInOut(duration: 0.3), value: totalBalance)
            }

            Divider()
                .padding(.horizontal, 40)

            // üìä RECEITAS E GASTOS
            HStack(spacing: 40) {
                // üíö RECEITAS
                VStack(spacing: 4) {
                    HStack(spacing: 4) {
                        Image(systemName: "arrow.up.circle.fill")
                            .foregroundColor(.green)
                        Text("Receitas")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }

                    Text(formatter(totalIncome))
                        .font(.system(size: 18, weight: .semibold, design: .rounded))
                        .foregroundColor(.green)
                }

                // ‚ù§Ô∏è GASTOS
                VStack(spacing: 4) {
                    HStack(spacing: 4) {
                        Image(systemName: "arrow.down.circle.fill")
                            .foregroundColor(.red)
                        Text("Gastos")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }

                    Text(formatter(totalExpenses))
                        .font(.system(size: 18, weight: .semibold, design: .rounded))
                        .foregroundColor(.red)
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
                .shadow(color: .black.opacity(0.1), radius: 5, x: 0, y: 2)
        )
        .padding(.horizontal)
    }
}

#Preview {
    BalanceHeaderView(
        totalBalance: 2500.50,
        totalIncome: 5000,
        totalExpenses: 2499.50,
        formatter: { value in
            let formatter = NumberFormatter()
            formatter.numberStyle = .currency
            formatter.locale = Locale(identifier: "pt_BR")
            return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
        }
    )
    .padding()
}

// ==========================================
// 4Ô∏è‚É£ Components/StatisticsCardView.swift
// ==========================================

import SwiftUI

/*
üìä STATISTICS CARD - Card de Estat√≠stica Individual

Exibe uma m√©trica espec√≠fica com √≠cone e valor.
Reutiliz√°vel para diferentes tipos de estat√≠sticas.
*/
struct StatisticsCardView: View {
    let icon: String
    let title: String
    let value: String
    let color: Color

    var body: some View {
        HStack(spacing: 12) {
            // √çCONE
            Image(systemName: icon)
                .font(.system(size: 24))
                .foregroundColor(color)
                .frame(width: 40, height: 40)
                .background(color.opacity(0.2))
                .clipShape(Circle())

            // TEXTO
            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.caption)
                    .foregroundColor(.secondary)

                Text(value)
                    .font(.system(size: 16, weight: .semibold, design: .rounded))
                    .foregroundColor(.primary)
            }

            Spacer()
        }
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
        )
    }
}

#Preview {
    VStack(spacing: 12) {
        StatisticsCardView(
            icon: "chart.bar.fill",
            title: "Transa√ß√µes",
            value: "24",
            color: .blue
        )

        StatisticsCardView(
            icon: "chart.line.uptrend.xyaxis",
            title: "M√©dia de Gastos",
            value: "R$ 185,50",
            color: .orange
        )
    }
    .padding()
}



// ==========================================
// 5Ô∏è‚É£ Components/TransactionCardView.swift
// ==========================================

import SwiftUI

/*
üí≥ TRANSACTION CARD - Card de Transa√ß√£o Individual

Exibe uma transa√ß√£o com:
- Indicador visual (cor/√≠cone)
- Descri√ß√£o e data
- Valor formatado
- Design moderno e responsivo
*/
struct TransactionCardView: View {
    let transaction: Transaction
    let formatter: (Double) -> String
    let dateFormatter: (Date) -> String

    private var isIncome: Bool {
        transaction.amount > 0
    }

    var body: some View {
        HStack(spacing: 12) {
            // INDICADOR VISUAL
            Circle()
                .fill(isIncome ? Color.green : Color.red)
                .frame(width: 8, height: 8)

            // INFORMA√á√ïES
            VStack(alignment: .leading, spacing: 4) {
                Text(transaction.description)
                    .font(.system(size: 15, weight: .medium))
                    .foregroundColor(.primary)

                Text(dateFormatter(transaction.date))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Spacer()

            // VALOR
            Text(formatter(abs(transaction.amount)))
                .font(.system(size: 16, weight: .semibold, design: .rounded))
                .foregroundColor(isIncome ? .green : .red)
        }
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemGroupedBackground))
        )
    }
}

// Preview comentado pois Transaction precisa ser Hashable



// ==========================================
// 6Ô∏è‚É£ Components/EmptyStateView.swift
// ==========================================

import SwiftUI

/*
üì≠ EMPTY STATE - Estado Vazio Informativo

Exibido quando n√£o h√° transa√ß√µes.
Importante para UX - evita tela em branco confusa.
*/
struct EmptyStateView: View {
    var body: some View {
        VStack(spacing: 20) {
            // √çCONE GRANDE
            Image(systemName: "chart.bar.doc.horizontal")
                .font(.system(size: 60))
                .foregroundColor(.secondary.opacity(0.5))

            // TEXTO PRINCIPAL
            Text("Nenhuma Transa√ß√£o Ainda")
                .font(.title2)
                .fontWeight(.semibold)
                .foregroundColor(.primary)

            // TEXTO SECUND√ÅRIO
            Text("Adicione sua primeira transa√ß√£o\npara ver estat√≠sticas em tempo real!")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)

            // BOT√ÉO DE A√á√ÉO
            Button(action: {}) {
                HStack {
                    Image(systemName: "plus.circle.fill")
                    Text("Adicionar Transa√ß√£o")
                }
                .font(.headline)
                .foregroundColor(.white)
                .padding(.horizontal, 24)
                .padding(.vertical, 12)
                .background(Color.blue)
                .cornerRadius(12)
            }
            .padding(.top, 8)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

#Preview {
    EmptyStateView()
}



// ==========================================
// üìù RESUMO - O QUE MUDOU DA PARTE 6 ‚Üí 7
// ==========================================

/*
 ‚úÖ PARTE 6 (Base):
 - TransactionService com listeners
 - RealtimeDemoViewModel b√°sico
 - Lista simples de transa√ß√µes
 - Start/Stop listener funcionando
 
 ‚ú® PARTE 7 (Evolu√ß√£o):
 - ViewModel: + computed properties + formatadores
 - View: Dashboard completo com componentes
 - 4 componentes novos: BalanceHeader, Statistics, TransactionCard, EmptyState
 - Design profissional com gradientes e shadows
 - Estados visuais (vazio, carregando)
 
 üîí COMPATIBILIDADE:
 - nonisolated(unsafe) listener MANTIDO
 - cleanupListener() MANTIDO
 - deinit MANTIDO
 - Mesmos nomes de propriedades
 - C√≥digo da P6 funciona sem mudan√ßas
 */
