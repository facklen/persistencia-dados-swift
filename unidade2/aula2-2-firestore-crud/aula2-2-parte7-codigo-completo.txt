// ==========================================
// AULA 2.2 - PARTE 7: RealtimeDemoViewModel.swift
// ‚úÖ CORRIGIDO - Mant√©m estrutura EXATA da Parte 6
// ==========================================

import SwiftUI
import FirebaseFirestore

/*
 üé≠ REALTIME DEMO VIEWMODEL - VERS√ÉO COMPLETA
 
 ‚úÖ PARTE 6: Gest√£o de listeners em tempo real
 ‚úÖ PARTE 7: + Computed properties + Formatadores
 
 ESTRUTURA:
 - @Published properties para UI reativa
 - Dependencies (service, userId)
 - Listener management (start/stop/cleanup)
 - Computed properties (saldo, receitas, gastos, etc) ‚Üê NOVO P7
 - Formatadores (moeda, data) ‚Üê NOVO P7
*/
@MainActor
class RealtimeDemoViewModel: ObservableObject {
    
    // MARK: - üìä Published Properties (DA PARTE 6)
    
    /// Transa√ß√µes sincronizadas em tempo real
    @Published var transactions: [Transaction] = []
    
    /// Estado do listener (ativo/inativo)
    @Published var isListening = false
    
    /// Mensagem de status para o usu√°rio
    @Published var message: String?
    
    // MARK: - üîß Dependencies (DA PARTE 6)
    
    private let service = TransactionService()
    private let userId = "demo_user"
    
    // MARK: - üéÆ Listener Management (DA PARTE 6)
    
    /*
     ‚ö†Ô∏è CRITICAL: nonisolated(unsafe) permite acesso no deinit
     
     Por que unsafe?
     - ListenerRegistration do Firebase √© thread-safe
     - Property √© privada (controlada)
     - S√≥ fazemos opera√ß√µes simples (remove + nil)
     
     Sem isso, deinit n√£o consegue limpar o listener!
     */
    nonisolated(unsafe) private var listener: ListenerRegistration?
    
    // MARK: - üì° Listener Control (DA PARTE 6 - EXATO!)
    
    /// Inicia escuta de transa√ß√µes em tempo real
    func startListening() {
        guard !isListening else {
            message = "‚ö†Ô∏è J√° est√° escutando!"
            return
        }
        
        print("‚ñ∂Ô∏è ViewModel: Iniciando listener...")
        
        // ‚úÖ ESTRUTURA EXATA DA PARTE 6
        // Duas closures: onUpdate e onError
        // DispatchQueue.main.async para voltar √† main thread
        // Tudo inline, sem m√©todos auxiliares
        listener = service.startListeningToUserTransactions(
            userId: userId,
            onUpdate: { [weak self] transactions in
                DispatchQueue.main.async {
                    print("‚úÖ ViewModel: \(transactions.count) transa√ß√µes recebidas")
                    self?.transactions = transactions
                    self?.isListening = true
                    self?.message = "‚úÖ Sincronizando (\(transactions.count) transa√ß√µes)"
                }
            },
            onError: { [weak self] error in
                DispatchQueue.main.async {
                    print("‚ùå ViewModel: Erro no listener: \(error.localizedDescription)")
                    self?.isListening = false
                    self?.message = "‚ùå Erro: \(error.localizedDescription)"
                }
            }
        )
    }
    
    /// Para a escuta de transa√ß√µes
    func stopListening() {
        print("üõë ViewModel: Parando listener...")
        cleanupListener()
        isListening = false
        message = "üõë Listener parado"
        print("‚úÖ ViewModel: Listener parado com sucesso")
    }
    
    // MARK: - üßπ Cleanup (DA PARTE 6 - CR√çTICO!)
    
    /*
     M√âTODO ESSENCIAL para evitar memory leaks!
     
     Por que nonisolated?
     - Pode ser chamado de deinit (n√£o-async)
     - Pode ser chamado de stopListening (@MainActor)
     
     Reutiliza√ß√£o: stopListening() e deinit() usam este m√©todo
     */
    nonisolated private func cleanupListener() {
        listener?.remove()
        listener = nil
    }
    
    /*
     DESTRUTOR - garante limpeza ao destruir ViewModel
     
     Cen√°rios:
     - Usu√°rio fecha a tela
     - App √© destru√≠do
     - ViewModel sai de mem√≥ria
     
     Sem cleanupListener aqui = memory leak!
     */
    deinit {
        print("üßπ ViewModel: deinit chamado")
        cleanupListener()
        print("‚úÖ ViewModel: Cleanup completo")
    }
    
    // MARK: - üí∞ Computed Properties Reativas (‚ú® NOVO NA PARTE 7)
    
    /*
     üßÆ SALDO TOTAL
     
     Calcula automaticamente quando transactions muda.
     Receitas positivas, gastos negativos.
     
     Reativo: SwiftUI re-renderiza automaticamente!
     */
    var totalBalance: Double {
        transactions.reduce(0.0) { $0 + $1.amount }
    }
    
    /*
     üíö TOTAL DE RECEITAS
     
     Soma apenas valores positivos.
     Filter + Reduce = pipeline funcional elegante!
     */
    var totalIncome: Double {
        transactions
            .filter { $0.amount > 0 }
            .reduce(0.0) { $0 + $1.amount }
    }
    
    /*
     ‚ù§Ô∏è TOTAL DE GASTOS
     
     Soma apenas valores negativos.
     abs() retorna valor absoluto para UI.
     */
    var totalExpenses: Double {
        abs(transactions
            .filter { $0.amount < 0 }
            .reduce(0.0) { $0 + $1.amount })
    }
    
    /*
     üìä QUANTIDADE DE TRANSA√á√ïES
     
     √ötil para:
     - Exibir estat√≠sticas
     - Controlar empty states
     - Analytics
     */
    var transactionCount: Int {
        transactions.count
    }
    
    /*
     üìà M√âDIA DE GASTOS
     
     Guard protege contra divis√£o por zero.
     Retorna 0 se n√£o houver gastos.
     */
    var averageExpense: Double {
        let expenses = transactions.filter { $0.amount < 0 }
        guard !expenses.isEmpty else { return 0 }
        return abs(expenses.reduce(0.0) { $0 + $1.amount }) / Double(expenses.count)
    }
    
    // MARK: - üé® Formatadores para UI (‚ú® NOVO NA PARTE 7)
    
    /*
     üíµ FORMATAR MOEDA
     
     Transforma Double em String formatada:
     1234.56 ‚Üí "R$ 1.234,56"
     
     Por que fun√ß√£o e n√£o computed property?
     - Precisa receber par√¢metro
     - Reutiliz√°vel para qualquer valor
     */
    func formatCurrency(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: NSNumber(value: value)) ?? "R$ 0,00"
    }
    
    /*
     üìÖ FORMATAR DATA
     
     Transforma Date em String leg√≠vel:
     Date() ‚Üí "12/10/2024 14:30"
     */
    func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: date)
    }
}

// ==========================================
// üìù RESUMO DAS MUDAN√áAS P6 ‚Üí P7
// ==========================================

/*
 ‚úÖ MANTIDO EXATAMENTE DA PARTE 6:
 - @Published properties (transactions, isListening, message)
 - Dependencies (service, userId)
 - nonisolated(unsafe) listener
 - startListening() com MESMA estrutura:
   * onUpdate closure com DispatchQueue.main.async
   * onError closure com DispatchQueue.main.async
   * Sem Task, sem m√©todos auxiliares
 - stopListening() id√™ntico
 - cleanupListener() id√™ntico
 - deinit id√™ntico
 
 ‚ú® ADICIONADO NA PARTE 7:
 - 5 computed properties (totalBalance, totalIncome, totalExpenses, transactionCount, averageExpense)
 - 2 formatadores (formatCurrency, formatDate)
 
 ‚ùå REMOVIDO (estava errado):
 - Task { @MainActor in } (n√£o existia na P6)
 - handleListenerError() m√©todo separado (n√£o existia na P6)
 - init() removido (n√£o era essencial)
 
 üîÑ COMPATIBILIDADE:
 - C√≥digo da Parte 6 funciona sem modifica√ß√µes
 - Apenas adicionamos features, n√£o quebramos nada
 - Estrutura de closures mantida identicamente
 */
